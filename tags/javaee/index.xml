<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javaee on KATSUMI KOKUZAWA&#39;S BLOG</title>
    <link>https://kokuzawa.github.io/tags/javaee/</link>
    <description>Recent content in Javaee on KATSUMI KOKUZAWA&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 28 Jun 2018 01:16:27 +0900</lastBuildDate>
    
	<atom:link href="https://kokuzawa.github.io/tags/javaee/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>子ノードにドロップをすると StackOverflowError が発生</title>
      <link>https://kokuzawa.github.io/blog/2018/06/28/bug-primefaces/</link>
      <pubDate>Thu, 28 Jun 2018 01:16:27 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/06/28/bug-primefaces/</guid>
      <description>要約 PrimeFaces-6.2 の Tree コンポーネントにバグがあります。
 この問題は報告済みです。 対応状況や詳しい内容は下記を参照してください。
Tree: &#34;StackOverflowError&#34; when a node is dropped to own child node
   再現方法 再現はとても簡単です。 PrimeFaces の Showcase で、 Node 0 をドラッグして Node 0.0 にドロップするだけです。
 この操作を実施するとエラー画面が表示されます。 以前はスタックトレースが画面に表示されたのですが、 新しいデザインになってからは表示がされず、何が起きたのかよくわからないかもしれません。 ローカル環境でこの操作を実施すると、下記のエラーが発生します。
 java.lang.StackOverflowError at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202) at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202) at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202) at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202)     </description>
    </item>
    
    <item>
      <title>PrimeFaces-6.1 Dblclick Event</title>
      <link>https://kokuzawa.github.io/blog/2017/12/04/primefaces-dblclick/</link>
      <pubDate>Mon, 04 Dec 2017 01:40:41 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2017/12/04/primefaces-dblclick/</guid>
      <description>今作っているWebアプリでリンクをダブルクリックで動作させるという要求が出たので、 どうやって実現するのか調べてみました。
 通常のリンクを実装してみる PrimeFacesの commandLink コンポーネントでリンクを実装します。
 &amp;lt;p:commandLink value=&#34;Single Click&#34; action=&#34;#{bean.onClick}&#34; /&amp;gt;     ダブルクリックで動作するリンクを実装してみる commandLink コンポーネントで実装すると、 onclick イベントで動作するようにレンダリングされてしまうので、 link コンポーネントで実装します。 href を指定するのがコツです。 link コンポーネントでは dblclick イベントだけを発生させ、実際の呼び出しは remoteCommand コンポーネントで行います。
 &amp;lt;p:link href=&#34;#&#34; value=&#34;Double Click&#34; ondblclick=&#34;dblClickEvent()&#34; /&amp;gt; &amp;lt;p:remoteCommand name=&#34;dblClickEvent&#34; action=&#34;#{bean.onClick}&#34; /&amp;gt;     </description>
    </item>
    
    <item>
      <title>JdbcRealm with WildFly 9.0.1.Final</title>
      <link>https://kokuzawa.github.io/blog/2015/12/25/jdbcrealm-with-wildfly-9-dot-0-1-dot-final/</link>
      <pubDate>Fri, 25 Dec 2015 20:50:08 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/12/25/jdbcrealm-with-wildfly-9-dot-0-1-dot-final/</guid>
      <description>以前、「WildFlyでJdbcRealm」 という記事を書きました。 これを現在インストールしている9.0.1.Final上で設定したところ、認証がうまく行われないことがわかりました。 大枠の変更はないのですが、DBに登録するパスワードのハッシュ文字列が当時とは異なる値である必要があったので、 忘れないようにメモしておきます。
差分 WildFly 8.0.0.Finalの時の設定:
&amp;lt;security-domain name=&amp;quot;app&amp;quot; cache-type=&amp;quot;default&amp;quot;&amp;gt; &amp;lt;authentication&amp;gt; &amp;lt;login-module name=&amp;quot;app_auth&amp;quot; code=&amp;quot;Database&amp;quot; flag=&amp;quot;required&amp;quot;&amp;gt; &amp;lt;module-option name=&amp;quot;dsJndiName&amp;quot; value=&amp;quot;java:jboss/datasources/ExampleDS&amp;quot;/&amp;gt; &amp;lt;module-option name=&amp;quot;principalsQuery&amp;quot; value=&amp;quot;SELECT PASSWORD FROM ACCOUNTS WHERE EMAIL = ?&amp;quot;/&amp;gt; &amp;lt;module-option name=&amp;quot;rolesQuery&amp;quot; value=&amp;quot;SELECT r.ROLENAME, &#39;Roles&#39; FROM ROLES r, ACCOUNTS a WHERE r.ACCOUNTID = a.ACCOUNTID AND a.EMAIL = ?&amp;quot;/&amp;gt; &amp;lt;module-option name=&amp;quot;hashAlgorithm&amp;quot; value=&amp;quot;SHA-256&amp;quot;/&amp;gt; &amp;lt;module-option name=&amp;quot;hashEncoding&amp;quot; value=&amp;quot;HEX&amp;quot;/&amp;gt; &amp;lt;/login-module&amp;gt; &amp;lt;/authentication&amp;gt; &amp;lt;/security-domain&amp;gt;  WildFly 9.0.1.Finalの設定:
&amp;lt;security-domain name=&amp;quot;app&amp;quot; cache-type=&amp;quot;default&amp;quot;&amp;gt; &amp;lt;authentication&amp;gt; &amp;lt;login-module name=&amp;quot;app_auth&amp;quot; code=&amp;quot;Database&amp;quot; flag=&amp;quot;required&amp;quot;&amp;gt; &amp;lt;module-option name=&amp;quot;dsJndiName&amp;quot; value=&amp;quot;java:jboss/datasources/ExampleDS&amp;quot;/&amp;gt; &amp;lt;module-option name=&amp;quot;principalsQuery&amp;quot; value=&amp;quot;SELECT PASSWORD FROM ACCOUNTS WHERE EMAIL = ?</description>
    </item>
    
    <item>
      <title>Server Sent Events</title>
      <link>https://kokuzawa.github.io/blog/2015/12/20/server-sent-events/</link>
      <pubDate>Sun, 20 Dec 2015 10:32:29 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/12/20/server-sent-events/</guid>
      <description>これは JavaEE Advent Calendar 2015 の20日目の記事です。
昨日は@yumix_hさんの「「帰ってきたGlassFish Users Group Japan勉強会」の未発表資料」でした。
明日は@emaggameさんです。
Server Sent Eventsとは Server Sent Events (SSE) はサーバから送られたイベントという意味の通り、push型のデータ通信を行うことができます。 これはHTML5で追加された新機能です。 同じくpush型のデータ通信を行う方法としてWebsocketがありますが、WebsocketがHTTPとは別のプロトコルで通信をするのに対し、 SSEではHTTPプロトコルを利用します。そのため、既存のHTTPを利用した通信との互換性が高いというメリットがある反面、 Websocketのような双方向の通信を行うことはできません。 HTTPプロトコルでpush通信を実現するため、SSEではサーバからのレスポンスを受けても接続を終了せずに継続させます。 こうすることで、サーバ側からのデータを継続して受信することを実現します。 このようにSSEはHTTPプロトコルで接続を行うのですが、クライアントがSSEだと認識できるデータを送ってもらう必要があります。 そこで、サーバはMIMEタイプにtext/event-streamを設定する必要があります。
JavaEE8にSSEのサポートが入るようですが、一足先にJAX-RSのRIであるJerseyでこの機能を試すことができます。
Server Sent Eventsを試す 今回実行した環境は下記の通りです。
 OS: Mac OSX 10.11.1 Java: Java&amp;trade; SE Runtime Environment (build 1.8.0_60-b27) APサーバ: GlasshFish-4.1.1 ブラウザ: Safari-9.0.1  実際のコードはGithubにあるので、 コードを見れば分かる方は以降の実装の説明を読むより、 そちらを見ていただいた方が早いかと思います。
sandbox/sse-example
実装の説明 Mavenを利用しているので、最初に下記のDependencyを追加します。 2015/12/10時点のMaven Centralの最新版は2.22.1のようです。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jersey-media-sse&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.22.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  サーバ側のリソースはMIMEタイプにtext/event-streamを設定する他に、 org.glassfish.jersey.media.sse.EventOutputを返却する必要があります。
@GET @Produces(SseFeature.SERVER_SENT_EVENTS) public EventOutput getServerSentEvents() { .</description>
    </item>
    
    <item>
      <title>RESTEasyとSpringの連携</title>
      <link>https://kokuzawa.github.io/blog/2014/12/20/resteasytospringfalselian-xi/</link>
      <pubDate>Sat, 20 Dec 2014 10:22:07 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/12/20/resteasytospringfalselian-xi/</guid>
      <description>Java EE Advent Calendar 2014の20日の記事です。
昨日は@yoshioteradaさんの「Java EE 8 の新機能概要のご紹介」でした。
明日は@suke_masaさんです。
Jersey-1.8を使ったアプリを最新の2.14に置き換えようと思ったところが始まりです。 サーバーがWildFlyだからRESTEasyが含まれているので、JerseyではなくRESTEasyを使えば良いのだけれども、 アプリ内でJersey MultiPartを使っているのでひとまずバージョンアップを試みたのですが、 いろいろ問題があって結局RESTEasyに置き換えました。
実際の運用はTomcatを使っているので、Tomcatでも動作する設定を考慮しています。 なので、WildFlyオンリーで考えた場合は不要な設定があるかもしれません。
環境  OS: Mac OSX Yosemite 10.10 Java: Java™ SE Runtime Environment (build 1.8.0-b132) メモリ: 4GB WildFly 8.0.0.Final  pom.xml 下記のdiendencyが必要です。JettisonじゃなくてJacksonを使いたいのでそのdependencyも追加しています。 あとファイルアップロードも使いたいので、resteasy-multipart-providerも入れています。 resteasy-springに依存してRESTEasyのコアライブラリは入るので定義の必要ありません。 Tomcatの場合、サーバにはJAX-RSの実装は入っていないのでscopeはcompileを指定します。 WildFlyの場合はscopeをcompileにすると起動時にエラーが発生するのでprovidedを指定します。 これは既にRESTEasyがサーバに含まれているから。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-servlet-initializer&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-multipart-provider&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-jackson-provider&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  web.xml web.xml には下記を追加します。 url-pattarnが/*以外の場合はresteasy.</description>
    </item>
    
    <item>
      <title>WildFlyでJdbcRealm</title>
      <link>https://kokuzawa.github.io/blog/2014/08/23/wildflydejdbcrealmwoshe-ding-suru/</link>
      <pubDate>Sat, 23 Aug 2014 15:50:18 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/08/23/wildflydejdbcrealmwoshe-ding-suru/</guid>
      <description>今回は WildFly 8.0.0.Final を利用してJdbcRealmを試してみます。
WildFly の設定 WildFly 8.0.0.Final に JDBCRealm を構築します。
まず、PostgreSQL を使ってとてもシンプルなテーブル構成を作ります。
Security Domain を追加します。 追加は WildFly の GUI コンソールから行います。 追加する Security Domain は Name: app, Cache Type: default です。
追加した Security Domain を開き、Login Module を追加します。 追加する Login Modile は Code: Database, Flg: required です。
追加した Login Module に Module Option を追加します。
追加する Module Option は下記表になります。 dsJndiName で指定するのは事前に登録した Datasource です。
   Key Value     dsJndiName java:/jdbc/realmSample   hashAlgorithm SHA-256   hashEncoding HEX   principalsQuery SELECT password FROM accounts WHERE email = ?</description>
    </item>
    
    <item>
      <title>JAX-RSで複数ファイルをアップロードするには</title>
      <link>https://kokuzawa.github.io/blog/2013/12/22/jaxrs-upload-multiple-files/</link>
      <pubDate>Sun, 22 Dec 2013 09:20:55 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/12/22/jaxrs-upload-multiple-files/</guid>
      <description>この記事はJava Advent Calendar 2013の22日目の記事です。
昨日は@nagaseyasuhitoさんの「mvn siteのtips三連発」でした。
明日は monzou さんです。
ファイルアップロードを実現するために何を使っていますか？
私はもっぱらJAX-RSを使っています。
ファイルアップロードはAX-RSの仕様には含まれていないのですが、ほとんどの実装でサポートされているようです。 その実装の中から、今回はJerseyを使った複数ファイルのアップロードについて紹介しようかと思います。
今回利用したJerseyはGlassFish4に含まれているものを利用します。
ライブラリとしては以下のjarになります。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jersey-media-multipart&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  さっそくHTMLから。複数のファイルをアップロードするので同じnameのfileフィールドを用意します。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;/&amp;gt; &amp;lt;title&amp;gt;JAX-RS upload multiple files example&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;rest/upload/multipleFiles&amp;quot;&amp;gt; &amp;lt;div&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot;/&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot;/&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Upload&amp;quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  で、実際にリクエストを受け取るJavaのコード。
package org.katsumi.resources; import org.glassfish.jersey.media.multipart.FormDataBodyPart; import org.glassfish.jersey.media.multipart.FormDataParam; import javax.ws.rs.Consumes; import javax.ws.rs.POST; import javax.ws.rs.Path; import javax.ws.rs.Produces; import javax.</description>
    </item>
    
    <item>
      <title>JavaEE 7 リリース！</title>
      <link>https://kokuzawa.github.io/blog/2013/06/14/javaee7-release/</link>
      <pubDate>Fri, 14 Jun 2013 01:53:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/06/14/javaee7-release/</guid>
      <description>JavaEE 7 がというかGlassFish 4 がリリースされた。
会社でテストサーバとして使っているのは、GlassFish 3.1.2.2 なので早速入れ替えてみた。 余談だが運用サーバはTomcatなので、どちらかというとテストサーバの方が性能が良い。
で、意気揚々と起動してみた訳なのだが、起動できない。
理由は単純で、GlassFish 4 はJDK7が必須にもかかわらず、プロジェクトのJDKのバージョンがJDK6なのである。 まあコンパイル時にサーバのクラスのバージョンよりも古いバージョンでコンパイルしているよ、という警告が出ていたので 何となくは思っていたのだが、改めて起動できないとちょっとショックではある。
ひとまず、DataSourceの設定が今までと同じように出来ることは確認したので、 それについて書こうと思う。
ドライバの配置 GlassFishで利用できるJDBCドライバには下記のものがある。
Administration Guide:
 ■ IBM DB2 Database Type 2 Driver
■ IBM DB2 Database Type 4 Driver
■ Java DB/Derby Type 4 Driver
■ MySQL Server Database Type 4 Driver
■ Oracle 10 Database Driver
■ Oracle 11 Database Driver
■ PostgreSQL Type 4 Driver
■ DataDirect Type 4 Driver for IBM DB2 Database</description>
    </item>
    
    <item>
      <title>Performance of JPA</title>
      <link>https://kokuzawa.github.io/blog/2013/01/27/performance-of-jpa/</link>
      <pubDate>Sun, 27 Jan 2013 12:08:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/01/27/performance-of-jpa/</guid>
      <description> JPAはJavaSE上でも動作するので、DBアクセスをする場合、最近はもっぱらJDBCではなくJPAを利用している。 サーバサイドを利用しない、クライアントアプリでDBアクセスをするのは、主にデータ移行ツールとかが多く、 ひとつのトランザクション内で処理されるレコード数が数万レコードになる事が多い。
数万レコードを移行する為に、JPAを利用した移行ツールを作り、実データでテストをしたところ、 想定外のパフォーマンス劣化が発生し、その解決に幾分か時間が掛かってしまった。 そのため、パフォーマンスが劣化する状況とその解決方法を簡易に示す為の簡易なコードを作成、備忘録として残しておく。
アプリ構成 JavaはJDK7、JPAの実装はEclipseLink-2.3.2を利用。DBはDerby。
コード 検証に利用するコードは下記の通り。 Bookエンティティを1万レコード永続化する。この際、永続化だけではパフォーマンスの劣化を確認できないため、 永続化されたBookエンティティのうち、bookname=&#39;name1&#39;のレコードを抽出する。 また、検証に利用する為に、ループ1回の処理時間(ms)をファイルに出力する。
 検証 まず改善前の結果。縦軸は処理時間(ms)、横軸は回数。 約5,000回で一度速度が改善しているが、全体的に右肩上がりで処理時間が劣化している。 簡易なコードであり、処理時間が数msのため、このままでも致命的な状況にならないかもしれないが、 tachされたエンティティの数が増加すると、それに比例して劣化していく。
次に改善後の結果。 約5,000回で速度が改善するのは同じだが、一定速度以上の劣化は起こらず安定している。
改善方法 では、何をすれば改善するのか。 結論から言えば、エンティティをdetachすれば良い。 detachすることによってエンティティはエンティティマネージャの管理外になり、通常のJavaのオブジェクトになる。 そのため、同期のためのオーバヘッドがなくなり、パフォーマンスが改善するのだと考えられるが確証はないので、 あとでEclipseLinkのソースコードを確認してみようと思う。 ただし、これによりDBとの同期は行えなくなるため、detachをする位置には注意が必要。
検証コードでは、ループ内の最後に下記2行を追加した。
em.flush(); em.clear();  em.flush()を呼び出しているのは、Bookエンティティが永続化される前にdetachされるのを回避するため。 ただし、これも注意が必要で、リレーション関係のあるエンティティを両方とも永続化しようとするケース等で、 片方をpersist、他方をpersistする前にflushしてしまうと、他方の永続化時にエラーが発生してしまう。
ちなみにflushやclearに関しては次の本が詳しい。
 </description>
    </item>
    
    <item>
      <title>Convert the Alerts component of &#39;Bootstrap&#39; to a component of JSF 2.0</title>
      <link>https://kokuzawa.github.io/blog/2013/01/13/facesmessagetobootstrap/</link>
      <pubDate>Sun, 13 Jan 2013 18:46:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/01/13/facesmessagetobootstrap/</guid>
      <description>JSFのMessagesコンポーネントは、Managed Beanで設定されたFacesMessageを出力する為のコンポーネントです。 出力方法は、listとTableの二つのレイアウトを利用した方法があり、デフォルトはlistレイアウトです。 listレイアウトは以下のような出力になります。
(Bootstrapのalert alert-errorを適用)
これに対してTableレイアウトは以下のような出力になります。
どちらもエラーを表示するには十分ですが、ユーザとしては確認したらエラー情報を消したいところです。 MessagesコンポーネントはHTMLをカスタマイズする事ができません。 正確にはレンダラをカスタマイズすれば、出力するHTMLを書き換える事が出来ますし、 そういった情報を扱ったブログもありますが、Messagesレンダラのカスタマイズは、 com.sunパッケージのクラスを継承して拡張する必要があり、JSFの実装依存のコードになってしまいます。 もちろん独自で一からレンダラを書いても良いのですが、あまり現実的ではありません。 そこで、標準のMessagesコンポーネントではなくBootstrapのAlertsコンポーネントを使うことにします。
BootstrapのAlertsコンポーネントはクローズボタンを表示する事ができます。 このクローズボタンをクリックする事により、エラー情報を消すことができます。 クローズボタンを出すには、HTMLを下記のように記載する必要があります。
&amp;lt;div class=&amp;quot;alert alert-error&amp;quot;&amp;gt; &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; data-dismiss=&amp;quot;alert&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/button&amp;gt; &amp;lt;h4&amp;gt;Summary Message&amp;lt;/h4&amp;gt; Detail Message &amp;lt;/div&amp;gt;  これをJSF合成コンポーネントにします。 webapp/resources/bootstrapフォルダを作成し、alert.xhtmlファイルを配置します。(フォルダ構成はMavenです)
alert.xhtml:
&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;quot;&amp;gt; &amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xmlns:cc=&amp;quot;http://java.sun.com/jsf/composite&amp;quot; xmlns:c=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot;&amp;gt; &amp;lt;!-- INTERFACE --&amp;gt; &amp;lt;cc:interface&amp;gt; &amp;lt;/cc:interface&amp;gt; &amp;lt;!-- IMPLEMENTATION --&amp;gt; &amp;lt;cc:implementation&amp;gt; &amp;lt;c:forEach var=&amp;quot;message&amp;quot; items=&amp;quot;#{facesContext.messageList}&amp;quot;&amp;gt; &amp;lt;c:if test=&amp;quot;#{message.severity == &#39;ERROR 2&#39;}&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;alert alert-error&amp;quot;&amp;gt; &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; data-dismiss=&amp;quot;alert&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/button&amp;gt; &amp;lt;h4&amp;gt;#{message.</description>
    </item>
    
    <item>
      <title>Point-to-Point on JMS</title>
      <link>https://kokuzawa.github.io/blog/2012/12/15/point-to-point-on-jms/</link>
      <pubDate>Sat, 15 Dec 2012 15:50:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/12/15/point-to-point-on-jms/</guid>
      <description>JavaEE Advent Calendar 2012の15日目のエントリーです。
昨日は@yoshioteradaさんのJava EE 7 WebSocket Client Sample Application with JavaFXです。
明日は@akirakoyasuさんです。
普段は使わないJMSを使う おそらくJMSの本来の利用方法は非同期通信を利用した分散処理なのだと思うけど、今回はそんな高尚な目的ではなく、単純なメッセンジャーとして利用します。 世の中のどの位のプロジェクトでJMSが利用されているのか分からないけど、JavaEEの仕様にJMSが含まれているにも関わらず、今まで本格的に利用した事がありません。 分散処理をするケースがあるプロジェクトに参加した事が無いのか、またはサーバがいつもTomcatだからなのか。 おそらく後者なのだと思うけど、ということはつまり分散処理の必要がないプロジェクトということなんだと思います。
そんな事もあって、JMSの知識が皆無だったわけですが、 JavaEEのアドベンドカレンダーをやるに当たって何か普段は触らないようなことをやりたいなと思い立ち、JMSを使ってみる事にしました。
必要なもの  GlassFish-3.1.2.2 jms-api-1.1-rev-1.jar  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.jms&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jms-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1-rev-1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   imq-4.5.2.jar  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.glassfish.mq&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;imq&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  JMSを利用する為には、メッセージプロバイダが必要になります。プロバイダにはOpenMQ, MQSeries, SonicMQなどがありますが、 今回は導入が簡単なOpenMQを利用します。OpenMQはGlassFishに付属してインストールされます。インストール時に特に何かを意識する必要はありません。 また、OpenMQにアクセスする為に2つのライブラリが必要になります。jms-apiとimqです。Mavenリポジトリに登録されているので、 こちらも容易に入手可能です。
事前準備 GlassFishを起動しておく必要があります。ポートとして7676を利用するので、GlassFishがローカルではなく、リモート環境にある場合は、 ポートへのアクセスを許可する必要があるかもしれません。
メッセージプロデューサーを作る メッセージを送信するプロデューサーを作ります。
package jp.co.baykraft.jmsexample; import com.sun.messaging.ConnectionConfiguration; import com.sun.messaging.QueueConnectionFactory; import javax.jms.JMSException; import javax.jms.Queue; import javax.jms.QueueConnection; import javax.jms.QueueSender; import javax.jms.QueueSession; import javax.</description>
    </item>
    
  </channel>
</rss>