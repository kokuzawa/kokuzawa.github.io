<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jax Rs on Katsumi Kokuzawa&#39;s Blog</title>
    <link>https://kokuzawa.github.io/tags/jax-rs/</link>
    <description>Recent content in Jax Rs on Katsumi Kokuzawa&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 20 Dec 2015 10:32:29 +0900</lastBuildDate>
    
	<atom:link href="https://kokuzawa.github.io/tags/jax-rs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Server Sent Events</title>
      <link>https://kokuzawa.github.io/posts/blog/2015/12/20/server-sent-events/</link>
      <pubDate>Sun, 20 Dec 2015 10:32:29 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/posts/blog/2015/12/20/server-sent-events/</guid>
      <description>これは JavaEE Advent Calendar 2015 の20日目の記事です。
昨日は@yumix_hさんの「「帰ってきたGlassFish Users Group Japan勉強会」の未発表資料」でした。
明日は@emaggameさんです。
Server Sent Eventsとは Server Sent Events (SSE) はサーバから送られたイベントという意味の通り、push型のデータ通信を行うことができます。 これはHTML5で追加された新機能です。 同じくpush型のデータ通信を行う方法としてWebsocketがありますが、WebsocketがHTTPとは別のプロトコルで通信をするのに対し、 SSEではHTTPプロトコルを利用します。そのため、既存のHTTPを利用した通信との互換性が高いというメリットがある反面、 Websocketのような双方向の通信を行うことはできません。 HTTPプロトコルでpush通信を実現するため、SSEではサーバからのレスポンスを受けても接続を終了せずに継続させます。 こうすることで、サーバ側からのデータを継続して受信することを実現します。 このようにSSEはHTTPプロトコルで接続を行うのですが、クライアントがSSEだと認識できるデータを送ってもらう必要があります。 そこで、サーバはMIMEタイプにtext/event-streamを設定する必要があります。
JavaEE8にSSEのサポートが入るようですが、一足先にJAX-RSのRIであるJerseyでこの機能を試すことができます。
Server Sent Eventsを試す 今回実行した環境は下記の通りです。
 OS: Mac OSX 10.11.1 Java: Java&amp;trade; SE Runtime Environment (build 1.8.0_60-b27) APサーバ: GlasshFish-4.1.1 ブラウザ: Safari-9.0.1  実際のコードはGithubにあるので、 コードを見れば分かる方は以降の実装の説明を読むより、 そちらを見ていただいた方が早いかと思います。
sandbox/sse-example
実装の説明 Mavenを利用しているので、最初に下記のDependencyを追加します。 2015/12/10時点のMaven Centralの最新版は2.22.1のようです。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jersey-media-sse&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.22.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  サーバ側のリソースはMIMEタイプにtext/event-streamを設定する他に、 org.glassfish.jersey.media.sse.EventOutputを返却する必要があります。
@GET @Produces(SseFeature.SERVER_SENT_EVENTS) public EventOutput getServerSentEvents() { .</description>
    </item>
    
    <item>
      <title>JAX-RSでStreamを扱う</title>
      <link>https://kokuzawa.github.io/posts/blog/2015/10/15/stream-in-jaxrs/</link>
      <pubDate>Thu, 15 Oct 2015 02:44:04 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/posts/blog/2015/10/15/stream-in-jaxrs/</guid>
      <description>JAX-RSでExcelファイルをダウンロードする際にストリームを直接触る必要があって、 どうすればストリームにアクセスできるかちょっと調べてみました。 Excelファイルの生成にはApache POIを使っています。
Apache POIでExcelファイルを生成する場合、下記のようなコードを書きます。
final Workbook wb = new HSSFWorkbook(); final FileOutputStream fileOut = new FileOutputStream(&amp;quot;workbook.xls&amp;quot;); wb.write(fileOut); fileOut.close();  生成したファイルをファイルとして保存せずにServletでダウンロードしようとした場合、 そのコードは下記のようにHttpServletResponse#getOutputStream()でアウトプットストリームを取得し、 レスポンスボディに対してストリーミング処理をすることになります。
final Workbook wb = new HSSFWorkbook(); final FileOutputStream fileOut = new FileOutputStream(response.getOutputStream()); wb.write(fileOut); fileOut.close();  ここからが本題です。
JAX-RSでファイルをダウンロードするにはどうしたら良いのか。
通常のファイルの場合は下記のようなコードを書くことで実現できます。
final File file = new File(&amp;quot;workbook.xls&amp;quot;); return Response.ok(file).build();  Servletでのダウンロードのように、 レスポンスボディに対してストリーミング処理をする場合はjavax.ws.rs.core.StreamingOutputクラスを利用します。 そのコードは下記のようになります。
final Workbook wb = new HSSFWorkbook(); final StreamingOutput so = out -&amp;gt; wb.write(out); return Response.ok(stream).build();  </description>
    </item>
    
    <item>
      <title>Googleのテキスト読み上げAPIを組み込む（その２）</title>
      <link>https://kokuzawa.github.io/posts/blog/2015/05/07/continue-translate-google/</link>
      <pubDate>Thu, 07 May 2015 15:34:12 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/posts/blog/2015/05/07/continue-translate-google/</guid>
      <description>先日書いたコードがiOSのSafariで上手く動きませんでした。
Googleのテキスト読み上げAPIを組み込む
子供向けなのでiPhoneまたはiPadで音声が再生されないと困ります。 いろいろ調べたけれど、JavaScriptから呼び出す方法がわからないので 勝手知ったるJavaの世界に取り込んでiOSのSafariでも音声が再生されるようにしました。
下記がそのコードです。
@Path(&amp;quot;/tts&amp;quot;) public class TTSResource { @GET @Produces(&amp;quot;audio/mpeg&amp;quot;) public Response textToSpeech(@QueryParam(&amp;quot;text&amp;quot;) String text) throws IOException { final URL url = new URL(&amp;quot;http://translate.google.com/translate_tts?tl=en&amp;amp;q=&amp;quot; + text); final URLConnection connection = url.openConnection(); connection.setRequestProperty(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla&amp;quot;); return Response.ok(connection.getInputStream()).build(); } }  JAX-RSでGoogle Translateの結果をそのままレスポンスとして返すようにしています。 User-Agentを指定していないと上手く動きません。 ここで気がついたのですがUser-Agentで振る舞いが変わるようなので、 もしかしたらiOSからのアクセスの場合にもUser-Agentを偽装できれば音声が再生されるのかもしれないです。
先日の記事にも書きましたがクライアント側（javaScript）は下記のようになります。
&amp;lt;h:outputScript&amp;gt; function play() { var voice = new Audio(); voice.src = &amp;quot;${request.contextPath}/rest/tts?text=one&amp;quot;; voice.play(); } &amp;lt;/h:outputScript&amp;gt; &amp;lt;a href=&amp;quot;javascript:play()&amp;quot;&amp;gt;音声&amp;lt;/a&amp;gt;  </description>
    </item>
    
    <item>
      <title>RESTEasyとSpringの連携</title>
      <link>https://kokuzawa.github.io/posts/blog/2014/12/20/resteasytospringfalselian-xi/</link>
      <pubDate>Sat, 20 Dec 2014 10:22:07 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/posts/blog/2014/12/20/resteasytospringfalselian-xi/</guid>
      <description>Java EE Advent Calendar 2014の20日の記事です。
昨日は@yoshioteradaさんの「Java EE 8 の新機能概要のご紹介」でした。
明日は@suke_masaさんです。
Jersey-1.8を使ったアプリを最新の2.14に置き換えようと思ったところが始まりです。 サーバーがWildFlyだからRESTEasyが含まれているので、JerseyではなくRESTEasyを使えば良いのだけれども、 アプリ内でJersey MultiPartを使っているのでひとまずバージョンアップを試みたのですが、 いろいろ問題があって結局RESTEasyに置き換えました。
実際の運用はTomcatを使っているので、Tomcatでも動作する設定を考慮しています。 なので、WildFlyオンリーで考えた場合は不要な設定があるかもしれません。
環境  OS: Mac OSX Yosemite 10.10 Java: Java™ SE Runtime Environment (build 1.8.0-b132) メモリ: 4GB WildFly 8.0.0.Final  pom.xml 下記のdiendencyが必要です。JettisonじゃなくてJacksonを使いたいのでそのdependencyも追加しています。 あとファイルアップロードも使いたいので、resteasy-multipart-providerも入れています。 resteasy-springに依存してRESTEasyのコアライブラリは入るので定義の必要ありません。 Tomcatの場合、サーバにはJAX-RSの実装は入っていないのでscopeはcompileを指定します。 WildFlyの場合はscopeをcompileにすると起動時にエラーが発生するのでprovidedを指定します。 これは既にRESTEasyがサーバに含まれているから。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-servlet-initializer&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-multipart-provider&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-jackson-provider&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;resteasy-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  web.xml web.xml には下記を追加します。 url-pattarnが/*以外の場合はresteasy.</description>
    </item>
    
    <item>
      <title>FlexとJavaFXでREST-APIを呼び出す</title>
      <link>https://kokuzawa.github.io/posts/blog/2014/11/03/javafxderest-apiwohu-bichu-su/</link>
      <pubDate>Mon, 03 Nov 2014 17:12:02 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/posts/blog/2014/11/03/javafxderest-apiwohu-bichu-su/</guid>
      <description>FlexとJavaFXからREST-APIを呼び出してみました。
環境  OS: Mac OSX Yosemite 10.10 Java: Java&amp;trade; SE Runtime Environment (build 1.8.0-b132) Flex SDK 4.6 メモリ: 4GB WildFly 8.0.0.Final  サーバの用意 今回の本題ではないので、ここでは簡単な文字列を返すだけのAPIを作成します。 引数で受け取った文字を加工して「Hello XXX!」という文字を返します。 RESTの実装にはJersey-2.8を利用します。
import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import javax.ws.rs.QueryParam; import javax.ws.rs.core.MediaType; @Path(&amp;quot;/hello&amp;quot;) public class HelloService { @GET @Produces(MediaType.TEXT_PLAIN) public String hello(@QueryParam(&amp;quot;string&amp;quot;) String string) { return String.format(&amp;quot;Hello %s!&amp;quot;, string); } }  FlexからのREST-API呼び出し JavaFXとの比較のためにFlexからのREST-API呼び出しを提示します。
画面構成を管理するMXMLです。
Main.mxml:
&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt; &amp;lt;s:WindowedApplication xmlns:fx=&amp;quot;http://ns.adobe.com/mxml/2009&amp;quot; xmlns:s=&amp;quot;library://ns.adobe.com/flex/spark&amp;quot; xmlns:local=&amp;quot;*&amp;quot; title=&amp;quot;Hello World&amp;quot; width=&amp;quot;230&amp;quot; height=&amp;quot;80&amp;quot;&amp;gt; &amp;lt;fx:Declarations&amp;gt; &amp;lt;local:Controller id=&amp;quot;controller&amp;quot;/&amp;gt; &amp;lt;/fx:Declarations&amp;gt; &amp;lt;s:VGroup paddingBottom=&amp;quot;10&amp;quot; paddingLeft=&amp;quot;10&amp;quot; paddingRight=&amp;quot;10&amp;quot; paddingTop=&amp;quot;10&amp;quot; gap=&amp;quot;10&amp;quot; minHeight=&amp;quot;0&amp;quot;&amp;gt; &amp;lt;s:HGroup&amp;gt; &amp;lt;s:TextInput id=&amp;quot;stringField&amp;quot;/&amp;gt; &amp;lt;s:Button label=&amp;quot;Button&amp;quot; click=&amp;quot;{controller.</description>
    </item>
    
  </channel>
</rss>