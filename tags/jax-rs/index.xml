<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jax Rs on KATSUMI KOKUZAWA&#39;S BLOG</title>
    <link>https://kokuzawa.github.io/tags/jax-rs/</link>
    <description>Recent content in Jax Rs on KATSUMI KOKUZAWA&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 22 Nov 2018 22:07:16 +0900</lastBuildDate>
    
        <atom:link href="https://kokuzawa.github.io/tags/jax-rs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[JAX-RS] Validation Json to Enum Convert</title>
      <link>https://kokuzawa.github.io/blog/2018/11/22/validation-json-to-enum-convert/</link>
      <pubDate>Thu, 22 Nov 2018 22:07:16 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/11/22/validation-json-to-enum-convert/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_概要&#34;&gt;概要&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;JAX-RSでJSONプロパティをEnumプロパティに変換する際にBean Validationで値の検証をします。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_環境&#34;&gt;環境&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WildFly 14.0.0.Final&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_ひとまず普通に実装してみる&#34;&gt;ひとまず普通に実装してみる&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;作るのは最低限の３点セット＋テストクラス。
テストクラスで設定しているパラメータの &lt;code&gt;MONDAY&lt;/code&gt; はわざと間違えて &lt;code&gt;MONDAYY&lt;/code&gt; にしています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;MyApplication.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.katsumi.rest;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath(&#34;api&#34;)
public class MyApplication extends Application
{
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;TestParam.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.katsumi.rest.request;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import java.time.DayOfWeek;

public class TestParam
{
    @NotNull
    @Pattern(regexp = &#34;(MONDAY|TUESDAY|WEDNESDAY|THURSDAY|FRIDAY|SATURDAY|SUNDAY)&#34;)
    private DayOfWeek dayOfWeek;

    public DayOfWeek getDayOfWeek()
    {
        return dayOfWeek;
    }

    public void setDayOfWeek(DayOfWeek dayOfWeek)
    {
        this.dayOfWeek = dayOfWeek;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;TestResource.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.katsumi.rest;

import org.katsumi.rest.request.TestParam;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.time.DayOfWeek;
import java.util.HashMap;

@Path(&#34;/test&#34;)
public class TestResource
{
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response postTest(@NotNull @Valid TestParam param)
    {
        final HashMap&amp;lt;DayOfWeek, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(DayOfWeek.MONDAY, &#34;月&#34;);
        map.put(DayOfWeek.TUESDAY, &#34;火&#34;);
        map.put(DayOfWeek.WEDNESDAY, &#34;水&#34;);
        map.put(DayOfWeek.THURSDAY, &#34;木&#34;);
        map.put(DayOfWeek.FRIDAY, &#34;金&#34;);
        map.put(DayOfWeek.SATURDAY, &#34;土&#34;);
        map.put(DayOfWeek.SUNDAY, &#34;日&#34;);

        final HashMap&amp;lt;String, String&amp;gt; response = new HashMap&amp;lt;&amp;gt;();
        response.put(&#34;dayOfWeek&#34;, map.get(param.getDayOfWeek()));
        return Response.ok(response).build();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;TestResourceTest.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.katsumi.rest;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import org.junit.jupiter.api.Test;

import static org.hamcrest.Matchers.equalTo;

class TestResourceTest
{
    @Test
    void testJsonToEnum()
    {
        RestAssured.baseURI = &#34;http://localhost:8080/json-to-enum/api&#34;;
        RestAssured
                .given()
                .contentType(ContentType.JSON)
                .body(&#34;{\&#34;dayOfWeek\&#34;:\&#34;MONDAYY\&#34;}&#34;)
                .when()
                .post(&#34;/test&#34;)
                .then()
                .body(&#34;dayOfWeek&#34;, equalTo(&#34;月&#34;));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_実行してみる&#34;&gt;実行してみる&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;実行すると下記のエラーが発生します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;javax.ws.rs.ProcessingException: RESTEASY008200: JSON Binding deserialization error&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;いや、エラーになることは望んでいたんですけど、
こういうのじゃなくてBean Validationのエラーになって欲しい。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_修正してみる&#34;&gt;修正してみる&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;という訳で、Bean Validationのエラーになるようにパラメータクラスを修正します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;TestParam.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;package org.katsumi.rest.request;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import java.time.DayOfWeek;

public class TestParam
{
    @NotNull
    @Pattern(regexp = &#34;(MONDAY|TUESDAY|WEDNESDAY|THURSDAY|FRIDAY|SATURDAY|SUNDAY)&#34;)
-    private DayOfWeek dayOfWeek;
+    private String dayOfWeek;

    public DayOfWeek getDayOfWeek()
    {
-        return dayOfWeek;
+        return DayOfWeek.valueOf(dayOfWeek);
    }

-    public void setDayOfWeek(DayOfWeek dayOfWeek)
+    public void setDayOfWeek(String dayOfWeek)
    {
        this.dayOfWeek = dayOfWeek;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;直接 &lt;code&gt;DayOfWeek&lt;/code&gt; にするのではなく、 &lt;code&gt;String&lt;/code&gt; で受け取って、使う際にgetterで &lt;code&gt;DayOfWeek&lt;/code&gt; で所得するように修正しました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_拡張&#34;&gt;拡張&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ここまでの対応でBean Validationによるチェックが行われるようになるのですが、
それを確認する方法がHTTPステータスコードぐらいしかありません。
そこで、Bean ValidationのエラーをJSONで返却するように下記のファイルを追加します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;ValidationError.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.katsumi.rest.mapper;

public class ValidationError
{
    private String path;
    private String message;

    public String getPath()
    {
        return path;
    }

    public String getMessage()
    {
        return message;
    }

    public ValidationError(String path, String message)
    {
        this.path = path;
        this.message = message;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;ConstraintViolationExceptionMapper.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.katsumi.rest.mapper;

import javax.validation.ConstraintViolationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;
import java.util.List;
import java.util.stream.Collectors;

@Provider
public class ConstraintViolationExceptionMapper
        implements ExceptionMapper&amp;lt;ConstraintViolationException&amp;gt;
{
    @Override
    public Response toResponse(ConstraintViolationException e)
    {
        final List&amp;lt;ValidationError&amp;gt; errors = e.getConstraintViolations().stream()
                .map(cv -&amp;gt; new ValidationError(
                        cv.getPropertyPath().toString(), cv.getMessage()))
                .collect(Collectors.toList());
        return Response.status(Response.Status.BAD_REQUEST)
                .type(MediaType.APPLICATION_JSON)
                .entity(errors)
                .build();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;レスポンスの形式が変わるので、テストクラスも修正します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;TestResourceTest.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;package org.katsumi.rest;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import org.junit.jupiter.api.Test;

import static org.hamcrest.Matchers.equalTo;

class TestResourceTest
{
    @Test
    void testJsonToEnum()
    {
        RestAssured.baseURI = &#34;http://localhost:8080/json-to-enum/api&#34;;
        RestAssured
                .given()
                .contentType(ContentType.JSON)
                .body(&#34;{\&#34;dayOfWeek\&#34;:\&#34;MONDAYY\&#34;}&#34;)
                .when()
                .post(&#34;/test&#34;)
                .then()
-                .body(&#34;dayOfWeek&#34;, equalTo(&#34;月&#34;))
+                .body(&#34;message[0]&#34;, equalTo(&#34;must match \&#34;(MONDAY|TUESDAY|WEDNESDAY|THURSDAY|FRIDAY|SATURDAY|SUNDAY)\&#34;&#34;))
+                .body(&#34;path[0]&#34;, equalTo(&#34;test.arg0.dayOfWeek&#34;));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;これで実行するとテストケースが正常終了します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://rest-assured.io/&#34; class=&#34;bare&#34;&gt;http://rest-assured.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Server Sent Events</title>
      <link>https://kokuzawa.github.io/blog/2015/12/20/server-sent-events/</link>
      <pubDate>Sun, 20 Dec 2015 10:32:29 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/12/20/server-sent-events/</guid>
      <description>

&lt;p&gt;これは &lt;a href=&#34;http://qiita.com/advent-calendar/2015/javaee&#34;&gt;JavaEE Advent Calendar 2015&lt;/a&gt; の20日目の記事です。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/yumix_h&#34;&gt;@yumix_h&lt;/a&gt;さんの「&lt;a href=&#34;http://yumix.hatenablog.jp/entry/2015/12/19/205954&#34;&gt;「帰ってきたGlassFish Users Group Japan勉強会」の未発表資料&lt;/a&gt;」でした。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/emaggame&#34;&gt;@emaggame&lt;/a&gt;さんです。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;server-sent-eventsとは&#34;&gt;Server Sent Eventsとは&lt;/h2&gt;

&lt;p&gt;Server Sent Events (SSE) はサーバから送られたイベントという意味の通り、push型のデータ通信を行うことができます。
これはHTML5で追加された新機能です。
同じくpush型のデータ通信を行う方法としてWebsocketがありますが、WebsocketがHTTPとは別のプロトコルで通信をするのに対し、
SSEではHTTPプロトコルを利用します。そのため、既存のHTTPを利用した通信との互換性が高いというメリットがある反面、
Websocketのような双方向の通信を行うことはできません。
HTTPプロトコルでpush通信を実現するため、SSEではサーバからのレスポンスを受けても接続を終了せずに継続させます。
こうすることで、サーバ側からのデータを継続して受信することを実現します。
このようにSSEはHTTPプロトコルで接続を行うのですが、クライアントがSSEだと認識できるデータを送ってもらう必要があります。
そこで、サーバはMIMEタイプに&lt;code&gt;text/event-stream&lt;/code&gt;を設定する必要があります。&lt;/p&gt;

&lt;p&gt;JavaEE8にSSEのサポートが入るようですが、一足先にJAX-RSのRIであるJerseyでこの機能を試すことができます。&lt;/p&gt;

&lt;h2 id=&#34;server-sent-eventsを試す&#34;&gt;Server Sent Eventsを試す&lt;/h2&gt;

&lt;p&gt;今回実行した環境は下記の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX 10.11.1&lt;/li&gt;
&lt;li&gt;Java: Java&amp;trade; SE Runtime Environment (build 1.8.0_60-b27)&lt;/li&gt;
&lt;li&gt;APサーバ: GlasshFish-4.1.1&lt;/li&gt;
&lt;li&gt;ブラウザ: Safari-9.0.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際のコードはGithubにあるので、
コードを見れば分かる方は以降の実装の説明を読むより、
そちらを見ていただいた方が早いかと思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kokuzawa/sandbox/tree/master/sse-example&#34;&gt;sandbox/sse-example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装の説明&#34;&gt;実装の説明&lt;/h2&gt;

&lt;p&gt;Mavenを利用しているので、最初に下記のDependencyを追加します。
2015/12/10時点のMaven Centralの最新版は2.22.1のようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jersey-media-sse&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.22.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サーバ側のリソースはMIMEタイプに&lt;code&gt;text/event-stream&lt;/code&gt;を設定する他に、
&lt;code&gt;org.glassfish.jersey.media.sse.EventOutput&lt;/code&gt;を返却する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GET
@Produces(SseFeature.SERVER_SENT_EVENTS)
public EventOutput getServerSentEvents()
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;EventOutput&lt;/code&gt;を返却するだけだと、クライアントとの接続が確立しているだけの状態なので、
実際にクライアントに送信するデータを書き込む必要があります。
書き込みは&lt;code&gt;EventOutput#write(OutboundEvent)&lt;/code&gt;で行います。
単純には下記のような実装になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final EventOutput eventOutput = new EventOutput();
final OutboundEvent.Builder builder = new OutboundEvent.Builder();
builder.name(&amp;quot;message-to-client&amp;quot;);
builder.data(String.class, &amp;quot;Hello world !&amp;quot;);
eventOutput.write(builder.build());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;builder.name(...)&lt;/code&gt;で指定している文字列はクライアント側でイベントのマッピングをするために利用します。&lt;/p&gt;

&lt;p&gt;今回クライアントはJavascriptにします。
JavascriptでSSEを利用するには&lt;code&gt;EventSource&lt;/code&gt;クラスを利用します。
&lt;code&gt;EventSource&lt;/code&gt;を利用した実装は下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var eventList = document.getElementById(&amp;quot;eventList&amp;quot;);
var eventSource = new EventSource(&amp;quot;http://localhost:8080/sse-example/api/sse/events&amp;quot;);
eventSource.addEventListener(&amp;quot;message-to-client&amp;quot;, function (e) {
    var newElement = document.createElement(&amp;quot;li&amp;quot;);
    newElement.innerHTML = &amp;quot;message: &amp;quot; + e.data;
    eventList.appendChild(newElement);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EventSourceコンストラクタの引数でAPIエンドポイントを指定します。
addEventListenerでサーバからのイベントをハンドリングします。
この時、リスナーに設定するイベント名として、サーバ側コードで指定したイベント名を指定します。
この例では&amp;rdquo;message-to-client&amp;rdquo;です。&lt;/p&gt;

&lt;p&gt;さて、実際のコードの説明です。&lt;br /&gt;
ユースケースとして複数のユーザがそれぞれブラウザの画面を表示している状態で、
データが登録されると、開いている画面に登録された旨を伝えるメッセージを表示することを考えます。
まず必要なのは接続を確立するために&lt;code&gt;EventOutput&lt;/code&gt;を返却するサービスです。
&lt;code&gt;EventOutput&lt;/code&gt;はクライアントごとにインスタンスが必要なので、
接続が確立した&lt;code&gt;EventOutput&lt;/code&gt;を格納するためのリストも合わせて定義します。
これらを踏まえて下記のコードを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private List&amp;lt;EventOutput&amp;gt; eventOutputs = new ArrayList&amp;lt;&amp;gt;();

@GET
@Path(&amp;quot;events&amp;quot;)
@Produces(SseFeature.SERVER_SENT_EVENTS)
public EventOutput getServerSentEvents()
{
    final EventOutput eventOutput = new EventOutput();
    eventOutputs.add(eventOutput);
    return eventOutput;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に登録をするためのサービスを作ります。が、実際に何かを登録するのは実装が面倒なので、
サービスが呼ばれたら各クライアントにメッセージをpushするだけにします。
こんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PUT
@Path(&amp;quot;put&amp;quot;)
public void putData() throws IOException
{
    for (EventOutput eventOutput : eventOutputs) {
        final OutboundEvent.Builder builder = new OutboundEvent.Builder();
        builder.name(&amp;quot;message-to-client&amp;quot;);
        builder.data(String.class, &amp;quot;登録された！&amp;quot;);
        eventOutput.write(builder.build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでサービス側は実装完了です。
Javascriptクライアントを実装する前に正しく動くかcurlコマンドで確認してみます。
接続確立のサービスを下記のように呼び出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/sse-example/api/sse/events
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロンプトが待ち状態になりました。接続されたままになったのでうまくいったようです！
別のプロンプトから次のコマンドを実行して最初のプロンプトに通知されるか確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X PUT http://localhost:8080/sse-example/api/sse/put
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初のプロンプトの方に以下のメッセージが表示されました。こちらもうまくいったようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event: message-to-client
data: 登録された！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サービス側が正常に動作することが確認できたので、
次にJavascriptクライアントを作ります。
HTMLを含めた全コードは下記のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;SSE Example&amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
        function startup() {
            var eventList = document.getElementById(&amp;quot;eventList&amp;quot;);
            var eventSource = new EventSource(&amp;quot;http://localhost:8080/sse-example/api/sse/events&amp;quot;);
            eventSource.addEventListener(&amp;quot;message-to-client&amp;quot;, function (e) {
                var newElement = document.createElement(&amp;quot;li&amp;quot;);
                newElement.innerHTML = &amp;quot;message: &amp;quot; + e.data;
                eventList.appendChild(newElement);
            });
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&amp;quot;startup()&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;イベント表示:&amp;lt;/h1&amp;gt;
    &amp;lt;ul id=&amp;quot;eventList&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;このようにSSEの実装は比較的簡単に行うことがでます。
ただ最初にも書いたようにSSEは一方向通信なので、push通信だけでなく双方向通信を行いたい場合は
Websocketを利用することになります。
利用シーンとしてはWebsocketの方が多くなりそうですが、
既存のアプリにpush通知機能を実装するという観点からであれば、
HTTPプロトコルで動作するSSEを利用した方が良いケースがあるかもしれないですね。&lt;/p&gt;

&lt;h2 id=&#34;参考にしたサイト&#34;&gt;参考にしたサイト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jersey.java.net/documentation/latest/sse.html&#34;&gt;Chapter 15. Server-Sent Events (SSE) Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JAX-RSでStreamを扱う</title>
      <link>https://kokuzawa.github.io/blog/2015/10/15/stream-in-jaxrs/</link>
      <pubDate>Thu, 15 Oct 2015 02:44:04 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/10/15/stream-in-jaxrs/</guid>
      <description>&lt;p&gt;JAX-RSでExcelファイルをダウンロードする際にストリームを直接触る必要があって、
どうすればストリームにアクセスできるかちょっと調べてみました。
Excelファイルの生成にはApache POIを使っています。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;Apache POIでExcelファイルを生成する場合、下記のようなコードを書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Workbook wb = new HSSFWorkbook();
final FileOutputStream fileOut = new FileOutputStream(&amp;quot;workbook.xls&amp;quot;);
wb.write(fileOut);
fileOut.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成したファイルをファイルとして保存せずにServletでダウンロードしようとした場合、
そのコードは下記のように&lt;code&gt;HttpServletResponse#getOutputStream()&lt;/code&gt;でアウトプットストリームを取得し、
レスポンスボディに対してストリーミング処理をすることになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Workbook wb = new HSSFWorkbook();
final FileOutputStream fileOut = new FileOutputStream(response.getOutputStream());
wb.write(fileOut);
fileOut.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここからが本題です。&lt;br /&gt;
JAX-RSでファイルをダウンロードするにはどうしたら良いのか。&lt;br /&gt;
通常のファイルの場合は下記のようなコードを書くことで実現できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final File file = new File(&amp;quot;workbook.xls&amp;quot;);
return Response.ok(file).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Servletでのダウンロードのように、
レスポンスボディに対してストリーミング処理をする場合は&lt;code&gt;javax.ws.rs.core.StreamingOutput&lt;/code&gt;クラスを利用します。
そのコードは下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Workbook wb = new HSSFWorkbook();
final StreamingOutput so = out -&amp;gt; wb.write(out);
return Response.ok(stream).build();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Googleのテキスト読み上げAPIを組み込む（その２）</title>
      <link>https://kokuzawa.github.io/blog/2015/05/07/continue-translate-google/</link>
      <pubDate>Thu, 07 May 2015 15:34:12 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/05/07/continue-translate-google/</guid>
      <description>&lt;p&gt;先日書いたコードがiOSのSafariで上手く動きませんでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kokuzawa.github.io/blog/2015/05/03/translate-google/&#34;&gt;Googleのテキスト読み上げAPIを組み込む&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;子供向けなのでiPhoneまたはiPadで音声が再生されないと困ります。
いろいろ調べたけれど、JavaScriptから呼び出す方法がわからないので
勝手知ったるJavaの世界に取り込んでiOSのSafariでも音声が再生されるようにしました。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;下記がそのコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Path(&amp;quot;/tts&amp;quot;)
public class TTSResource
{
    @GET
    @Produces(&amp;quot;audio/mpeg&amp;quot;)
    public Response textToSpeech(@QueryParam(&amp;quot;text&amp;quot;) String text) throws IOException
    {
        final URL url = new URL(&amp;quot;http://translate.google.com/translate_tts?tl=en&amp;amp;q=&amp;quot; + text);
        final URLConnection connection = url.openConnection();
        connection.setRequestProperty(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla&amp;quot;);
        return Response.ok(connection.getInputStream()).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JAX-RSでGoogle Translateの結果をそのままレスポンスとして返すようにしています。
User-Agentを指定していないと上手く動きません。
ここで気がついたのですがUser-Agentで振る舞いが変わるようなので、
もしかしたらiOSからのアクセスの場合にもUser-Agentを偽装できれば音声が再生されるのかもしれないです。&lt;/p&gt;

&lt;p&gt;先日の記事にも書きましたがクライアント側（javaScript）は下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h:outputScript&amp;gt;
function play() {
    var voice = new Audio();
    voice.src = &amp;quot;${request.contextPath}/rest/tts?text=one&amp;quot;;
    voice.play();
}
&amp;lt;/h:outputScript&amp;gt;

&amp;lt;a href=&amp;quot;javascript:play()&amp;quot;&amp;gt;音声&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>RESTEasyとSpringの連携</title>
      <link>https://kokuzawa.github.io/blog/2014/12/20/resteasytospringfalselian-xi/</link>
      <pubDate>Sat, 20 Dec 2014 10:22:07 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/12/20/resteasytospringfalselian-xi/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2014/javaee&#34;&gt;Java EE Advent Calendar 2014&lt;/a&gt;の20日の記事です。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/yoshioterada&#34;&gt;@yoshioterada&lt;/a&gt;さんの「&lt;a href=&#34;http://yoshio3.com/2014/12/19/java-ee-8-new-features/&#34;&gt;Java EE 8 の新機能概要のご紹介&lt;/a&gt;」でした。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/suke_masa&#34;&gt;@suke_masa&lt;/a&gt;さんです。&lt;/p&gt;

&lt;p&gt;Jersey-1.8を使ったアプリを最新の2.14に置き換えようと思ったところが始まりです。
サーバーがWildFlyだからRESTEasyが含まれているので、JerseyではなくRESTEasyを使えば良いのだけれども、
アプリ内でJersey MultiPartを使っているのでひとまずバージョンアップを試みたのですが、
いろいろ問題があって結局RESTEasyに置き換えました。&lt;/p&gt;

&lt;p&gt;実際の運用はTomcatを使っているので、Tomcatでも動作する設定を考慮しています。
なので、WildFlyオンリーで考えた場合は不要な設定があるかもしれません。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX Yosemite 10.10&lt;/li&gt;
&lt;li&gt;Java: Java™ SE Runtime Environment (build 1.8.0-b132)&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;WildFly 8.0.0.Final&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pom-xml&#34;&gt;pom.xml&lt;/h2&gt;

&lt;p&gt;下記のdiendencyが必要です。JettisonじゃなくてJacksonを使いたいのでそのdependencyも追加しています。
あとファイルアップロードも使いたいので、&lt;code&gt;resteasy-multipart-provider&lt;/code&gt;も入れています。
&lt;code&gt;resteasy-spring&lt;/code&gt;に依存してRESTEasyのコアライブラリは入るので定義の必要ありません。
Tomcatの場合、サーバにはJAX-RSの実装は入っていないのでscopeはcompileを指定します。
WildFlyの場合はscopeをcompileにすると起動時にエラーが発生するのでprovidedを指定します。
これは既にRESTEasyがサーバに含まれているから。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-servlet-initializer&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-multipart-provider&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-jackson-provider&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;web-xml&#34;&gt;web.xml&lt;/h2&gt;

&lt;p&gt;web.xml には下記を追加します。
url-pattarnが&lt;code&gt;/*&lt;/code&gt;以外の場合は&lt;code&gt;resteasy.servlet.mapping.prefix&lt;/code&gt;の設定が必要です。
&lt;code&gt;resteasy.scan&lt;/code&gt;で自動的にJAX-RSのコンポーネントをスキャンする設定ができるのですが、
springと連携する場合は自動スキャンはしちゃダメ。
自動スキャンしようとすると&lt;code&gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&lt;/code&gt;でエラーになります。&lt;/p&gt;

&lt;p&gt;ということは、@Providerとか@PathがついたクラスはすべてSpringのコンポーネントにしておく必要があります。
あとApplicationのサブクラスはなくても大丈夫です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&lt;/code&gt;を追加しているので、
&lt;code&gt;org.springframework.web.context.ContextLoaderListener&lt;/code&gt;は指定しちゃダメ。
指定すると起動に失敗します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;resteasy.servlet.mapping.prefix&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;/rest&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;
  
  &amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;

  &amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;
  
  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;Resteasy&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&amp;lt;/servlet-class&amp;gt;
  &amp;lt;/servlet&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;Resteasy&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/rest/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これでJAX-RSのリソースクラスにも@AutowiredでDIできるようになります。
RESTEasyのドキュメントに詳細に書いてあるんだけど、web.xmlの設定方法がServletのバージョンを考慮したパターンとか
いろいろありすぎて逆に困る。結局いろいろ試した末に上記の設定にたどり着きました。&lt;/p&gt;

&lt;p&gt;同じようなことをしようとしている人の何かの参考になれば。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FlexとJavaFXでREST-APIを呼び出す</title>
      <link>https://kokuzawa.github.io/blog/2014/11/03/javafxderest-apiwohu-bichu-su/</link>
      <pubDate>Mon, 03 Nov 2014 17:12:02 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/11/03/javafxderest-apiwohu-bichu-su/</guid>
      <description>

&lt;p&gt;FlexとJavaFXからREST-APIを呼び出してみました。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX Yosemite 10.10&lt;/li&gt;
&lt;li&gt;Java: Java&amp;trade; SE Runtime Environment (build 1.8.0-b132)&lt;/li&gt;
&lt;li&gt;Flex SDK 4.6&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;WildFly 8.0.0.Final&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;サーバの用意&#34;&gt;サーバの用意&lt;/h2&gt;

&lt;p&gt;今回の本題ではないので、ここでは簡単な文字列を返すだけのAPIを作成します。
引数で受け取った文字を加工して「Hello XXX!」という文字を返します。
RESTの実装にはJersey-2.8を利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;

@Path(&amp;quot;/hello&amp;quot;)
public class HelloService
{
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello(@QueryParam(&amp;quot;string&amp;quot;) String string)
    {
        return String.format(&amp;quot;Hello %s!&amp;quot;, string);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flexからのrest-api呼び出し&#34;&gt;FlexからのREST-API呼び出し&lt;/h2&gt;

&lt;p&gt;JavaFXとの比較のためにFlexからのREST-API呼び出しを提示します。&lt;/p&gt;

&lt;p&gt;画面構成を管理するMXMLです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Main.mxml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;s:WindowedApplication
        xmlns:fx=&amp;quot;http://ns.adobe.com/mxml/2009&amp;quot;
        xmlns:s=&amp;quot;library://ns.adobe.com/flex/spark&amp;quot;
        xmlns:local=&amp;quot;*&amp;quot; 
        title=&amp;quot;Hello World&amp;quot; 
        width=&amp;quot;230&amp;quot; 
        height=&amp;quot;80&amp;quot;&amp;gt;
    &amp;lt;fx:Declarations&amp;gt;
        &amp;lt;local:Controller id=&amp;quot;controller&amp;quot;/&amp;gt;
    &amp;lt;/fx:Declarations&amp;gt;
    &amp;lt;s:VGroup paddingBottom=&amp;quot;10&amp;quot; 
              paddingLeft=&amp;quot;10&amp;quot; 
              paddingRight=&amp;quot;10&amp;quot; 
              paddingTop=&amp;quot;10&amp;quot; 
              gap=&amp;quot;10&amp;quot; 
              minHeight=&amp;quot;0&amp;quot;&amp;gt;
        &amp;lt;s:HGroup&amp;gt;
            &amp;lt;s:TextInput id=&amp;quot;stringField&amp;quot;/&amp;gt;
            &amp;lt;s:Button label=&amp;quot;Button&amp;quot; click=&amp;quot;{controller.buttonAction(event)}&amp;quot;/&amp;gt;
        &amp;lt;/s:HGroup&amp;gt;
        &amp;lt;s:Label id=&amp;quot;stringLabel&amp;quot;/&amp;gt;
    &amp;lt;/s:VGroup&amp;gt;
&amp;lt;/s:WindowedApplication&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面をコントロールするコントローラクラスです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller.as:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-as&#34;&gt;package {
    import flash.events.MouseEvent;

    import mx.core.IMXMLObject;
    import mx.rpc.events.ResultEvent;
    import mx.rpc.http.mxml.HTTPService;

    public class Controller implements IMXMLObject
    {
        private var _document:Main;

        public function initialized(document:Object, id:String):void
        {
            _document = document as Main;
        }

        public function buttonAction(event:MouseEvent):void
        {
            var service:HTTPService = new HTTPService(&amp;quot;http://localhost:8080&amp;quot;);
            service.url = &amp;quot;/jaxrs/rest/hello&amp;quot;;
            service.addEventListener(ResultEvent.RESULT, function (e:ResultEvent):void
            {
                _document.stringLabel.text = e.result as String;
            });
            service.send({string:_document.stringField.text});
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動すると下記の画面が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_37.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;javafxからrest-apiを呼び出す&#34;&gt;JavaFXからREST-APIを呼び出す&lt;/h2&gt;

&lt;p&gt;JavaFXからの呼び出し例を提示します。&lt;/p&gt;

&lt;p&gt;画面構成を管理するFXMLです。
画面レイアウトにはSceneBuilder-2.0を利用しました。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sample.fxml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;?import javafx.geometry.Insets?&amp;gt;
&amp;lt;?import javafx.scene.control.Button?&amp;gt;
&amp;lt;?import javafx.scene.control.Label?&amp;gt;
&amp;lt;?import javafx.scene.control.TextField?&amp;gt;
&amp;lt;?import javafx.scene.layout.*?&amp;gt;
&amp;lt;GridPane alignment=&amp;quot;center&amp;quot; 
          hgap=&amp;quot;10&amp;quot; 
          prefHeight=&amp;quot;46.0&amp;quot; 
          prefWidth=&amp;quot;324.0&amp;quot; 
          vgap=&amp;quot;10&amp;quot; 
          xmlns=&amp;quot;http://javafx.com/javafx/8&amp;quot; 
          xmlns:fx=&amp;quot;http://javafx.com/fxml/1&amp;quot; 
          fx:controller=&amp;quot;sample.Controller&amp;quot;&amp;gt;
   &amp;lt;columnConstraints&amp;gt;
      &amp;lt;ColumnConstraints /&amp;gt;
      &amp;lt;ColumnConstraints minWidth=&amp;quot;10.0&amp;quot; prefWidth=&amp;quot;60.0&amp;quot; /&amp;gt;
   &amp;lt;/columnConstraints&amp;gt;
   &amp;lt;rowConstraints&amp;gt;
      &amp;lt;RowConstraints /&amp;gt;
      &amp;lt;RowConstraints minHeight=&amp;quot;10.0&amp;quot; prefHeight=&amp;quot;30.0&amp;quot; /&amp;gt;
   &amp;lt;/rowConstraints&amp;gt;
   &amp;lt;children&amp;gt;
      &amp;lt;TextField fx:id=&amp;quot;stringField&amp;quot; prefHeight=&amp;quot;26.0&amp;quot; prefWidth=&amp;quot;205.0&amp;quot; /&amp;gt;
      &amp;lt;Button mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;Button&amp;quot; GridPane.columnIndex=&amp;quot;1&amp;quot; onAction=&amp;quot;#buttonAction&amp;quot;/&amp;gt;
      &amp;lt;Label fx:id=&amp;quot;stringLabel&amp;quot; GridPane.columnSpan=&amp;quot;2&amp;quot; GridPane.rowIndex=&amp;quot;1&amp;quot; /&amp;gt;
   &amp;lt;/children&amp;gt;
   &amp;lt;padding&amp;gt;
      &amp;lt;Insets bottom=&amp;quot;10.0&amp;quot; left=&amp;quot;10.0&amp;quot; right=&amp;quot;10.0&amp;quot; top=&amp;quot;10.0&amp;quot; /&amp;gt;
   &amp;lt;/padding&amp;gt;
&amp;lt;/GridPane&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaによるREST-API呼び出しは、JAX-RSクライアントを利用するため、
下記ライブラリを追加します。（Mavenの設定）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.glassfish.jersey.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jersey-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.8&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面をコントロールするコントローラクラスです。
ボタンがクリックされた場合にREST-APIを呼び出して結果をラベルに設定します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.MediaType;

public class Controller
{
    @FXML
    private TextField stringField;

    @FXML
    private Label stringLabel;

    public void buttonAction()
    {
        final Client client = ClientBuilder.newClient();
        try {
            final String result = client.target(&amp;quot;http://localhost:8080/jaxrs/rest&amp;quot;)
                    .path(&amp;quot;hello&amp;quot;)
                    .queryParam(&amp;quot;string&amp;quot;, stringField.getText())
                    .request(MediaType.TEXT_PLAIN_TYPE)
                    .get(String.class);
            stringLabel.setText(result);
        }
        finally {
            client.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動すると下記の画面が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_38.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;javafxからの呼び出しを非同期にする&#34;&gt;JavaFXからの呼び出しを非同期にする&lt;/h2&gt;

&lt;p&gt;FlexもJavaFXもほぼ同じようなコードでREST-APIを呼び出すことができるのですが、
Flexの方は非同期呼び出しであり、JavaFXの方は同期呼び出しという違いがあります。
そこでJavaFXの方でも非同期呼び出しをさせてみたいと思います。&lt;/p&gt;

&lt;p&gt;JAX-RSクライアントには非同期呼び出しの仕組みがあるので、
それを利用するようにREST-APIの呼び出し部分を下記のように書き換えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Client client = ClientBuilder.newClient();
client.target(&amp;quot;http://localhost:8080/jaxrs/rest&amp;quot;)
      .path(&amp;quot;hello&amp;quot;)
      .queryParam(&amp;quot;string&amp;quot;, stringField.getText())
      .request(MediaType.TEXT_PLAIN_TYPE)
      .async()
      .get(new InvocationCallback&amp;lt;String&amp;gt;()
      {
          @Override
          public void completed(String result)
          {
              stringLabel.setText(result);
          }

          @Override
          public void failed(Throwable throwable)
          {
              throwable.printStackTrace();
          }
      });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出しチェーンに&lt;code&gt;async()&lt;/code&gt;メソッドを追加します。
結果は戻り値ではなく、&lt;code&gt;InvocationCallback&amp;lt;T&amp;gt;&lt;/code&gt;インターフェースの&lt;code&gt;completed(T)&lt;/code&gt;メソッドで受け取るようになります。
また、呼び出し後にclientをクローズしてしまうと非同期によるレスポンスを受け取る前に接続が切れてしまいます。
そのため、ここではクローズは行いません。&lt;/p&gt;

&lt;p&gt;これで非同期になると思いきや、実行すると下記エラーが発生します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;javax.ws.rs.ProcessingException: java.lang.IllegalStateException: Not on FX application thread; currentThread = jersey-client-async-executor-0
	at org.glassfish.jersey.client.ClientRuntime.processFailure(ClientRuntime.java:173)
	at org.glassfish.jersey.client.ClientRuntime.access$400(ClientRuntime.java:69)
	at org.glassfish.jersey.client.ClientRuntime$1.run(ClientRuntime.java:155)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaFXアプリのスレッド以外でアクセスしようとしたのでエラーが発生しています。
というわけで&lt;code&gt;async()&lt;/code&gt;メソッドは使えません。
そこで、&lt;code&gt;javafx.concurrent.Service&lt;/code&gt;クラスを利用します。
このクラスを利用すると、JavaFXアプリにおいて別スレッドを利用できるようになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javafx.concurrent.Service&lt;/code&gt;クラスを利用したクラスが下記になります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HelloService.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.concurrent.Service;
import javafx.concurrent.Task;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.MediaType;

public class HelloService extends Service&amp;lt;String&amp;gt;
{
    private StringProperty string = new SimpleStringProperty();

    public StringProperty stringProperty()
    {
        return string;
    }

    @Override
    protected Task&amp;lt;String&amp;gt; createTask()
    {
        return new Task&amp;lt;String&amp;gt;()
        {
            @Override
            protected String call() throws Exception
            {
                if (false == string.get().isEmpty()) {
                    final Client client = ClientBuilder.newClient();
                    try {
                        return client.target(&amp;quot;http://localhost:8080/jaxrs/rest&amp;quot;)
                                .path(&amp;quot;hello&amp;quot;)
                                .queryParam(&amp;quot;string&amp;quot;, string.get())
                                .request(MediaType.TEXT_PLAIN_TYPE)
                                .get(String.class);
                    }
                    finally {
                        client.close();
                    }
                }
                return null;
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作成したサービスクラスを利用するようにコントローラクラスを書き換えます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;

import java.net.URL;
import java.util.ResourceBundle;

public class Controller implements Initializable
{
    @FXML
    private TextField stringField;

    @FXML
    private Label stringLabel;

    private HelloService service = new HelloService();

    public void buttonAction()
    {
        service.restart();
    }

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle)
    {
        service.stringProperty().bind(stringField.textProperty());
        service.setOnSucceeded(e -&amp;gt; stringLabel.setText((String)e.getSource().getValue()));
        service.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Initializable&lt;/code&gt;インターフェースの&lt;code&gt;initialize(URL, ResourceBundle)&lt;/code&gt;メソッド内で
入力フィールドをサービスクラスへバインドし、サービスの処理完了時に呼ばれる&lt;code&gt;setOnSucceeded&lt;/code&gt;メソッドで
ラベルに対してレスポンスを書き出すようにします。&lt;code&gt;start()&lt;/code&gt;メソッドでサービスを開始します。&lt;/p&gt;

&lt;p&gt;また、書き換え前のコードではボタンクリックのハンドラ内でREEST-APIを呼び出していましたが、
新しいコードではサービスクラスの&lt;code&gt;restart()&lt;/code&gt;メソッドを呼び出し、
サービスの起動状態をキャンセルして再起動させます。こうすることにより、サービス内のタスクが再度生成されるので、
入力された値がサーバーに送信されるようになります。
入力値はバインドを利用しているので、サービスへの再設定は必要ありません。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;FlexとJavaFXでの簡単な呼び出しにおいてはほとんど違いがないことがわかるかと思います。
JavaFXで非同期呼び出しをしようとした場合にちょっとだけ面倒になりますが、
非同期にしたい部分だけ今回のようにサービスにするだけなので、
JavaFXを利用する上ではそれほど問題にならないかな、と思っています。&lt;/p&gt;

&lt;p&gt;Flexでは同期呼び出しにするという選択肢がないので、
同期と非同期を切り替えられるJavaFXの方がメリットがありそうです。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javafx/2/threads/jfxpub-threads.htm&#34;&gt;Concurrency in JavaFX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

