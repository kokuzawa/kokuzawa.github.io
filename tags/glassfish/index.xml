<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Glassfish on KATSUMI KOKUZAWA&#39;S BLOG</title>
    <link>https://kokuzawa.github.io/tags/glassfish/</link>
    <description>Recent content in Glassfish on KATSUMI KOKUZAWA&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 30 Jun 2013 11:09:00 +0900</lastBuildDate>
    
        <atom:link href="https://kokuzawa.github.io/tags/glassfish/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JDBCRealmのパッケージが変更 #glassfish-4</title>
      <link>https://kokuzawa.github.io/blog/2013/06/30/jdbcrealmfalsepatukezigabian-geng-number-glassfish-4/</link>
      <pubDate>Sun, 30 Jun 2013 11:09:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/06/30/jdbcrealmfalsepatukezigabian-geng-number-glassfish-4/</guid>
      <description>&lt;p&gt;GlassFish-4.0からJDBCRealmクラスのパッケージが変更になった。&lt;br /&gt;
今までのパッケージは下記の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GlassFish-4.0からは下記のパッケージとなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;com.sun.enterprise.security.ee.auth.realm.jdbc.JDBCRealm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Embeddedとして利用しているとかじゃないとあまり影響はないかもしれない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jersey on glassfish-4</title>
      <link>https://kokuzawa.github.io/blog/2013/03/24/jersey-on-glassfish4/</link>
      <pubDate>Sun, 24 Mar 2013 12:32:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/03/24/jersey-on-glassfish4/</guid>
      <description>&lt;p&gt;GlassFish-4を使ってみたらJerseyのパッケージが変わってた。
GlassFish-3.1.2.2までは以下のようにcom.sunパッケージにあるJerseyのサーブレットがロードできていたけど、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;servlet-name&amp;gt;jersey-serlvet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.sun.jersey.spi.container.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GlassFish-4ではcom.sunパッケージにJerseyはなく、org.glassfishのパッケージとなっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;servlet-name&amp;gt;jersey-serlvet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.glassfish.jersey.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Point-to-Point on JMS</title>
      <link>https://kokuzawa.github.io/blog/2012/12/15/point-to-point-on-jms/</link>
      <pubDate>Sat, 15 Dec 2012 15:50:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/12/15/point-to-point-on-jms/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://atnd.org/events/33783&#34;&gt;JavaEE Advent Calendar 2012&lt;/a&gt;の15日目のエントリーです。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/yoshioterada&#34;&gt;@yoshioterada&lt;/a&gt;さんの&lt;a href=&#34;http://yoshio3.com/2012/12/14/javaee7-websocket-client-with-javafx/&#34;&gt;Java EE 7 WebSocket Client Sample Application with JavaFX&lt;/a&gt;です。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/akirakoyasu&#34;&gt;@akirakoyasu&lt;/a&gt;さんです。&lt;/p&gt;

&lt;h2 id=&#34;普段は使わないjmsを使う&#34;&gt;普段は使わないJMSを使う&lt;/h2&gt;

&lt;p&gt;おそらくJMSの本来の利用方法は非同期通信を利用した分散処理なのだと思うけど、今回はそんな高尚な目的ではなく、単純なメッセンジャーとして利用します。
世の中のどの位のプロジェクトでJMSが利用されているのか分からないけど、JavaEEの仕様にJMSが含まれているにも関わらず、今まで本格的に利用した事がありません。
分散処理をするケースがあるプロジェクトに参加した事が無いのか、またはサーバがいつもTomcatだからなのか。
おそらく後者なのだと思うけど、ということはつまり分散処理の必要がないプロジェクトということなんだと思います。&lt;/p&gt;

&lt;p&gt;そんな事もあって、JMSの知識が皆無だったわけですが、
JavaEEのアドベンドカレンダーをやるに当たって何か普段は触らないようなことをやりたいなと思い立ち、JMSを使ってみる事にしました。&lt;/p&gt;

&lt;h2 id=&#34;必要なもの&#34;&gt;必要なもの&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GlassFish-3.1.2.2&lt;/li&gt;
&lt;li&gt;jms-api-1.1-rev-1.jar&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;javax.jms&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jms-api&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.1-rev-1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;imq-4.5.2.jar&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.glassfish.mq&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;imq&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.5.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JMSを利用する為には、メッセージプロバイダが必要になります。プロバイダにはOpenMQ, MQSeries, SonicMQなどがありますが、
今回は導入が簡単なOpenMQを利用します。OpenMQはGlassFishに付属してインストールされます。インストール時に特に何かを意識する必要はありません。
また、OpenMQにアクセスする為に2つのライブラリが必要になります。jms-apiとimqです。Mavenリポジトリに登録されているので、
こちらも容易に入手可能です。&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;GlassFishを起動しておく必要があります。ポートとして7676を利用するので、GlassFishがローカルではなく、リモート環境にある場合は、
ポートへのアクセスを許可する必要があるかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;メッセージプロデューサーを作る&#34;&gt;メッセージプロデューサーを作る&lt;/h2&gt;

&lt;p&gt;メッセージを送信するプロデューサーを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package jp.co.baykraft.jmsexample;

import com.sun.messaging.ConnectionConfiguration;
import com.sun.messaging.QueueConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Queue;
import javax.jms.QueueConnection;
import javax.jms.QueueSender;
import javax.jms.QueueSession;
import javax.jms.TextMessage;

/**
 * メッセージを送信するクラスです。
 * @author Katsumi
 */
public class Sender
{
    public static void main(String... args) throws JMSException
    {
        QueueConnectionFactory factory = new QueueConnectionFactory();
        factory.setProperty(ConnectionConfiguration.imqAddressList, 
            &amp;quot;localhost:7676&amp;quot;);
        QueueConnection connection = factory.createQueueConnection();
        QueueSession session = connection.createQueueSession(false, 
            QueueSession.AUTO_ACKNOWLEDGE);
        Queue queue = session.createQueue(&amp;quot;KQueue&amp;quot;);

        QueueSender sender = session.createSender(queue);
        TextMessage message = session.createTextMessage();
        message.setText(&amp;quot;メッセージ&amp;quot;);
        sender.send(message);

        connection.close();

        System.out.println(&amp;quot;Finished.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;session.createQueue(&amp;quot;KQueue&amp;quot;)&lt;/code&gt;でKQueueという文字列を指定していますが、これは任意の文字列です。
メッセージを受信する側でも同じ文字列を指定してメッセージを受け取ります。&lt;/p&gt;

&lt;h2 id=&#34;メッセージコンシューマを作る&#34;&gt;メッセージコンシューマを作る&lt;/h2&gt;

&lt;p&gt;次にメッセージを受信するコンシューマを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package jp.co.baykraft.jmsexample;

import com.sun.messaging.ConnectionConfiguration;
import com.sun.messaging.QueueConnectionFactory;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.Queue;
import javax.jms.QueueConnection;
import javax.jms.QueueReceiver;
import javax.jms.QueueSession;
import javax.jms.TextMessage;

/**
 * メッセージを受診するクラスです。
 * @author Katsumi
 */
public class Receiver
{
    public static void main(String... args) throws JMSException
    {
        QueueConnectionFactory factory = new QueueConnectionFactory();
        factory.setProperty(ConnectionConfiguration.imqAddressList, 
            &amp;quot;localhost:7676&amp;quot;);
        QueueConnection connection = factory.createQueueConnection();
        QueueSession session = connection.createQueueSession(false, 
            QueueSession.CLIENT_ACKNOWLEDGE);
        Queue queue = session.createQueue(&amp;quot;KQueue&amp;quot;);

        QueueReceiver receiver = session.createReceiver(queue);
        receiver.setMessageListener(new MessageListener() {
            @Override
            public void onMessage(Message msg)
            {
                try {
                    TextMessage message = (TextMessage) msg;
                    message.acknowledge();
                    System.out.println(message.getText());
                }
                catch (JMSException ex) {
                    Logger.getLogger(Receiver.class.getName())
                          .log(Level.SEVERE, null, ex);
                }
            }
        });

        connection.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;動かしてみよう&#34;&gt;動かしてみよう&lt;/h2&gt;

&lt;p&gt;さて、コードも作ったので動かしてみます。
送信するメッセージはキューに溜め込まれるので、コンシューマを起動しておかなくても大丈夫です。
まずはプロデューサーを起動すると、「メッセージ」という文字列がメッセージプロバイダに送られます。&lt;/p&gt;

&lt;p&gt;次にコンシューマを起動します。
コンシューマを起動すると、メッセージプロバイダのKQueueに溜め込まれたメッセージが受信されます。
コンシューマのコードの&lt;code&gt;QueueSession.CLIENT_ACKNOWLEDGE&lt;/code&gt;の指定ですが、この指定の場合、
コンシューマ側で&lt;code&gt;TextMessage#acknowledge()&lt;/code&gt;メソッドを呼び出すまで、キュー上のメッセージは削除されません。
コンシューマ側の処理が失敗した場合はキュー上のメッセージを削除したくないのでこの指定にしています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GlassFishを起動するだけでメッセージプロバイダが起動されるのは非常に便利です。
メッセージプロバイダを起動しておけば、簡単なメッセージの送受信アプリが作れます。
キューの名前をコンシューマ毎に切り替えれば、複数クライアントのアプリも出来そうです。
JMSの本来の利用目的とは違うのかもしれませんが、こんな簡単なアプリから触ってみると楽しいと思います。
それにしても、GlassFishは最高ですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GlassFish3.1.2へのデプロイ時のエラー</title>
      <link>https://kokuzawa.github.io/blog/2012/11/10/glassfishhefalsedepuroishi-falseera/</link>
      <pubDate>Sat, 10 Nov 2012 07:44:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/11/10/glassfishhefalsedepuroishi-falseera/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent.ExecutionException: com.sun.faces.config.ConfigurationException: Unable to parse document &amp;lsquo;bundle://213.0:1/com/sun/faces/jsf-ri-runtime.xml&amp;rsquo;: DTD factory class org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl does not extend from DTDDVFactory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSFを利用していると発生しているようなので、warファイル内のjavax.faces-2.1.4.jarを取り除いて再度デプロイ。でも変化なし。
（JSFのライブラリはGlassFishに含まれている。バージョンはわからないけど）&lt;/p&gt;

&lt;p&gt;何度か再デプロイをしていると起動できるので、それほど真剣に調べていなかったけど、本腰をいれて調べてみることにした。&lt;/p&gt;

&lt;h3 id=&#34;結果&#34;&gt;結果&lt;/h3&gt;

&lt;p&gt;ログを見ると&lt;code&gt;org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl&lt;/code&gt;関係でエラーが発生して&lt;code&gt;bundle://213.0:1/com/sun/faces/jsf-ri-runtime.xml&lt;/code&gt;がパースできないことがわかる。&lt;/p&gt;

&lt;p&gt;っていうか&lt;code&gt;bundle://213.0:1/com/sun/faces/jsf-ri-runtime.xml&lt;/code&gt;って何だろう？ひとまずこれについてはあとで調査。&lt;/p&gt;

&lt;p&gt;おそらくGlassFishで利用しているXMLパーサとぶつかっているせいだと思う。warファイル内からxercesImpl-2.8.1.jarを取り除いてデプロイしたところ正常に起動ができた。
取り除いても正常に起動できたのでXMLパーサがGlassFishに含まれてるのは間違いないと推測できるが、GlassFishのどこにXMLパーサが含まれているのかがわからない。&lt;/p&gt;

&lt;h4 id=&#34;追記-nov-11-2012&#34;&gt;追記: Nov 11, 2012&lt;/h4&gt;

&lt;p&gt;運用環境はTomcatだからxercesImpl-2.8.1.jarを取り除いちゃダメなんじゃないかと思う。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

