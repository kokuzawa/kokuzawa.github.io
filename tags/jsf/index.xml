<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jsf on KATSUMI KOKUZAWA&#39;S BLOG</title>
    <link>https://kokuzawa.github.io/tags/jsf/</link>
    <description>Recent content in Jsf on KATSUMI KOKUZAWA&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 12 Jan 2017 00:29:21 +0900</lastBuildDate>
    
	<atom:link href="https://kokuzawa.github.io/tags/jsf/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JSF 2.3 の Websocket を試す</title>
      <link>https://kokuzawa.github.io/blog/2017/01/12/jsf-2-3-websocket/</link>
      <pubDate>Thu, 12 Jan 2017 00:29:21 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2017/01/12/jsf-2-3-websocket/</guid>
      <description>JSF 2.3 では新しい機能として Websocket が追加されます。
JSF 2.3 はまだリリースされていませんが、先日 JSF 2.3-m09 が公開されたので、 これを使って Websocket を試してみようと思います。
環境  macOS Sierra Java&amp;trade; SE Runtime Environment (build 1.8.0_91-b14) WildFly 10.1.0.Final Payara Server 4.1.1.164  はじめに 今回やったことは下記に書いてあることそのままです。
http://blog.payara.fish/jsf-2.3-the-websocket-quickstart-under-payara-server
ボタンをクリックすることでサーバサイドから時間を取得してそれを表示するアプリを作ります。 アプリの作り方は上記サイトを見てもらえばわかると思うので、ここでは上記のサイトには書かれていない、 JavaEE8に対応していない現状のAPサーバで JSF 2.3 を有効にする方法について説明します。
WildFly 10.1.0.Final で試す まず、普段利用している WildFly で動かそうとしてみました。 WildFly で JSF 2.3 を有効にするためには、WildFly が内包する JSF を無効にする必要があります。 無効にする方法は、下記の記述をした WEB-INF/jboss-deployment-structure.xml を用意します。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt; &amp;lt;jboss-deployment-structure xmlns=&amp;quot;urn:jboss:deployment-structure:1.2&amp;quot;&amp;gt; &amp;lt;deployment&amp;gt; &amp;lt;exclude-subsystems&amp;gt; &amp;lt;subsystem name=&amp;quot;jsf&amp;quot;/&amp;gt; &amp;lt;/exclude-subsystems&amp;gt; &amp;lt;/deployment&amp;gt; &amp;lt;/jboss-deployment-structure&amp;gt;  JSF 2.</description>
    </item>
    
    <item>
      <title>Dialog of PrimeFaces</title>
      <link>https://kokuzawa.github.io/blog/2016/12/25/opendialog-of-primefaces/</link>
      <pubDate>Sun, 25 Dec 2016 15:10:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/12/25/opendialog-of-primefaces/</guid>
      <description>この記事はJava EE Advent Calendar 2016の25日目です。
昨日は@kikutaroさんの「実はJava EEに含まれるJavaMailについて」でした。
現在業務でJSFを使っています。 導入当初はRIであるMojarraのみを利用しようと考えていたのですが、 業務アプリで多い、ツリーやグリッドで数多くのアクションを実装しなければならず、 一つ一つをJavaScriptで実装していくには時間が足りないという判断のもとに、 それらを簡易に実現できるPrimeFacesを利用することにしました。 採用を決定した段階での最新バージョンはPrimeFaces-6.0です。 PrimeFacesは充実したコンポーネント群を持っているので、 必要なコンポーネントはほぼ見つけることができるかと思います。
さて、今回はその中でダイアログコンポーネントについて説明します。 PrimeFacesのDemoを見るとわかるのですが、 このダイアログコンポーネントを表示するための方法が二通り用意されています。
一つ目は静的にダイアログを表示する方法です。
XHTML:
&amp;lt;p:dialog widgetVar=&amp;quot;sampleDialog&amp;quot;&amp;gt; ... &amp;lt;/p:dialog&amp;gt; &amp;lt;p:commandButton value=&amp;quot;Show&amp;quot; oncomplete=&amp;quot;PF(&#39;sampleDialog&#39;).show()&amp;quot;/&amp;gt;  二つ目の方法は動的にダイアログを表示する方法です。
ManagedBean:
public void onShowDialog() { RequestContext.getCurrentInstance().openDialog(&amp;quot;dialog.xhtml&amp;quot;); }  XHTML:
&amp;lt;p:commandButton value=&amp;quot;Show&amp;quot; actionListener=&amp;quot;#{bean.onShowDialog}&amp;quot;/&amp;gt;  二つ目の方法は指定したXHTMLをiframe内に表示して、それをダイアログとして表示してくれます。 一つ目の方法と異なり、 ダイアログ内のコンテンツを別XHTMLに分けることができるのでコードの見通しが良くなるかと思います。 また、表示時にダイアログのオプションを指定することができますが、 何も指定しないと、モーダレス、リサイズ可能、コンテンツが640pxで固定されたダイアログが表示されます。 ダイアログをリサイズしてもコンテンツが640pxで固定されているので、追従して広がることがありません。 もし、リサイズに合わせてコンテンツも追従するようにしたければ、 表示時に下記のようなオプションを付与します。
public void onShowDialog() { final Map&amp;lt;String, Object&amp;gt; options = new HashMap&amp;lt;&amp;gt;(); options.put(&amp;quot;width&amp;quot;, 640); options.put(&amp;quot;contentWidth&amp;quot;, &amp;quot;100%&amp;quot;); RequestContext.getCurrentInstance().openDialog(&amp;quot;dialog.xhtml&amp;quot;, options, null); }  このようにすることで、ダイアログの初期表示の幅は640px、コンテンツの幅は100%となり、 コンテンツがリサイズに追従するようになります。</description>
    </item>
    
    <item>
      <title>remoteCommand in Composite</title>
      <link>https://kokuzawa.github.io/blog/2016/12/14/remotecommand-in-composite/</link>
      <pubDate>Wed, 14 Dec 2016 01:28:24 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/12/14/remotecommand-in-composite/</guid>
      <description>JSFにはcompositeというカスタムコンポーネントを作るための仕組みがあります。 PrimeFaces-6.0にはManagedBeanのメソッドを呼び出すためのremoteCommandというコンポーネントがあります。 この二つを使ってカスタムコンポーネントを作ったところ、ManagedBeanのメソッドが呼ばれないという問題が発生しました。
まず、JSFのcomposite機能を使って下記のような二つのコンポーネントを作りました。
sample1.xhtml:
&amp;lt;composite:implementation&amp;gt; &amp;lt;p:tree&amp;gt; &amp;lt;p:ajax event=&amp;quot;select&amp;quot; oncomplate=&amp;quot;afterSelected()&amp;quot;/&amp;gt; &amp;lt;/p:tree&amp;gt; &amp;lt;p:remoteCommand name=&amp;quot;afterSelected&amp;quot; actionListener=&amp;quot;#{bean.method1}&amp;quot;/&amp;gt; &amp;lt;/composite:implementation&amp;gt;  sample2.xhtml:
&amp;lt;composite:implementation&amp;gt; &amp;lt;p:tree&amp;gt; &amp;lt;p:ajax event=&amp;quot;select&amp;quot; oncomplate=&amp;quot;afterSelected()&amp;quot;/&amp;gt; &amp;lt;/p:tree&amp;gt; &amp;lt;p:remoteCommand name=&amp;quot;afterSelected&amp;quot; actionListener=&amp;quot;#{bean.method2}&amp;quot;/&amp;gt; &amp;lt;/composite:implementation&amp;gt;  そしてこれらを一つのXHTMLに組み込みます。
main.xhtml:
&amp;lt;my:sample1/&amp;gt; &amp;lt;my:sample2/&amp;gt;  sample1側のツリーノードを選択した際にbean.method1が呼ばれることを想定していたのですが、 呼ばれることなく画面がリフレッシュされました。それぞれのカスタムコンポーネント内の remoteCommandのnameの値が重複していると、エラーが発生することなくメソッドが呼ばれないという現象が発生します。
当たり前と言えば当たり前なのですが、 似たようなコンポーネントを作るとやらかしてしまいそうなので注意しないと。</description>
    </item>
    
    <item>
      <title>WildFly SwarmでJSFを試す</title>
      <link>https://kokuzawa.github.io/blog/2015/11/16/wildfly-swarmdejsfwoshi-su/</link>
      <pubDate>Mon, 16 Nov 2015 22:58:09 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/11/16/wildfly-swarmdejsfwoshi-su/</guid>
      <description>昨日はWildFly SwarmでJAXRSを触ったので、今日はJSFを試してみることにします。
JSFを組み込む 仕様毎にモジュールが分かれているので、JAXRSの時と同じく、今回はJSFのモジュールを取り込みます。 あと、ここで特に記載はしませんがwildfly-swarm-pluginももちろん設定する必要があります。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;wildfly-swarm-jsf&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0.Alpha5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  JSFアプリケーションを作る JSFアプリケーションを作ると言ってもJavaのコードを書くわけではなく、 動くことが分かれば良いのでXHTMLファイルだけを作るだけにします。
&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;quot;&amp;gt; &amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xmlns:h=&amp;quot;http://xmlns.jcp.org/jsf/html&amp;quot;&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h:outputText value=&amp;quot;Hello JSF!&amp;quot;/&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  あと、JAXRSの時と違い、web.xmlを作る必要があります。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;web-app xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&amp;quot; version=&amp;quot;3.1&amp;quot;&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;javax.faces.PROJECT_STAGE&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;Development&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;javax.faces.webapp.FacesServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;*.xhtml&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;/web-app&amp;gt;  動かす JAXRSの時と同じく、mainメソッドから実行するため、mainメソッドを持つクラスを作ります。 今回はJAXRSArchiveではなく、WARArchieをデプロイします。
package org.katsumi.jsf; import org.</description>
    </item>
    
    <item>
      <title>Googleのテキスト読み上げAPIを組み込む</title>
      <link>https://kokuzawa.github.io/blog/2015/05/03/translate-google/</link>
      <pubDate>Sun, 03 May 2015 22:12:37 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/05/03/translate-google/</guid>
      <description>子供用の英単語帳Webアプリを作っています。 単語の読み上げ機能があると便利だなと思い、そんなAPIはないかと調べてみると、 Googleが提供しているテキスト読み上げAPIというのを見つけました。
使い方はとても簡単で、下記のようなURLを呼び出せば良いようです。 この例ではoneという単語を読み上げてくれます。
http://translate.google.com/translate_tts?tl=en&amp;amp;q=one  これをHTMLに組み込みます。 HTMLで音声を再生するためにはaudioタグを利用します。 下記のように組み込むことで音声を再生するためのコントロールを表示することができます。
&amp;lt;video src=&amp;quot;http://translate.google.com/translate_tts?tl=en&amp;amp;q=one&amp;quot; controls /&amp;gt;  こんな感じになります。
実際のアプリはJSF-2.2でFaceletを利用しています。 このタグを組み込んだ場合、最初の一回目は正しく再生されますが 2回目以降が再生されません。 なぜダメなのか結局分からなかったのですが、 UI的にはaudioコントロールを表示したくなかったので、 タグを埋め込むのではなくJavaScriptで再生するようにしました。
&amp;lt;script&amp;gt; function play() { var audio = document.createElement(&amp;quot;audio&amp;quot;); audio.src = &amp;quot;http://translate.google.com/translate_tts?tl=en&amp;amp;q=one&amp;quot;; audio.play(); } &amp;lt;/script&amp;gt; &amp;lt;a href=&amp;quot;#&amp;quot; onClick=&amp;quot;play()&amp;quot;&amp;gt;再生&amp;lt;/a&amp;gt;  この場合audioコントロールは表示されないのですが、 再生リンクをクリックするたびに正しく再生されます。</description>
    </item>
    
    <item>
      <title>[JSF-2.3]FacesContextをInjectする</title>
      <link>https://kokuzawa.github.io/blog/2014/12/23/jsf-2-dot-3defacecontextwoinjectsuru/</link>
      <pubDate>Tue, 23 Dec 2014 15:02:06 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/12/23/jsf-2-dot-3defacecontextwoinjectsuru/</guid>
      <description>JSF-2.3の新しい機能として、UIViewRoot, ViewMap, ApplicationMap, ExternalContext, FacesContextがInjectできるようになります。 この記事ではFacesContextの古い取得方法であるFacesContext.getCurrentInstance()と、 Injectを利用した取得方法のサンプルを記載します。
サンプルでは画面のボタンをクリックすると、&amp;lt;h:messages/&amp;gt;タグとFacesContext.addMessage(String, FacesMessage)を利用して 同じ画面上にインフォメーションメッセージを表示します。
最初にFacesContextの古い取得方法を利用したManaged Beanです。
import javax.enterprise.context.RequestScoped; import javax.faces.application.FacesMessage; import javax.faces.context.FacesContext; import javax.inject.Inject; import javax.inject.Named; @Named @RequestScoped public class IndexBean { public void doClick() { final FacesContext context = FacesContext.getCurrentInstance(); context.addMessage(null, new FacesMessage(FacesMessage.SEVERITY_INFO, &amp;quot;summary&amp;quot;, &amp;quot;detail&amp;quot;)); } }  次にInjectを利用してFacesContextを取得するManaged Beanです。
import javax.enterprise.context.RequestScoped; import javax.faces.application.FacesMessage; import javax.faces.context.FacesContext; import javax.inject.Inject; import javax.inject.Named; @Named @RequestScoped public class IndexBean { @Inject private FacesContext context; public void doClick() { context.</description>
    </item>
    
    <item>
      <title>JSFのCSRF対策</title>
      <link>https://kokuzawa.github.io/blog/2014/10/08/jsffalsecsrfdui-ce/</link>
      <pubDate>Wed, 08 Oct 2014 02:29:57 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/10/08/jsffalsecsrfdui-ce/</guid>
      <description>だいぶ前にリリースされたJSF 2.2ではCSRF対策の機能が追加されました。 そこで、JSFをどのように利用している場合にCSRFの脆弱性が発生するのかと、 JSF 2.2で追加されたCSRF対策を実施すると、この問題をどのように防げるのかを確認してみます。
環境  OS: Mac OSX 10.9.4 Java: Java&amp;trade; SE Runtime Environment (build 1.8.0-b132) メモリ: 4GB WildFly 8.0.0.Final  アプリを作る CSRFの脆弱性がある、といわれても具体例がないとなかなかイメージするのが難しいかもしれません。 そこで、ここでは実際に攻撃を受けるアプリを作り、脆弱性を露呈されてみたいと思います。 コードの構成は下記のようになります。
JSFCSRFSample +- src | +- main | | +- java | | +- org.katsumi.bean | | +- FormBean.java | +- webapp | +- index.xhtml | +- result.xhtml | +- warning.xhtml | +- WEB-INF | +- jboss-web.xml | +- faces-config.xml | +- web.xml +- pom.</description>
    </item>
    
    <item>
      <title>How to set the value in ValueChangeListener</title>
      <link>https://kokuzawa.github.io/blog/2014/02/12/how-to-set-the-value-in-valuechangelistener/</link>
      <pubDate>Wed, 12 Feb 2014 00:58:25 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/02/12/how-to-set-the-value-in-valuechangelistener/</guid>
      <description>JSFには値が変更されたことをハンドリングするためのイベントとしてValueChangeEventが用意されています。 このイベントは、コンポーネントのValueChangeListenerによって発行されます。 ValueChangEventを利用してテキストフィールドに入力された値の検証を行っているのですが、 値が不正だった場合に、エラーを表示するのではなく正常な値を設定したい場合があります。
このとき、単純にValueChangeListenerの中でテキストフィールドのプロパティに値を設定しても、画面には反映されません。 これは、ValueChangeEventがJSFのライフサイクルのUpdate Model Valuesフェーズの前に呼ばれるからであり、 ValueChangeListenerで設定した値はUpdate Model Valuesフェーズで入力値によって上書きされてしまうからです。
これを解決するには、ValueChangeListenerにおいて、ちょっとした工夫が必要です。 以下にその例を示します。
public void valueChangeListener(ValueChangeEvent event) { if (event.getPhaseId() == PhaseId.UPDATE_MODEL_VALUES) { property = &amp;quot;9:00&amp;quot;; } else { String value = (String) event.getNewValue(); if (false == value.matches(&amp;quot;([0-9]{1,2}|1[0-9]|2[0-3]):[0-5][0-9]&amp;quot;) { event.setPhaseId(PhaseId.UPDATE_MODEL_VALUES); event.queue(); } } }  この例では、時間の入力に対する検証を行い、不正な値が入力された場合にデフォルト値である「9:00」を設定しています。 値の検証をUpdate Model Valuesフェーズの前に実施し、値が不正である場合には、ValueChangeEventをUpdate Model Valuesフェーズにエンキューします。 このようにすることで、Update Model Valuesフェーズでもう一度ValueChangeListenerが呼び出されます。 二度ValueChangeListenerが呼ばれることになるので、イベントのフェーズIDを判定し、 Update Model Valuesフェーズで呼ばれた場合にデフォルト値を設定することで画面にその値を反映させます。
JSFは、ライフサイクルを知っていないと対処が難しい場合があるのがちょっといけてないですね&amp;hellip;。 というわけで何かの参考になれば幸いです。
Enjoy !</description>
    </item>
    
    <item>
      <title>JSF 2.2 でさらに便利になったMarkupを使ってみよう</title>
      <link>https://kokuzawa.github.io/blog/2013/12/18/jsf-2-dot-2-markup/</link>
      <pubDate>Tue, 17 Dec 2013 00:12:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/12/18/jsf-2-dot-2-markup/</guid>
      <description>この記事は、Java EE Advent Calendar 2013の18日目の記事です。
昨日は @yumix_h さんの私がJava EE開発の現場から学んだことでした。
明日は誕生日の @aoetk さんです。
みなさんJSF使ってますか？
JSFってちょっと取っ付きにくいところがありますよね。でもそんなJSFもバージョンが2.2になって、 ちょっと良い感じになってきたので使ってみませんか、 ということでJSFのマークアップについて書いてみたいと思います。
デザイナーとプログラマの作業の分担 JSFはデザイナーとプログラマで作業が分担できるということを良く聞きます。 デザイナーを雇うほど大きなプロジェクトでJSFを使ったことがないし、 分担しているということもあまり見聞きしませんが、実際この分担というのはどういうことなんでしょう？
デザイナーはHTMLは分かりますがJSFはわかりません。
プログラマはHTMLもJSFも分かりますが、デザインセンスはそれを専属でやっているデザイナーのほうに 一日の長があると思うので、素直にデザインは任せた方が良いでしょう。
このようにHTMLしか分からない人が、HTMLに注力できるようにするには、 そのファイルがHTMLとして認識、つまりAPサーバーを経由しなくても、ブラウザでレイアウトが表示できる必要があります。 昔のJSPのように、JSPのタグやスクリプトレットで動的にレイアウトをするようにしていると、 ブラウザでレイアウトが表示できないのでダメということですね。
JSFはFaceletsというテンプレートエンジンを取り込んでいるので、 特別なファイルではなく、XHTMLとして画面を作ることができます。 そのため、JSFのコンポーネントを埋め込まなければ、このままブラウザで表示することができます。
ですが、何も埋め込まないのでは静的なHPと何も変わらないので、 JSFのコンポーネントを埋め込んでいく必要があり、下記のようなコンポーネントを埋め込んでしまうと、 デザイナーが理解できない状態、ブラウザでレイアウトを確認できない状態になってしまいます。
&amp;lt;h:commandButton value=&amp;quot;OK&amp;quot; action=&amp;quot; #{managedBean.doAction}&amp;quot;/&amp;gt;  ではどうしたら良いのでしょう？
JSF 2.1 JSF 2.1では、例えば下記のようにHTMLのタグにJSFのコンポーネント名を設定することによって、 JSFのコンポーネントとして認識させることができます。もちろんJSF 2.2でもできます。
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot; jsfc=&amp;quot;h:commandButton&amp;quot; action=&amp;quot;#{managedBean.doAction}&amp;quot;/&amp;gt;  これをブラウザで表示してみます。
h:commandButtonの方は見事に表示されませんが、jsfc属性で書いた方は普通のボタンとして表示されています。
JSF 2.2 jsfc属性でJSFコンポーネントをHTMLとして認識させるのには十分でしたが、 それぞれのJSFコンポーネント名をいちいち記載するのは面倒でした。コンポーネント名を正確に覚えていなければならないし&amp;hellip;。 JSF 2.2ではそこがさらに改善され、下記のようにコンポーネント名を書かなくても、JSFコンポーネントとして認識してくれるようになりました。 namespaceはxmlns:jsf=&amp;quot;http://xmlns.jcp.org/jsf&amp;quot;です。
&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot; jsf:action=&amp;quot;#{managedBean.doAction}&amp;quot;/&amp;gt;  詳しくはJava EE 7 Tutorialを参考にしてください。</description>
    </item>
    
    <item>
      <title>JSF2.0でCSSリソース内の画像を読み込む</title>
      <link>https://kokuzawa.github.io/blog/2013/06/10/load-images-within-css-resources-in-jsf-2-dot-0/</link>
      <pubDate>Mon, 10 Jun 2013 03:10:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/06/10/load-images-within-css-resources-in-jsf-2-dot-0/</guid>
      <description> JSF 2.0 でCSSリソース内の画像を読み込むにはコツが必要です。
Bootstrapのglyphicons-halflings.pngを読み込むのに暫く悩んだのでそのメモなど。
フォルダ構成は次のようになっています。（Mavenです）
root +-- src +-- webapp +-- resources +-- css | +-- bootstrap.min.css +-- img +-- glyphicons-halflings.png  JSFなのでXHTMLを使い、CSSの読み込みは以下のようにします。
&amp;lt;h:outputStylesheet library=&amp;quot;css&amp;quot; name=&amp;quot;bootstrap.min.css&amp;quot;/&amp;gt;  このとき、bootstrap.min.css内のイメージのパスは../img/glyphicons-halflings.pngとなっていますが、 このままでは画像が読み込まれません。まあ、パスからも明らかですね。
問題を解決するには次のように、イメージのパスを変更する必要があります。
background-image:url(&amp;quot;#{resource[&#39;img/glyphicons-halflings.png&#39;]}&amp;quot;)  Jun 20, 2013 追記 twitterで@den2snさんに教えてもらったのですが、outputStylesheetを下記のようにlibraryを削除して宣言することにより、 bootstrap.min.cssを書き換えなくても良くなります。
&amp;lt;h:outputStylesheet name=&amp;quot;css/bootstrap.min.css&amp;quot;/&amp;gt;  </description>
    </item>
    
    <item>
      <title>Convert the Alerts component of &#39;Bootstrap&#39; to a component of JSF 2.0</title>
      <link>https://kokuzawa.github.io/blog/2013/01/13/facesmessagetobootstrap/</link>
      <pubDate>Sun, 13 Jan 2013 18:46:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/01/13/facesmessagetobootstrap/</guid>
      <description>JSFのMessagesコンポーネントは、Managed Beanで設定されたFacesMessageを出力する為のコンポーネントです。 出力方法は、listとTableの二つのレイアウトを利用した方法があり、デフォルトはlistレイアウトです。 listレイアウトは以下のような出力になります。
(Bootstrapのalert alert-errorを適用)
これに対してTableレイアウトは以下のような出力になります。
どちらもエラーを表示するには十分ですが、ユーザとしては確認したらエラー情報を消したいところです。 MessagesコンポーネントはHTMLをカスタマイズする事ができません。 正確にはレンダラをカスタマイズすれば、出力するHTMLを書き換える事が出来ますし、 そういった情報を扱ったブログもありますが、Messagesレンダラのカスタマイズは、 com.sunパッケージのクラスを継承して拡張する必要があり、JSFの実装依存のコードになってしまいます。 もちろん独自で一からレンダラを書いても良いのですが、あまり現実的ではありません。 そこで、標準のMessagesコンポーネントではなくBootstrapのAlertsコンポーネントを使うことにします。
BootstrapのAlertsコンポーネントはクローズボタンを表示する事ができます。 このクローズボタンをクリックする事により、エラー情報を消すことができます。 クローズボタンを出すには、HTMLを下記のように記載する必要があります。
&amp;lt;div class=&amp;quot;alert alert-error&amp;quot;&amp;gt; &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; data-dismiss=&amp;quot;alert&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/button&amp;gt; &amp;lt;h4&amp;gt;Summary Message&amp;lt;/h4&amp;gt; Detail Message &amp;lt;/div&amp;gt;  これをJSF合成コンポーネントにします。 webapp/resources/bootstrapフォルダを作成し、alert.xhtmlファイルを配置します。(フォルダ構成はMavenです)
alert.xhtml:
&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;quot;&amp;gt; &amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot; xmlns:cc=&amp;quot;http://java.sun.com/jsf/composite&amp;quot; xmlns:c=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot;&amp;gt; &amp;lt;!-- INTERFACE --&amp;gt; &amp;lt;cc:interface&amp;gt; &amp;lt;/cc:interface&amp;gt; &amp;lt;!-- IMPLEMENTATION --&amp;gt; &amp;lt;cc:implementation&amp;gt; &amp;lt;c:forEach var=&amp;quot;message&amp;quot; items=&amp;quot;#{facesContext.messageList}&amp;quot;&amp;gt; &amp;lt;c:if test=&amp;quot;#{message.severity == &#39;ERROR 2&#39;}&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;alert alert-error&amp;quot;&amp;gt; &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; data-dismiss=&amp;quot;alert&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/button&amp;gt; &amp;lt;h4&amp;gt;#{message.</description>
    </item>
    
  </channel>
</rss>