---
title: "Performance of JPA"
date: 2013-01-27T12:08:00+09:00
tags: [Java, JavaEE, JPA, EclipseLink] 
---

JPAはJavaSE上でも動作するので、DBアクセスをする場合、最近はもっぱらJDBCではなくJPAを利用している。
サーバサイドを利用しない、クライアントアプリでDBアクセスをするのは、主にデータ移行ツールとかが多く、
ひとつのトランザクション内で処理されるレコード数が数万レコードになる事が多い。

数万レコードを移行する為に、JPAを利用した移行ツールを作り、実データでテストをしたところ、
想定外のパフォーマンス劣化が発生し、その解決に幾分か時間が掛かってしまった。
そのため、パフォーマンスが劣化する状況とその解決方法を簡易に示す為の簡易なコードを作成、備忘録として残しておく。

## アプリ構成
JavaはJDK7、JPAの実装はEclipseLink-2.3.2を利用。DBはDerby。

## コード
検証に利用するコードは下記の通り。
Bookエンティティを1万レコード永続化する。この際、永続化だけではパフォーマンスの劣化を確認できないため、
永続化されたBookエンティティのうち、`bookname='name1'`のレコードを抽出する。
また、検証に利用する為に、ループ1回の処理時間(ms)をファイルに出力する。

<script src="https://gist.github.com/kokuzawa/4646983.js"></script>

## 検証
まず改善前の結果。縦軸は処理時間(ms)、横軸は回数。
約5,000回で一度速度が改善しているが、全体的に右肩上がりで処理時間が劣化している。
簡易なコードであり、処理時間が数msのため、このままでも致命的な状況にならないかもしれないが、
tachされたエンティティの数が増加すると、それに比例して劣化していく。

![](/images/post_image_4.png)

次に改善後の結果。
約5,000回で速度が改善するのは同じだが、一定速度以上の劣化は起こらず安定している。

![](/images/post_image_5.png)

## 改善方法
では、何をすれば改善するのか。
結論から言えば、エンティティをdetachすれば良い。
detachすることによってエンティティはエンティティマネージャの管理外になり、通常のJavaのオブジェクトになる。
そのため、同期のためのオーバヘッドがなくなり、パフォーマンスが改善するのだと考えられるが確証はないので、
あとでEclipseLinkのソースコードを確認してみようと思う。
ただし、これによりDBとの同期は行えなくなるため、detachをする位置には注意が必要。

検証コードでは、ループ内の最後に下記2行を追加した。

``` java
em.flush();
em.clear();
```

`em.flush()`を呼び出しているのは、Bookエンティティが永続化される前にdetachされるのを回避するため。
ただし、これも注意が必要で、リレーション関係のあるエンティティを両方とも永続化しようとするケース等で、
片方をpersist、他方をpersistする前にflushしてしまうと、他方の永続化時にエラーが発生してしまう。

ちなみにflushやclearに関しては次の本が詳しい。

<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=FFFFFF&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=moonwhaleblog-22&o=9&p=8&l=as1&m=amazon&f=ifr&ref=qf_sp_asin_til&asins=4798124605" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

