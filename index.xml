<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KATSUMI KOKUZAWA&#39;S BLOG</title>
    <link>https://kokuzawa.github.io/</link>
    <description>Recent content on KATSUMI KOKUZAWA&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 18 Nov 2018 01:20:50 +0900</lastBuildDate>
    
        <atom:link href="https://kokuzawa.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Flowchart of Creating RESTful API</title>
      <link>https://kokuzawa.github.io/blog/2018/11/18/flowchart-of-creating-api/</link>
      <pubDate>Sun, 18 Nov 2018 01:20:50 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/11/18/flowchart-of-creating-api/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;うちのチームでAPIを作成する際に使用しているフローチャートを公開します。
HTTPステータスコードですが、APサーバやフレームワークで勝手に返却するもの、
APIを作成する上であまり利用しないものはあえて無視しています。
まあ、これが最終形という訳ではなく、日々足したり引いたりしているのですが、
指針としてはシンプルにできたかな、と思っています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;https://kokuzawa.github.io/images/FlowchartOfCreatingAPI.svg&#34; alt=&#34;FlowchartOfCreatingAPI&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;Figure 1. Flowchart of Creating RESTful API&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;dlist&#34;&gt;
&lt;dl&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;Method&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;処理内容によってMethodを分けます。RESTful APIの基本です。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;入力値検証&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;入力値を検証します。Bean Validationでやる感じ。
不正な入力を検知したら &lt;code&gt;400&lt;/code&gt; を返却します。
何のパラメータが不正なのか、といった情報も返却すべきかもしれません。
Bean Validationだと &lt;code&gt;ConstraintViolationException&lt;/code&gt; にそういった情報が入っています。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;認証&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;操作者のアカウントが登録されているか判定します。
Basic認証とかです。
認証できなければ &lt;code&gt;401&lt;/code&gt; を返却します。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;認可&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;権限判定です。
読み込み権限しかないのか、書き込み権限があるのか、はたまた管理権限があるのかなど。
権限がなければ &lt;code&gt;403&lt;/code&gt; を返却します。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;処理&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;ビジネスロジックです。
ここでデータを色々弄ります。
弄ろうとしたデータがなければ &lt;code&gt;404&lt;/code&gt; 、データが登録されていたら &lt;code&gt;409&lt;/code&gt; 、
ヌルポとかランタイム系のエラーの場合は &lt;code&gt;500&lt;/code&gt; を返却します。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;非同期&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;あまり使わないかも。
例えば、メール送信実行をリクエストしたけど、実際に送信されるのは10分後ですよ、などという場合に &lt;code&gt;202&lt;/code&gt; を返却します。
返却データとして「10分後に実行します」というのがわかるようなデータを返すのが作法のようです。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;返却データ無&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;削除処理や、登録、更新処理で返却データが無い場合は &lt;code&gt;204&lt;/code&gt; を返却します。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;新規登録データ&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;POST(登録)の場合にここまできたら &lt;code&gt;201&lt;/code&gt; になります。
それ以外は &lt;code&gt;200&lt;/code&gt; ですね。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_フローチャート図について&#34;&gt;フローチャート図について&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ちなみに、上のフローチャート図は &lt;a href=&#34;http://blockdiag.com/ja/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blockdiag&lt;/a&gt; を使って作りました。
こんな感じです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;blockdiag {
    orientation = portrait;
    edge_layout = flowchart;

    Action [label=&#34;Start&#34;, shape=flowchart.terminator];
    Method [label=&#34;Method&#34;, shape=flowchart.condition];
    Validation [label=&#34;入力値検証&#34;, shape=flowchart.condition];
    Authentication [label=&#34;認証&#34;, shape=flowchart.condition];
    Authorization [label=&#34;認可&#34;, shape=flowchart.condition];
    Process [label=&#34;処理&#34;, shape=flowchart.condition];
    Async [label=&#34;非同期&#34;, shape=flowchart.condition];
    Content [label=&#34;返却\nデータ無&#34;, shape=flowchart.condition];
    New [label=&#34;新規登録\nデータ&#34;, shape=flowchart.condition];
    400 [label=&#34;400&#34;, shape=flowchart.terminator, color=pink];
    401 [label=&#34;401&#34;, shape=flowchart.terminator, color=pink];
    403 [label=&#34;403&#34;, shape=flowchart.terminator, color=pink];
    404 [label=&#34;404&#34;, shape=flowchart.terminator, color=pink];
    409 [label=&#34;409&#34;, shape=flowchart.terminator, color=pink];
    500 [label=&#34;500&#34;, shape=flowchart.terminator, color=pink];
    202 [label=&#34;202&#34;, shape=flowchart.terminator, color=lightblue];
    204 [label=&#34;204&#34;, shape=flowchart.terminator, color=lightblue];
    200 [label=&#34;200&#34;, shape=flowchart.terminator, color=lightblue];
    201 [label=&#34;201&#34;, shape=flowchart.terminator, color=lightblue];

    // Action
    Action -&amp;gt; Method;
    Method -&amp;gt; GET[label=&#34;取得&#34;];
    Method -&amp;gt; POST[label=&#34;登録&#34;];
    Method -&amp;gt; PUT[label=&#34;更新&#34;];
    Method -&amp;gt; DELETE[label=&#34;削除&#34;];

    // Method
    GET -&amp;gt; Validation;
    POST -&amp;gt; Validation;
    PUT -&amp;gt; Validation;
    DELETE -&amp;gt; Validation;

    // Validation
    Validation -&amp;gt; Authentication[label=OK];
    Validation -&amp;gt; 400[label=NG];

    // Authentication
    Authentication -&amp;gt; Authorization[label=OK];
    Authentication -&amp;gt; 401[label=NG];

    // Authorization
    Authorization -&amp;gt; Process[label=OK];
    Authorization -&amp;gt; 403[label=NG];

    // Process
    Process -&amp;gt; Async[label=OK];
    Process -&amp;gt; 404[label=NG];
    Process -&amp;gt; 409[label=NG];
    Process -&amp;gt; 500[label=NG];

    // Async
    Async -&amp;gt; 202[label=YES];
    Async -&amp;gt; Content[label=NO];

    // Content
    Content -&amp;gt; 204[label=YES];
    Content -&amp;gt; New[label=NO];

    // New
    New -&amp;gt; 201[label=YES];
    New -&amp;gt; 200[label=NO];
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;blockdiagはasciidocに埋め込めるので、テキストベースでドキュメントを管理するのに便利なんですよ。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>[IDEA] blockdiagをIntelliJ IDEAで使う</title>
      <link>https://kokuzawa.github.io/blog/2018/11/17/use-blockdiag-with-idea/</link>
      <pubDate>Sat, 17 Nov 2018 19:39:33 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/11/17/use-blockdiag-with-idea/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_環境&#34;&gt;環境&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;macOS Mojave&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IntelliJ IDEA 2018.2.5&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_概要&#34;&gt;概要&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;IntelliJ IDEAにインストールしたAsciiDocプラグインで表示するAsciiDocファイルで、
blockdiagのイメージを表示したい。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_書いてみる&#34;&gt;書いてみる&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;test.adocファイルを作成してblockdiagを書いてみる。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;test.adoc&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;[blockdiag]
----
blockdiag {
  A -&amp;gt; B -&amp;gt; C -&amp;gt; D;
  A -&amp;gt; E -&amp;gt; F -&amp;gt; G;
}
----&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;これでプレビューに表示されると思ったんだけど、エラーが表示された。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;Failed to generate image: Could not find the &#39;blockdiag&#39;,
&#39;blockdiag3&#39; executable in PATH; add it to the PATH
or specify its location using the &#39;blockdiag&#39; document attribute
blockdiag {
  A -&amp;gt; B -&amp;gt; C -&amp;gt; D;
  A -&amp;gt; E -&amp;gt; F -&amp;gt; G;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;あーなるほど。Macのアプリは.bash_profileのPATHの設定は引き継がないのか。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_対応方法&#34;&gt;対応方法&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;code&gt;launchctl&lt;/code&gt; を使えば、.bash_profileに設定している$PATHをアプリ起動時に引き継ぐようにできるらしいんだけど、
なんとなく環境を弄るのはやりたくないので、adoc内にattributeを指定する方法で解決する。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;launchctlを使う場合&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo launchctl config user path $PATH&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;attributeで解決する場合&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;:blockdiag: /usr/local/bin/blockdiag
// ついでにフォントも指定してみる
:blockdiag-fontpath: &#34;/System/Library/Fonts/Hiragino Sans GB.ttc&#34;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://depressiverobot.com/2016/02/05/intellij-path.html&#34; class=&#34;bare&#34;&gt;http://depressiverobot.com/2016/02/05/intellij-path.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>[Nginx] NginxでGitリポジトリを共有</title>
      <link>https://kokuzawa.github.io/blog/2018/10/31/nginx-and-git/</link>
      <pubDate>Wed, 31 Oct 2018 23:20:12 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/10/31/nginx-and-git/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_環境&#34;&gt;環境&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows Subsystem for Linux (Ubuntu)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_概要&#34;&gt;概要&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;NginxでGitリポジトリを共有したい。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_必要なモジュールのインストール&#34;&gt;必要なモジュールのインストール&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo apt-get install nginx fcgiwrap spawn-fcgi&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_fcgiwrap_socketを作成&#34;&gt;fcgiwrap.socketを作成&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;/var/run/fgciwrap.socket&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;[Unit]
Description=fcgiwrap Socket

[Socket]
ListenStream=/run/fcgiwrap.sock

[Install]
WantedBy=sockets.target&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;permissionを変更&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo chmod 666 fcgiwrap.socket&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_etcnginxsites_availabledefaultを編集&#34;&gt;/etc/nginx/sites-available/defaultを編集&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;server {
    listen 80 default_server;
    listen [::]:80 default_server;

+    location ~ ^/git/.*\.git/(HEAD|info/refs|objects/info/.*|git-(upload|receive)-pack)$ {
+        client_max_body_size 0;
+        fastcgi_param SCRIPT_FILENAME /usr/lib/git-core/git-http-backend;
+        include fastcgi.conf;
+        fastcgi_pass unix:/var/run/fcgiwrap.socket;
+        fastcgi_split_path_info ^(/git)(/.*);
+        fastcgi_param SCRIPT_FILENAME /usr/lib/git-core/git-http-backend;
+        fastcgi_param GIT_PROJECT_ROOT /var/www/git;
+        fastcgi_param GIT_HTTP_EXPORT_ALL &#34;&#34;;
+        fastcgi_param PATH_INFO $fastcgi_path_info;
+        fastcgi_param REMOTE_USER $remote_user;
+    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_nginx起動&#34;&gt;Nginx起動&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo service nginx start&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_fcgiwrap起動&#34;&gt;fcgiwrap起動&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo /etc/init.d/fcgiwrap start&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_gitリポジトリ作成&#34;&gt;Gitリポジトリ作成&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo mkdir /var/www/git
sudo git init --bare --shared=group /var/www/git/hoge.git
sudo git config --file /var/www/git/hoge.git/config http.receivepack true
sudo chgrp -R www-data /var/www/git/hoge.git&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.pasokuma.net/linux/dev/git/gitnginx.html&#34; class=&#34;bare&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.pasokuma.net/linux/dev/git/gitnginx.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>[React] REST APIを呼び出す</title>
      <link>https://kokuzawa.github.io/blog/2018/09/16/start-react/</link>
      <pubDate>Sun, 16 Sep 2018 16:15:53 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/09/16/start-react/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_環境&#34;&gt;環境&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;macOS High Sierra (バージョン 10.13.6)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Node v10.10.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;npm 6.4.1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_概要&#34;&gt;概要&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;React で REST API を呼び出し、その結果を表示するアプリを作ります。
呼び出す API は &lt;a href=&#34;https://zipaddress.net&#34;&gt;郵便番号-住所検索API&lt;/a&gt; です。
郵便番号検索の API は色々あるのですが、こちらで公開されている API はクロスオリジン通信ができるため、これを利用します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_プロジェクトを作る&#34;&gt;プロジェクトを作る&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;はじめにReactプロジェクトを作ります。&lt;br&gt;
下記コマンドで &lt;code&gt;start-react&lt;/code&gt; フォルダにプロジェクトが生成されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ npx create-react-app start-react&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;生成されたプロジェクトは下記構成になっているはず。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;start-react
├── README.md
├── package-lock.json
├── package.json
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    └── registerServiceWorker.js&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_テンプレートを書き換える&#34;&gt;テンプレートを書き換える&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;code&gt;App.js&lt;/code&gt; を書き換えます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;以下の3つのファンクションを追加します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;constructor&lt;/code&gt;: コンストラクタ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;handleChange&lt;/code&gt;: 郵便番号入力欄の &lt;code&gt;onChange&lt;/code&gt; イベントで呼ばれるファンクション&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;handleSubmit&lt;/code&gt;: フォームの &lt;code&gt;onSubmit&lt;/code&gt; イベントで呼ばれるファンクション&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;constructor(props) {
    super(props);
    this.state = {
        zipcode: &#39;&#39;,
        address: &#39;&#39;
    };
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
}

handleChange(e) {
    this.setState({zipcode: e.target.value});
}

handleSubmit(e) {
    fetch(`https://api.zipaddress.net/?zipcode=${this.state.zipcode}`, {
        mode: &#39;cors&#39;
    })
        .then((response) =&amp;gt; {
            return response.json();
        })
        .then((myJson) =&amp;gt; {
            this.setState({address: myJson.data.fullAddress});
        });
    e.preventDefault();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;次に表示部分を書き換えます。
書き換えるのは以下の部分です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;書き換え前&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;p className=&#34;App-intro&#34;&amp;gt;
  To get started, edit &amp;lt;code&amp;gt;src/App.js&amp;lt;/code&amp;gt; and save to reload.
&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;書き換え後&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;form onSubmit={this.handleSubmit}&amp;gt;
    &amp;lt;p className=&#34;App-intro&#34;&amp;gt;
        &amp;lt;input type=&#34;text&#34; value={this.state.zipcode} onChange={this.handleChange}/&amp;gt;
        &amp;lt;input type=&#34;submit&#34; value=&#34;検索&#34;/&amp;gt;
    &amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;p&amp;gt;{this.state.address}&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_実行&#34;&gt;実行&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;下記のコマンドで実行します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ npm start&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;コードの書き方とか、React Component のライフサイクルとかの説明を端折っているので、
どうして画面が更新されるのだろうって思うかもしれないけど、この辺は公式ドキュメントを見てもらった方が正確だと思う。
特にライフサイクルを知らないと、余計な画面更新をしてしまったりするので、よく読んでおいた方が良さそうです。
&lt;a href=&#34;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&#34;&gt;ライフサイクル図&lt;/a&gt;が公開されているので、
これを参考にするといいと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://reactjs.org/docs/forms.html&#34;&gt;Forms - React&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&#34;&gt;React - ライフサイクル図&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zipaddress.net&#34;&gt;郵便番号-住所検索API&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>[JSF] ブラウザキャッシュを無効にする</title>
      <link>https://kokuzawa.github.io/blog/2018/08/08/disable-browser-caching-in-jsf/</link>
      <pubDate>Wed, 08 Aug 2018 23:11:26 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/08/08/disable-browser-caching-in-jsf/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;JSFでブラウザのキャッシュを無効にする方法。JSFでプロジェクトを始めるたびに検索するのがいい加減面倒になった、というわけでメモ。
&lt;code&gt;javax.faces.event.PhaseListener&lt;/code&gt; を実装したクラスで処理するので、一つ作っておけば全てのレスポンスに適用されます。
作ったクラスは faces-config.xml に登録します。
以下、必要最低限のコード。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;CacheControlPhaseListener.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package io.github.kokuzawa.faces;

import javax.faces.context.FacesContext;
import javax.faces.event.PhaseEvent;
import javax.faces.event.PhaseId;
import javax.faces.event.PhaseListener;
import javax.servlet.http.HttpServletResponse;

public class CacheControlPhaseListener implements PhaseListener
{
    @Override
    public void afterPhase(PhaseEvent phaseEvent)
    {
    }

    @Override
    public void beforePhase(PhaseEvent phaseEvent)
    {
        final FacesContext facesContext = phaseEvent.getFacesContext();
        final HttpServletResponse response = (HttpServletResponse) facesContext.getExternalContext().getResponse();
        response.addHeader(&#34;Pragma&#34;, &#34;no-cache&#34;);
        response.addHeader(&#34;Cache-Control&#34;, &#34;no-cache&#34;);
        response.addHeader(&#34;Cache-Control&#34;, &#34;no-store&#34;);
        response.addHeader(&#34;Cache-Control&#34;, &#34;must-revalidate&#34;);
        response.addHeader(&#34;Expires&#34;, &#34;Mon, 8 Aug 2006 10:00:00 GMT&#34;);
    }

    @Override
    public PhaseId getPhaseId()
    {
        return PhaseId.RENDER_RESPONSE;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;faces-config.xml&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;lifecycle&amp;gt;
    &amp;lt;phase-listener&amp;gt;io.github.kokuzawa.faces.CacheControlPhaseListener&amp;lt;/phase-listener&amp;gt;
&amp;lt;/lifecycle&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>[WildFly] EE8プレビューモードで起動する</title>
      <link>https://kokuzawa.github.io/blog/2018/07/20/wildfly-ee8-configuration/</link>
      <pubDate>Fri, 20 Jul 2018 14:42:51 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/07/20/wildfly-ee8-configuration/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_環境&#34;&gt;環境&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WildFly 13.0.0.Final&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_起動方法&#34;&gt;起動方法&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;WildFly 13.0.0.Final はデフォルトではEE7モードで起動します。
EE8の機能を有効にするにはEE8プレビューモードを有効にします。
これは、起動時に &lt;code&gt;ee8.preview.mode&lt;/code&gt; を指定します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;./standalone.sh -Dee8.preview.mode=true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;もう一つは、EE8プレビューモード用の設定ファイルを指定する方法です。
EE8プレビューモード用の設定ファイルと通常の設定ファイルの違いは、
システムプロパティへの &lt;code&gt;ee8.preview.mode&lt;/code&gt; 定義の有無だけのようです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;./standalone.sh -c standalone-ee8.xml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_intellij_idea_で起動&#34;&gt;IntelliJ IDEA で起動&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;通常の設定ファイルを利用する場合は、サーバ設定内のVM Optionsに &lt;code&gt;ee8.preview.mode&lt;/code&gt; を設定します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;-Dee8.preview.mode=true&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;EE8プレビューモード用の設定ファイルを利用する場合は、
VM Optionsに &lt;code&gt;jboss.server.default.config&lt;/code&gt; を設定して、読み込む設定ファイルを指定します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;-Djboss.server.default.config=standalone-ee8.xml&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://wildfly.org/news/2018/05/30/WildFly13-Final-Released/&#34;&gt;WildFly 13 &#34;Baker’s Dozen&#34; is released!&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>JSON-B を試す</title>
      <link>https://kokuzawa.github.io/blog/2018/07/06/jsonb-example/</link>
      <pubDate>Fri, 06 Jul 2018 01:53:22 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/07/06/jsonb-example/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_json_b_って何&#34;&gt;JSON-B って何？&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;JSON-B は Java オブジェクトを JSON メッセージに変換する、または JSON メッセージを Java オブジェクトに変換するためのライブラリです。
Java EE 8 に含まれています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_使ってみる&#34;&gt;使ってみる&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Java EE 8 に含まれますが、単独で使用することが可能です。
下記の3つのライブラリを利用します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.json.bind&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.json.bind-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.eclipse&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;yasson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.glassfish&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.json&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;JSON メッセージに変換する Java オブジェクトクラスを用意します。
あとで説明したいことがあるので、Immutable なクラスにしています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;public class User
{
    private final String name;
    private final int age;

    public User(String name, int age)
    {
        this.name = name;
        this.age = age;
    }

    public String getName()
    {
        return name;
    }

    public int getAge()
    {
        return age;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;最初は Java オブジェクトを JSON メッセージに変換してみます。
&lt;code&gt;JsonbBuilder#create()&lt;/code&gt; メソッドはインターフェースに定義された static メソッドなので、
Java 8 以降じゃないとコンパイルできません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;import org.junit.Test;
import javax.json.bind.Jsonb;
import javax.json.bind.JsonbBuilder;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;

public class AppTest
{
    @Test
    public void testToJson()
    {
        final Jsonb jsonb = JsonbBuilder.create();
        final String result = jsonb.toJson(new User(&#34;katsumi&#34;, 40));
        assertThat(result, is(&#34;{\&#34;age\&#34;:40,\&#34;name\&#34;:\&#34;katsumi\&#34;}&#34;));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;次に JSON メッセージを Java オブジェクトに変換してみます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;import org.junit.Test;
import javax.json.bind.Jsonb;
import javax.json.bind.JsonbBuilder;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;

public class AppTest
{
    @Test
    public void testFromJson()
    {
        final Jsonb jsonb = JsonbBuilder.create();
        final String text = &#34;{\&#34;age\&#34;:40,\&#34;name\&#34;:\&#34;katsumi\&#34;}&#34;;
        final User user = jsonb.fromJson(text, User.class);
        assertThat(user.getAge(), is(40));
        assertThat(user.getName(), is(&#34;katsumi&#34;));
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このまま実行すると &lt;code&gt;Jsonb#fromJson(String, Class&amp;lt;T&amp;gt;)&lt;/code&gt; メソッドでエラーになります。
JSON メッセージを Java オブジェクトに変換するためにはデフォルトコンストラクタが必要なのですが、
今回作成した User クラスは Immutable にしている関係でデフォルトコンストラクタがありません。
そのため下記のエラーが発生します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;javax.json.bind.JsonbException: Can&#39;t create instance of a class: class org.katsumi.User, No default constructor found.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;JSON-B にはカスタムコンストラクタをサポートする仕組みが用意されているので、
User クラスのコンストラクタを下記のように変更しました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;import javax.json.bind.annotation.JsonbCreator;
import javax.json.bind.annotation.JsonbProperty;

...

    @JsonbCreator
    public User(
            @JsonbProperty(&#34;name&#34;) String name,
            @JsonbProperty(&#34;age&#34;) int age)
    {
        this.name = name;
        this.age = age;
    }

...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この修正後に再度実行すると処理が成功します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://json-b.net/index.html&#34;&gt;JSON Binding (JSON-B)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>[JSF 2.3] Websocket を試す（その２）</title>
      <link>https://kokuzawa.github.io/blog/2018/07/04/websocket-part2/</link>
      <pubDate>Wed, 04 Jul 2018 01:54:11 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/07/04/websocket-part2/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://kokuzawa.github.io/blog/2017/01/12/jsf-2-3-websocket/&#34;&gt;以前&lt;/a&gt;、リリース前のJSF2.3を利用してWebsocketを試したことを書きました。&lt;br&gt;
その時はWildFlyで動かすことができなかったのですが、WildFlyも13.0.0.Finalになり、
JSF2.3を含んだJavaEE8をプレビューモードで起動できるようになったので、もう一度Websocketを試してみることにします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_環境&#34;&gt;環境&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;macOS High Sierra&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java&amp;#8482; SE Runtime Environment (build 1.8.0_91-b14)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WildFly 13.0.0.Final&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_実装&#34;&gt;実装&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フルセットのコードは下記にあります。&lt;br&gt;
&lt;a href=&#34;https://github.com/kokuzawa/sandbox/tree/master/websocket-example&#34; class=&#34;bare&#34;&gt;https://github.com/kokuzawa/sandbox/tree/master/websocket-example&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;通常のJSFの設定の他に、下記設定がweb.xmlに必要です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;web.xml&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;javax.faces.ENABLE_CDI_RESOLVER_CHAIN&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;javax.faces.ENABLE_WEBSOCKET_ENDPOINT&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;管理BeanはApplicationScopeの必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;PushBean.java&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;import javax.enterprise.context.ApplicationScoped;
import javax.faces.push.Push;
import javax.faces.push.PushContext;
import javax.inject.Named;
import java.io.Serializable;
import java.util.Calendar;

@Named
@ApplicationScoped
public class PushBean implements Serializable
{
    @Push(channel = &#34;clock&#34;)
    private PushContext push;

    public void clockAction()
    {
        final Calendar now = Calendar.getInstance();

        final String time = now.get(Calendar.HOUR_OF_DAY) + &#34;:&#34; +
                now.get(Calendar.MINUTE) + &#34;:&#34; + now.get(Calendar.SECOND);

        push.send(time);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;XHTMLで重要なのは下記だけです。
&lt;code&gt;websocket&lt;/code&gt; タグの &lt;code&gt;chaannel&lt;/code&gt; 属性で指定した値と、管理Beanの &lt;code&gt;Push&lt;/code&gt; アノテーションで指定した値が一致する必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;index.xhtml&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xhtml&#34; data-lang=&#34;xhtml&#34;&gt;&amp;lt;f:websocket channel=&#34;clock&#34; onmessage=&#34;socketListener&#34; /&amp;gt;

&amp;lt;script type=&#34;text/javascript&#34;&amp;gt;
    function socketListener(message, channel, event) {
        document.getElementById(&#34;clockId&#34;).innerHTML += message + &#34;&amp;amp;lt;br/&amp;amp;gt;&#34;;
    }
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_実行&#34;&gt;実行&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;起動オプションに下記を設定することで、WildFlyがJavaEE8モードで起動します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;-Dee8.preview.mode=true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;前回と異なり、余計な設定をしなくても問題なく実行できました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>子ノードにドロップをすると StackOverflowError が発生</title>
      <link>https://kokuzawa.github.io/blog/2018/06/28/bug-primefaces/</link>
      <pubDate>Thu, 28 Jun 2018 01:16:27 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2018/06/28/bug-primefaces/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_要約&#34;&gt;要約&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;PrimeFaces-6.2 の Tree コンポーネントにバグがあります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この問題は報告済みです。
対応状況や詳しい内容は下記を参照してください。&lt;br&gt;
&lt;a href=&#34;https://github.com/primefaces/primefaces/issues/3771&#34;&gt;Tree: &#34;StackOverflowError&#34; when a node is dropped to own child node&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_再現方法&#34;&gt;再現方法&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;再現はとても簡単です。
PrimeFaces の &lt;a href=&#34;https://www.primefaces.org/showcase/ui/data/tree/dragdrop.xhtml&#34;&gt;Showcase&lt;/a&gt; で、
&lt;code&gt;Node 0&lt;/code&gt; をドラッグして &lt;code&gt;Node 0.0&lt;/code&gt; にドロップするだけです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この操作を実施するとエラー画面が表示されます。
以前はスタックトレースが画面に表示されたのですが、
新しいデザインになってからは表示がされず、何が起きたのかよくわからないかもしれません。
ローカル環境でこの操作を実施すると、下記のエラーが発生します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;java.lang.StackOverflowError
at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202)
at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202)
at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202)
at org.primefaces.model.TreeNodeChildren.updateRowKeys(TreeNodeChildren.java:202)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>PrimeFaces-6.1 Dblclick Event</title>
      <link>https://kokuzawa.github.io/blog/2017/12/04/primefaces-dblclick/</link>
      <pubDate>Mon, 04 Dec 2017 01:40:41 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2017/12/04/primefaces-dblclick/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;今作っているWebアプリでリンクをダブルクリックで動作させるという要求が出たので、
どうやって実現するのか調べてみました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_通常のリンクを実装してみる&#34;&gt;通常のリンクを実装してみる&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;PrimeFacesの &lt;code&gt;commandLink&lt;/code&gt; コンポーネントでリンクを実装します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;p:commandLink value=&#34;Single Click&#34; action=&#34;#{bean.onClick}&#34; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_ダブルクリックで動作するリンクを実装してみる&#34;&gt;ダブルクリックで動作するリンクを実装してみる&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;code&gt;commandLink&lt;/code&gt; コンポーネントで実装すると、 &lt;code&gt;onclick&lt;/code&gt; イベントで動作するようにレンダリングされてしまうので、
&lt;code&gt;link&lt;/code&gt; コンポーネントで実装します。 &lt;code&gt;href&lt;/code&gt; を指定するのがコツです。
&lt;code&gt;link&lt;/code&gt; コンポーネントでは &lt;code&gt;dblclick&lt;/code&gt; イベントだけを発生させ、実際の呼び出しは &lt;code&gt;remoteCommand&lt;/code&gt; コンポーネントで行います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;p:link href=&#34;#&#34; value=&#34;Double Click&#34; ondblclick=&#34;dblClickEvent()&#34; /&amp;gt;
&amp;lt;p:remoteCommand name=&#34;dblClickEvent&#34; action=&#34;#{bean.onClick}&#34; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Hugoで始めるブログ生活</title>
      <link>https://kokuzawa.github.io/blog/2017/11/24/my-first-post/</link>
      <pubDate>Fri, 24 Nov 2017 01:56:46 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2017/11/24/my-first-post/</guid>
      <description>&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_step_1_hugoをインストール&#34;&gt;Step 1: Hugoをインストール&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;macOSでHomebrewがインストールされていることが前提です。&lt;br&gt;
brewを使ってHugoをインストールします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ brew install hugo&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;asciidoc形式で記事を書くつもりなので、asciidoctorもインストールします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ brew install asciidoctor&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_step_2_サイトを作る&#34;&gt;Step 2: サイトを作る&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Hugoをインストールしたら、はじめにサイトを作ります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ hugo new site hugo-quickstart&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;カレントフォルダに &lt;code&gt;hugo-quickstart&lt;/code&gt; フォルダが作られます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_step_3_テーマを追加&#34;&gt;Step 3: テーマを追加&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Hugoの &lt;a href=&#34;https://themes.gohugo.io&#34;&gt;テーマサイト&lt;/a&gt; から好きなテーマを選んで追加します。
個人的にCactusというテーマが気に入ったのでこれを取得します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ cd hugo-quickstart/themes
$ git clone https://github.com/digitalcraftsman/hugo-cactus-theme.git&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;テーマを追加したら、そのテーマを使うことを宣言しなければなりません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;config.toml&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;theme = &#34;hugo-cactus-theme&#34;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;さらにこのテーマは下記の設定も追記しないとダメなようです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;config.toml&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;[params]
name = &#34;Katsumi Kokuzawa&#34;
bio = &#34;Programmer&#34;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_step_4_記事を追加&#34;&gt;Step 4: 記事を追加&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;記事ファイルを追加します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ hugo new posts/my-first-post.adoc&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;追加した記事は &lt;code&gt;hugo server&lt;/code&gt; をドラフトモードで起動することで確認できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ hugo server -D&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;起動したら &lt;a href=&#34;http://localhost:1313/&#34; class=&#34;bare&#34;&gt;http://localhost:1313/&lt;/a&gt; にアクセスします。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>JSF 2.3 の Websocket を試す</title>
      <link>https://kokuzawa.github.io/blog/2017/01/12/jsf-2-3-websocket/</link>
      <pubDate>Thu, 12 Jan 2017 00:29:21 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2017/01/12/jsf-2-3-websocket/</guid>
      <description>

&lt;p&gt;JSF 2.3 では新しい機能として Websocket が追加されます。&lt;br /&gt;
JSF 2.3 はまだリリースされていませんが、先日 JSF 2.3-m09 が公開されたので、
これを使って Websocket を試してみようと思います。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;macOS Sierra&lt;/li&gt;
&lt;li&gt;Java&amp;trade; SE Runtime Environment (build 1.8.0_91-b14)&lt;/li&gt;
&lt;li&gt;WildFly 10.1.0.Final&lt;/li&gt;
&lt;li&gt;Payara Server 4.1.1.164&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;今回やったことは下記に書いてあることそのままです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.payara.fish/jsf-2.3-the-websocket-quickstart-under-payara-server&#34;&gt;http://blog.payara.fish/jsf-2.3-the-websocket-quickstart-under-payara-server&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ボタンをクリックすることでサーバサイドから時間を取得してそれを表示するアプリを作ります。
アプリの作り方は上記サイトを見てもらえばわかると思うので、ここでは上記のサイトには書かれていない、
JavaEE8に対応していない現状のAPサーバで JSF 2.3 を有効にする方法について説明します。&lt;/p&gt;

&lt;h2 id=&#34;wildfly-10-1-0-final-で試す&#34;&gt;WildFly 10.1.0.Final で試す&lt;/h2&gt;

&lt;p&gt;まず、普段利用している WildFly で動かそうとしてみました。
WildFly で JSF 2.3 を有効にするためには、WildFly が内包する JSF を無効にする必要があります。
無効にする方法は、下記の記述をした &lt;code&gt;WEB-INF/jboss-deployment-structure.xml&lt;/code&gt; を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;jboss-deployment-structure xmlns=&amp;quot;urn:jboss:deployment-structure:1.2&amp;quot;&amp;gt;

    &amp;lt;deployment&amp;gt;
        &amp;lt;exclude-subsystems&amp;gt;
            &amp;lt;subsystem name=&amp;quot;jsf&amp;quot;/&amp;gt;
        &amp;lt;/exclude-subsystems&amp;gt;
    &amp;lt;/deployment&amp;gt;

&amp;lt;/jboss-deployment-structure&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSF 2.3 の jar ファイルは &lt;code&gt;WEB-INF/lib&lt;/code&gt; フォルダに配置します。
この状態で WildFly にデプロイし、表示した画面でボタンをクリックすると下記のエラーが発生してしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Caused by: javax.faces.el.EvaluationException: javax.el.PropertyNotFoundException: /index.xhtml @15,73 action=&amp;quot;#{pushBean.clockAction}&amp;quot;: Target Unreachable, identifier &#39;pushBean&#39; resolved to null
	at javax.faces.component.MethodBindingMethodExpressionAdapter.invoke(MethodBindingMethodExpressionAdapter.java:94)
	at com.sun.faces.application.ActionListenerImpl.processAction(ActionListenerImpl.java:102)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ApplicationScoped を付与した PushBean クラスがインスタンス化されていないようです。
スコープを変えたり、色々試してみたのですが動作は変わらないので諦めました。
動かす方法をご存知でしたら教えて頂けると嬉しいです。&lt;/p&gt;

&lt;h2 id=&#34;payara-server-で試す&#34;&gt;Payara Server で試す&lt;/h2&gt;

&lt;p&gt;参考にしたサイトは Payara を使っているので、次に Payara で試してみることにしました。
Payara も JSF を内包しているので何もせずにデプロイすると下記エラーが発生します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Caused by: java.lang.reflect.MalformedParameterizedTypeException
	at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.validateConstructorArguments(ParameterizedTypeImpl.java:58)
	at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.&amp;lt;init&amp;gt;(ParameterizedTypeImpl.java:51)
	at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(ParameterizedTypeImpl.java:92)
	at sun.reflect.generics.factory.CoreReflectionFactory.makeParameterizedType(CoreReflectionFactory.java:105)
	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:140)
	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
	at sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68)
	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138)
	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
	at sun.reflect.generics.repository.ClassRepository.getSuperclass(ClassRepository.java:90)
	at java.lang.Class.getGenericSuperclass(Class.java:777)
	at javax.enterprise.util.TypeLiteral.getTypeParameter(TypeLiteral.java:103)
	at javax.enterprise.util.TypeLiteral.getType(TypeLiteral.java:66)
	at com.sun.faces.cdi.CdiUtils.&amp;lt;clinit&amp;gt;(CdiUtils.java:76)
	... 65 more
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Payara が内包する JSF を無効にする方法がわからなかったのですが、
Payara の場合は視点が違っていて、内包する JSF を無効にするのではなく、
Bundle した JSF を有効にする設定をしなければならないようです。
Bundle した JSF を有効にする方法は下記の記述をした &lt;code&gt;WEB-INF/glassfish-web.xml&lt;/code&gt; を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE glassfish-web-app PUBLIC
        &amp;quot;-//GlassFish.org//DTD GlassFish Application Server 3.1 Servlet 3.0//EN&amp;quot;
        &amp;quot;http://glassfish.org/dtds/glassfish-web-app_3_0-1.dtd&amp;quot;&amp;gt;
&amp;lt;glassfish-web-app&amp;gt;
    &amp;lt;class-loader delegate=&amp;quot;false&amp;quot; /&amp;gt;
    &amp;lt;property name=&amp;quot;useBundledJsf&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
&amp;lt;/glassfish-web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;設定さえわかれば何も難しい話ではなかったんですが、
設定方法がわからなくて時間がかかってしまいました。
特に Payara の方は全然情報が見つからなくて苦戦&amp;hellip;。
基本的にはリリースされてJavaEE8対応されたAPサーバで動かすことになるので知らなくても問題ないわけですが、
早期に試そうとすると色々とハードルがあり大変です。まあそれが楽しかったりするんですけどね。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.payara.fish/jsf-2.3-the-websocket-quickstart-under-payara-server&#34;&gt;JSF 2.3 - The WebSocket Quickstart under Payara Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/10782528/how-to-update-mojarra-version-in-glassfish&#34;&gt;How to update Mojarra version in GlassFish&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>PrimeNGを組み込む</title>
      <link>https://kokuzawa.github.io/blog/2016/12/28/primeng/</link>
      <pubDate>Wed, 28 Dec 2016 11:02:35 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/12/28/primeng/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://kokuzawa.github.io/blog/2016/12/28/intellij-ideaangular2/&#34;&gt;昨日&lt;/a&gt;、 Angular2 アプリを IntelliJ IDEA で動かすところまでやってみました。
今日は本来の目的である PrimeNG を使ってみます。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;primeng-とは&#34;&gt;PrimeNG とは&lt;/h2&gt;

&lt;p&gt;JSF の実装の一つである PrimeFaces と同じところが作っている Angular2 用の Rich UI Components です。
PrimeFaces とほぼ同じ（まだ PrimeNG の方が少ない）コンポーネント群を Angular2 から利用できるプロダクトです。
現在の最新バージョンは 1.1.2 です。&lt;/p&gt;

&lt;h2 id=&#34;primeng-のインストール&#34;&gt;PrimeNG のインストール&lt;/h2&gt;

&lt;p&gt;PrimeNG の &lt;a href=&#34;http://www.primefaces.org/primeng/#/setup&#34;&gt;Setup&lt;/a&gt; に書いてありますが、
プロジェクトフォルダで下記コマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$npm install primeng --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;primeng-を組み込む&#34;&gt;PrimeNG を組み込む&lt;/h2&gt;

&lt;p&gt;PrimeNG のインストールはできたので昨日作ったアプリに PrimeNG を組み込んでみます。
まず、PrimeNG 用の css が用意されているのでそれを追加します。
css の定義を index.html に書いてみたのですが、
表示された画面で確認すると css ファイルが見つからない状態となります。
色々試行錯誤した結果、&lt;code&gt;src/style.css&lt;/code&gt; ファイルに下記を追加することで期待した css が読み込まれることが分かりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@import url(&#39;../node_modules/primeng/resources/themes/omega/theme.css&#39;);
@import url(&#39;../node_modules/primeng/resources/primeng.min.css&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;読み込まれるというは正確ではなく、インポートした css が style.css ファイル内に展開されて、
それが html のヘッダに組み込まれるというのが正しい表現になります。
おそらくビルド時にそういうことをしているのだと思うのですが、
Angular のビルドフローがよくわかっていないのでなんとも言えません。
&lt;code&gt;src/style.css&lt;/code&gt; に何も書いていないと html にも組み込まれないので何か判定があるのかと。&lt;/p&gt;

&lt;p&gt;で、実はこれだけだと片手落ちで、&lt;a href=&#34;http://fontawesome.io&#34;&gt;Font Awesome&lt;/a&gt; で提供されている css と font 群を取り込まないと、
PrimeNG でのアイコン表示ができない状態となります。
まず、Font Awesome のサイトでフォントアイコンをダウンロードします。
プロジェクトの src フォルダ直下に resources フォルダを作り、
その下にダウンロードしたモジュール内にある、css フォルダと fonts フォルダをコピーします。
独自で取り込んだ css などをどこに配置するのが Angular として正しいのかよくわからないので、
PrimeNG の Showcace のソースコードと同じ構成にしてみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/style.css&lt;/code&gt; にインポートを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@import url(&#39;/resources/css/font-awesome.min.css&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;primeng-の-button-コンポーネントを配置&#34;&gt;PrimeNG の Button コンポーネントを配置&lt;/h2&gt;

&lt;p&gt;事前の準備ができたので、PrimeNG のコンポーネントの中から Button コンポーネントを配置します。
&lt;code&gt;src/app/app.component.html&lt;/code&gt; に下記のコードを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;button pButton type=&amp;quot;button&amp;quot; icon=&amp;quot;fa-check&amp;quot; iconPos=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に &lt;code&gt;src/app/app.module.ts&lt;/code&gt; を下記のように変更します。
diff がハイライトされていませんが差分表示です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  import { BrowserModule } from &#39;@angular/platform-browser&#39;;
  import { NgModule } from &#39;@angular/core&#39;;
  import { FormsModule } from &#39;@angular/forms&#39;;
  import { HttpModule } from &#39;@angular/http&#39;;

  import { AppComponent } from &#39;./app.component&#39;;
+ import {ButtonModule} from &#39;primeng/primeng&#39;;

  @NgModule({
    declarations: [
      AppComponent
    ],
    imports: [
      BrowserModule,
      FormsModule,
-     HttpModule
+     HttpModule,
+     ButtonModule
    ],
    providers: [],
    bootstrap: [AppComponent]
  })
  export class AppModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実行&#34;&gt;実行&lt;/h2&gt;

&lt;p&gt;実行すると下記の画面が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_43.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;PrimeNG のドキュメントを見ても module.ts ファイルを編集などは書いてないので、
この辺りのことは Angular を知っていればわかることなのかなぁとなんとなくモヤモヤした感じです。
実際仕組みがわかれば大したことをしていない気がするので、
もう少し色々試してみようと思います。
次はボタンへのイベントハンドリングをしてみようかと考えています。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.primefaces.org/primeng/#/button&#34;&gt;PrimeNG Demo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IntelliJ IDEAでAngular2アプリを動かす</title>
      <link>https://kokuzawa.github.io/blog/2016/12/28/intellij-ideaangular2/</link>
      <pubDate>Wed, 28 Dec 2016 00:39:11 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/12/28/intellij-ideaangular2/</guid>
      <description>

&lt;p&gt;Angular2のアプリをIntelliJ IDEAで動かすまでの試行錯誤の記録です。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;macOS Sierra&lt;/li&gt;
&lt;li&gt;IntelliJ IDEA 2016.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;angular2のインストール&#34;&gt;Angular2のインストール&lt;/h2&gt;

&lt;p&gt;Angular2を動かすのにはNode.jsが必要なので、最初にNode.jsをインストールします。
macOSの場合、homebrewでnodebrewを入れるのが良さそうです。
nodebrewはNode.jsのバージョン管理システムだそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$brew install nodebrew
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nodebrewインストール直後だと、カレントのNode.jsが選択されていないため、
Node.jsのコマンドを打ってもそんなコマンドはないと怒られてしまいます。
そこで、カレントのNode.jsを選択します。
選択方法ですが、まずインストールされているNode.jsのバージョンを知る必要があるので、
下記コマンドを実行し、バージョンリストを表示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nodebrew list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンが表示されたら、利用したいバージョンを指定した下記コマンドを実行します。
私の環境ではv7.3.0がインストールされていたので、これをカレントにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nodebrew use v7.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでNode.jsが使えるようになりました。&lt;/p&gt;

&lt;p&gt;次に目的のAngular2をインストールするわけですが、
ここではコマンドラインツールであるangular-cliをインストールします。
インストールはnpm(Node Package Manager)を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$npm install -g angular-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでAngular2アプリを作る準備ができました。&lt;/p&gt;

&lt;h2 id=&#34;angular2アプリを作る&#34;&gt;Angular2アプリを作る&lt;/h2&gt;

&lt;p&gt;早速アプリを作りたいのですが、IntelliJ IDEAではAngularプロジェクトを作るメニューはありません。
プラグイン等であるのかもしれませんが、プレーンな状態ではできないので、
Angular-cliを使って雛形のプロジェクトを作成します。
プロジェクトを作りたいフォルダに移動して下記コマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ng new angular-start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで雛形のアプリが作成されました。
angular-startフォルダに移動して下記コマンドを実行すると、&lt;code&gt;http://localhost:4200/&lt;/code&gt;で最初の画面が表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ng serve
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;intellij-ideaに読み込む&#34;&gt;IntelliJ IDEAに読み込む&lt;/h2&gt;

&lt;p&gt;ここまでの作業でAngular2の動作するアプリはできましたが、
IntelliJ IDEAでの編集はまだできません。
IntelliJ IDEAで編集するために下記手順でプロジェクトを読み込みます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;File -&amp;gt; New -&amp;gt; Project from Existing Sources&amp;hellip; を選択してangular-startフォルダを選択する&lt;/li&gt;
&lt;li&gt;Import ProjectダイアログでCreate Project from existing sourcesを選択してNextボタンをクリックする&lt;/li&gt;
&lt;li&gt;以降は何も変更せず、Nextボタンをクリックする&lt;/li&gt;
&lt;li&gt;Finishボタンが表示されたらそれをクリックする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これでソースの読み込みは完了しました。&lt;/p&gt;

&lt;h2 id=&#34;intellij-ideaで実行する&#34;&gt;IntelliJ IDEAで実行する&lt;/h2&gt;

&lt;p&gt;Run -&amp;gt; Edit Configurations&amp;hellip; を選択してRun/Debug Configurationsダイアログを表示します。
下記イメージではnpmの実行設定を既に作成した状態になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_42.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;イメージ右側のNode Interpreterの部分、選択された状態となっていますが、
これはIntelliJ IDEAにNodeJSプラグインをインストールしていないと選択されません。
ですので、事前にNodeJSプラグインをインストールする必要があります。&lt;/p&gt;

&lt;p&gt;package.json, Scripts, Argumentsの部分が空白となっていると思うので、
イメージ内で設定しているように設定します。
これで実行する準備が整いました。
実行するとコマンドラインで&lt;code&gt;ng serve&lt;/code&gt;とした時と同様のログがコンソールに出力されるのが確認できると思います。
最初の時と同じように、起動後&lt;code&gt;http://localhost:4200&lt;/code&gt;にアクセスすることで最初の画面を表示することができます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;コマンドラインからプロジェクトを作った後にIntelliJ IDEAに読み込ませるのがちょっと面倒です。
プラグインでAngular2のプロジェクトが作れるようになると良いのですが、
今の所できなさそうです。（どこかにあるのかな？）
ただし、一度読み込ませてしまえば、後は使い慣れたIntelliJ IDEA上で編集ができるし、
補完も効くので開発効率が良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gitbook.com/book/albatrosary/start-angular/details&#34;&gt;Start Angular&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dialog of PrimeFaces</title>
      <link>https://kokuzawa.github.io/blog/2016/12/25/opendialog-of-primefaces/</link>
      <pubDate>Sun, 25 Dec 2016 15:10:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/12/25/opendialog-of-primefaces/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2016/javaee&#34;&gt;Java EE Advent Calendar 2016&lt;/a&gt;の25日目です。&lt;br /&gt;
昨日は&lt;a href=&#34;http://qiita.com/kikutaro&#34;&gt;@kikutaro&lt;/a&gt;さんの「&lt;a href=&#34;http://qiita.com/kikutaro/items/a524038ca7306a8bfee3&#34;&gt;実はJava EEに含まれるJavaMailについて&lt;/a&gt;」でした。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;現在業務でJSFを使っています。
導入当初はRIであるMojarraのみを利用しようと考えていたのですが、
業務アプリで多い、ツリーやグリッドで数多くのアクションを実装しなければならず、
一つ一つをJavaScriptで実装していくには時間が足りないという判断のもとに、
それらを簡易に実現できるPrimeFacesを利用することにしました。
採用を決定した段階での最新バージョンはPrimeFaces-6.0です。
PrimeFacesは充実したコンポーネント群を持っているので、
必要なコンポーネントはほぼ見つけることができるかと思います。&lt;/p&gt;

&lt;p&gt;さて、今回はその中でダイアログコンポーネントについて説明します。
PrimeFacesのDemoを見るとわかるのですが、
このダイアログコンポーネントを表示するための方法が二通り用意されています。&lt;/p&gt;

&lt;p&gt;一つ目は静的にダイアログを表示する方法です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;XHTML:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;p:dialog widgetVar=&amp;quot;sampleDialog&amp;quot;&amp;gt;
  ...
&amp;lt;/p:dialog&amp;gt;

&amp;lt;p:commandButton value=&amp;quot;Show&amp;quot; oncomplete=&amp;quot;PF(&#39;sampleDialog&#39;).show()&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二つ目の方法は動的にダイアログを表示する方法です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ManagedBean:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onShowDialog()
{
    RequestContext.getCurrentInstance().openDialog(&amp;quot;dialog.xhtml&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;XHTML:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;p:commandButton value=&amp;quot;Show&amp;quot; actionListener=&amp;quot;#{bean.onShowDialog}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二つ目の方法は指定したXHTMLをiframe内に表示して、それをダイアログとして表示してくれます。
一つ目の方法と異なり、
ダイアログ内のコンテンツを別XHTMLに分けることができるのでコードの見通しが良くなるかと思います。
また、表示時にダイアログのオプションを指定することができますが、
何も指定しないと、モーダレス、リサイズ可能、コンテンツが640pxで固定されたダイアログが表示されます。
ダイアログをリサイズしてもコンテンツが640pxで固定されているので、追従して広がることがありません。
もし、リサイズに合わせてコンテンツも追従するようにしたければ、
表示時に下記のようなオプションを付与します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onShowDialog()
{
    final Map&amp;lt;String, Object&amp;gt; options = new HashMap&amp;lt;&amp;gt;();
    options.put(&amp;quot;width&amp;quot;, 640);
    options.put(&amp;quot;contentWidth&amp;quot;, &amp;quot;100%&amp;quot;);
    RequestContext.getCurrentInstance().openDialog(&amp;quot;dialog.xhtml&amp;quot;, options, null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにすることで、ダイアログの初期表示の幅は640px、コンテンツの幅は100%となり、
コンテンツがリサイズに追従するようになります。&lt;/p&gt;

&lt;p&gt;さらにパラメータを渡すことも可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onShowDialog()
{
    final Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; params = new HashMap&amp;lt;&amp;gt;();
    params.put(&amp;quot;id&amp;quot;, Collections.singletonList(&amp;quot;123&amp;quot;));
    RequestContext.getCurrentInstance().openDialog(&amp;quot;dialog.xhtml&amp;quot;, null, params);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パラメータはiframeのsrc属性に付与され、&lt;code&gt;/contextPath/dialog.xhtml?id=123&lt;/code&gt;という値になります。&lt;/p&gt;

&lt;h2 id=&#34;ちょっとしたコツ&#34;&gt;ちょっとしたコツ&lt;/h2&gt;

&lt;p&gt;ここまではドキュメントを読めば大体の内容は記載されているのですが、
以下は実体験に伴う内容です。&lt;/p&gt;

&lt;p&gt;ダイアログは簡単に表示できますが、
コンポーネントの構成次第で最初の一回は表示され、2回目以降は表示されないという問題が発生します。
具体的には下記のような構成とした場合です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;p:panel rendered=”#{bean.showPanel}”&amp;gt;
    &amp;lt;p:commandButton value=&amp;quot;Show&amp;quot; actionListener=&amp;quot;#{bean.onShowDialog}&amp;quot;/&amp;gt;
&amp;lt;/p:panel&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;親コンポーネントにrendered属性が付与されている場合、
2回目以降のダイアログの表示が行われません。
バグの可能性もありますが、現状での回避策は下記のように、
rendered属性が付与された親コンポーネントの外に隠しボタンを用意し、
実際のボタンがクリックされた際に隠しボタンをクリックするようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;p:commandButton id=&amp;quot;hiddenButton&amp;quot; actionListener=”#{bean.onShowDialog}” 
                 style=&amp;quot;visibility: hidden;&amp;quot;/&amp;gt;
&amp;lt;p:panel rendered=&amp;quot;#{bean.showPanel}&amp;quot;&amp;gt;
    &amp;lt;p:commandButton value=&amp;quot;Show&amp;quot; oncomplate=&amp;quot;$(&#39;#hiddenButton&#39;).click()&amp;quot;/&amp;gt;
&amp;lt;/p:panel&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンポーネントの組み合わせによっては落とし穴もあるよ、ということでした。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.primefaces.org/showcase/ui/df/data.xhtml&#34;&gt;PrimeFaces ShowCace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HttpURLConnectionで嵌った話</title>
      <link>https://kokuzawa.github.io/blog/2016/12/15/httpurlconnection/</link>
      <pubDate>Thu, 15 Dec 2016 00:03:24 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/12/15/httpurlconnection/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2016/java&#34;&gt;Java Advent Calendar 2016&lt;/a&gt;の15日目です。&lt;br /&gt;
昨日は&lt;a href=&#34;http://qiita.com/enk&#34;&gt;enk&lt;/a&gt;さんの「&lt;a href=&#34;http://qiita.com/enk/items/240e56a00e104d7088d8&#34;&gt;JGiven で 100% Pure Java BDD（導入編）&lt;/a&gt;」でした。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;HttpURLConnectionには&lt;code&gt;getInputStream&lt;/code&gt;と&lt;code&gt;getErrorStream&lt;/code&gt;というサーバからのレスポンスを受け取るためのメソッドが用意されています。
この二つのメソッドのうち、&lt;code&gt;getErrorStream&lt;/code&gt;のJavadocを見ると下記のように記載されています。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;接続が失敗したが、それにもかかわらずサーバーから有用なデータを送信されてきた場合に、エラー・ストリームを返します。典型的な例としては、HTTPサーバーが404で応答し、それによって接続内でFileNotFoundExceptionがスローされたが、そのサーバーから対処策を含むHTMLヘルプ・ページが送信されてきた、といった場合です。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これを読むと少なくともステータスコードが404の場合にはエラーストリームが取得できそうな気がするのですが、
実際のところインプットストリームで返却するのかエラーストリームで返却するのか明確に仕様が決まっているわけではないらしく、
接続先のサーバの実装に依存し、取得できたりできなかったりします。&lt;/p&gt;

&lt;p&gt;インプットストリームで返却されたのかエラーストリームで返却されたのか、
事前に判定するための方法が用意されているわけでもないため、
実際には下記のようなコードでストリームを取得する必要がありそうです。
インプットストリームが取れない場合は&lt;code&gt;IOException&lt;/code&gt;が発生、
エラーストリームが取れない場合はnullが返却されます。&lt;/p&gt;

&lt;p&gt;エラーストリームが取れない場合にインプットストリームを取得:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;InputStream stream = connection.getErrorStream();
if (null = stream) {
    stream = connection.getInputStream();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インプットストリームが取れない場合にエラーストリームを取得:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;InputStream stream;
try {
    stream = connection.getInputStream();
}
catch (IOException e) {
    stream = connection.getErrorStream();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実際の問題&#34;&gt;実際の問題&lt;/h2&gt;

&lt;p&gt;JAX-RSクライアントライブラリのresteasy-client 3.0.10が持つクラス、
&lt;code&gt;org.jboss.resteasy.client.jaxrs.engines.URLConnectionEngine&lt;/code&gt;を利用した際、
サーバが4xxのステータスコードを返却するとNullPointerExceptionが発生します。
URLConnectionEngineの該当箇所のコードは下記のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected InputStream getInputStream()
{
    if (stream == null)
    {
        try
        {
            stream = (status &amp;lt; 300) ? 
                    connection.getInputStream() : connection.getErrorStream();
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
    }

    return stream;
}

@Override
protected void releaseConnection() throws IOException
{
    getInputStream().close();
    connection.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ステータスコードが300未満の場合はインプットストリーム、300以上の場合はエラーストリームを取得し、
その取得したストリームをクローズしようとしたところでNullPointerExceptionが発生する状況です。
このクライアントコードを書いた人は、ステータスコードが300以上の場合はエラーと判断したのだと思います。
ところが実際はステータスコードが4xxが返却されてもエラーストリームはnullになっていました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;結局、インプットストリームを返却するのかエラーストリームを返却するのか、
仕様として明確に決まっていないために、サーバの実装とクライアントの実装が一致せずに問題が発生しているのだと思います。
少なくともステータスコードで判断することはできないので、
最初にあげたように泥臭いコードでストリームを取得しなければならないのでしょう。
HttpURLConnectionクラスに判定メソッドが追加されると良いとは思うのですが、
Java8の段階ではそのようなメソッドは見当たらないです。&lt;/p&gt;

&lt;p&gt;ちなみにresteasy-clientはというと、3.0.15でこの問題は修正されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/resteasy/Resteasy/blob/master/resteasy-client/src/main/java/org/jboss/resteasy/client/jaxrs/engines/URLConnectionEngine.java&#34;&gt;https://github.com/resteasy/Resteasy/blob/master/resteasy-client/src/main/java/org/jboss/resteasy/client/jaxrs/engines/URLConnectionEngine.java&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>remoteCommand in Composite</title>
      <link>https://kokuzawa.github.io/blog/2016/12/14/remotecommand-in-composite/</link>
      <pubDate>Wed, 14 Dec 2016 01:28:24 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/12/14/remotecommand-in-composite/</guid>
      <description>&lt;p&gt;JSFにはcompositeというカスタムコンポーネントを作るための仕組みがあります。
PrimeFaces-6.0にはManagedBeanのメソッドを呼び出すためのremoteCommandというコンポーネントがあります。
この二つを使ってカスタムコンポーネントを作ったところ、ManagedBeanのメソッドが呼ばれないという問題が発生しました。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;まず、JSFのcomposite機能を使って下記のような二つのコンポーネントを作りました。&lt;/p&gt;

&lt;p&gt;sample1.xhtml:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;composite:implementation&amp;gt;
  &amp;lt;p:tree&amp;gt;
    &amp;lt;p:ajax event=&amp;quot;select&amp;quot; oncomplate=&amp;quot;afterSelected()&amp;quot;/&amp;gt;
  &amp;lt;/p:tree&amp;gt;
  &amp;lt;p:remoteCommand name=&amp;quot;afterSelected&amp;quot; actionListener=&amp;quot;#{bean.method1}&amp;quot;/&amp;gt;
&amp;lt;/composite:implementation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sample2.xhtml:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;composite:implementation&amp;gt;
  &amp;lt;p:tree&amp;gt;
    &amp;lt;p:ajax event=&amp;quot;select&amp;quot; oncomplate=&amp;quot;afterSelected()&amp;quot;/&amp;gt;
  &amp;lt;/p:tree&amp;gt;
  &amp;lt;p:remoteCommand name=&amp;quot;afterSelected&amp;quot; actionListener=&amp;quot;#{bean.method2}&amp;quot;/&amp;gt;
&amp;lt;/composite:implementation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてこれらを一つのXHTMLに組み込みます。&lt;/p&gt;

&lt;p&gt;main.xhtml:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;my:sample1/&amp;gt;
&amp;lt;my:sample2/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sample1側のツリーノードを選択した際に&lt;code&gt;bean.method1&lt;/code&gt;が呼ばれることを想定していたのですが、
呼ばれることなく画面がリフレッシュされました。それぞれのカスタムコンポーネント内の
remoteCommandのnameの値が重複していると、エラーが発生することなくメソッドが呼ばれないという現象が発生します。&lt;/p&gt;

&lt;p&gt;当たり前と言えば当たり前なのですが、
似たようなコンポーネントを作るとやらかしてしまいそうなので注意しないと。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FreeMarkerでinterpolation部分をそのまま出力</title>
      <link>https://kokuzawa.github.io/blog/2016/10/20/java-freemarker-noparse/</link>
      <pubDate>Thu, 20 Oct 2016 13:41:21 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/10/20/java-freemarker-noparse/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://freemarker.org/&#34;&gt;FreeMarker-2.3.23&lt;/a&gt;でinterpolation部分をそのまま出力したい。&lt;/p&gt;

&lt;p&gt;ただし、テンプレート文字列部分はユーザが自由に入力ができて、さらに、それがFreeMarkerのテンプレートだとは認識していない場合を想定。
つまり、ユーザが&lt;code&gt;${hello}&lt;/code&gt;と入力したら、出力結果は&lt;code&gt;${hello}&lt;/code&gt;となって欲しい。
調べてみると、下記のようにinterpolation部分を&lt;code&gt;${r&amp;quot;...&amp;quot;}&lt;/code&gt;で括ればそのまま出力されるみたい。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TEMPLATE:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${r&amp;quot;${hello}&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OUTPUT:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${hello}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということは、ユーザの入力した文字列からinterpolation部分を抽出して、&lt;code&gt;${r&amp;quot;...&amp;quot;}&lt;/code&gt;で括るように置換してあげればよさそうだけど、
ユーザが&lt;code&gt;${hello&lt;/code&gt;としか入力しない場合に置換できないし、interpolation部分だけでなく、
&lt;code&gt;&amp;lt;#if&amp;gt;&lt;/code&gt;などの制御タグもそのまま出力しなければならないので、この方法はあまり現実的ではなさそう。
で、FreeMarkerのマニュアルを眺めてみると、&lt;code&gt;noparse&lt;/code&gt;という項があってそれをみたら「あ、これだ！」となった。
下記のように書くとそのまま出力される。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TEMPLATE:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#noparse&amp;gt;
  &amp;lt;#if greet&amp;gt;
    ${hello}
  &amp;lt;/#if&amp;gt;
&amp;lt;/#noparse&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OUTPUT:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if greet&amp;gt;
  ${hello}
&amp;lt;/#if&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これならユーザが入力した部分を&lt;code&gt;&amp;lt;#noparse&amp;gt;&lt;/code&gt;で括ってしまえばいいだけなので簡単。&lt;/p&gt;

&lt;h2 id=&#34;参考サイト&#34;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/5207613/how-to-output-expression-in-freemarker-without-it-being-interpreted&#34;&gt;How to output ${expression} in Freemarker without it being interpreted?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://freemarker.org/docs/ref_directive_noparse.html&#34;&gt;FreeMarker.org#noparse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>java.sql.Timestamp の振る舞い</title>
      <link>https://kokuzawa.github.io/blog/2016/06/27/java-sql-timestamp/</link>
      <pubDate>Mon, 27 Jun 2016 23:41:21 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/06/27/java-sql-timestamp/</guid>
      <description>&lt;p&gt;Java6 と Java8 で振る舞いが変わっていたのでメモ。&lt;/p&gt;

&lt;p&gt;Java6 では下記コードがエラーにならず結果が出力されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(java.sql.Timestamp.valueOf(&amp;quot;2016-13-01&amp;quot;)); // 2017-01-01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ところが Java8 だと下記のエラーが発生します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalArgumentException: Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]
	at java.sql.Timestamp.valueOf(Timestamp.java:204)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん存在しない日付、例えば 2016-12-32 などを指定した場合にもエラーとなります。
Java6 から Java7 になる際に &lt;code&gt;java.sql.Timestamp&lt;/code&gt; に対してかなりの数のバグフィックスが行われたようで、
おそらくその修正のどこかで振る舞いが変わったのだと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IntelliJ IDEAからDocker上のWildFlyでデバッグする</title>
      <link>https://kokuzawa.github.io/blog/2016/02/28/intellij-ideakaradockershang-falsewildflydedebatugusuru/</link>
      <pubDate>Sun, 28 Feb 2016 01:56:31 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/02/28/intellij-ideakaradockershang-falsewildflydedebatugusuru/</guid>
      <description>

&lt;p&gt;IntelliJ IDEAからDocker上のWildFlyコンテナにアプリケーションをデプロイし、
デバッグモードで起動することでステップ実行ができる環境を作ることが今回の目的です。
Docker上にコンテナを起動できる環境はできている前提になります。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX 10.11.3&lt;/li&gt;
&lt;li&gt;Java: Java&amp;trade; SE Runtime Environment (build 1.8.0_60-b27)&lt;/li&gt;
&lt;li&gt;メモリ: 16GB&lt;/li&gt;
&lt;li&gt;Docker version 1.9.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;アプリの準備&#34;&gt;アプリの準備&lt;/h2&gt;

&lt;p&gt;どんなアプリでも良いのですが最終的な生成物はwarファイルにします。
今回はMavenプロジェクトで下記のようなフォルダ構成にします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-wildfly-example/
├── Dockerfile
├── container_settings.json
├── docker-wildfly-example.iml
├── pom.xml
└── src
    └── main
        ├── java
        │   └── org
        │       └── katsumi
        │           └── HelloBean.java
        └── webapp
            ├── WEB-INF
            │   └── web.xml
            └── index.xhtml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;肝心なDockerfileの内容は下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# WildFlyのイメージを取得
FROM jboss/wildfly:latest

# MAINTAINER
MAINTAINER Katsumi

# アプリケーションのデプロイ
COPY target/docker-wildfly-example.war /opt/jboss/wildfly/standalone/deployments/

# ポートの解放
EXPOSE 9999

# WildFlyの実行
CMD [&amp;quot;/opt/jboss/wildfly/bin/standalone.sh&amp;quot;, &amp;quot;-b&amp;quot;, &amp;quot;0.0.0.0&amp;quot;, &amp;quot;--debug&amp;quot;, &amp;quot;9999&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mvn package&lt;/code&gt;することで生成される&lt;code&gt;target/docker-wildfly-example.war&lt;/code&gt;ファイルを
コンテナ上の&lt;code&gt;/opt/jboss/wildfly/standalone/deployments/&lt;/code&gt;に配置することで
WildFly起動時に自動的にデプロイさせます。
また、デバッグ用のポートとして&lt;code&gt;9999&lt;/code&gt;を使用するため&lt;code&gt;EXPOSE&lt;/code&gt;に指定します。&lt;/p&gt;

&lt;p&gt;デバッグはリモートデバッグをすることになるので、
WildFly起動オプションに&lt;code&gt;--debug&lt;/code&gt;を付与して&lt;code&gt;9999&lt;/code&gt;ポートを指定します。&lt;/p&gt;

&lt;h2 id=&#34;実行環境の構築&#34;&gt;実行環境の構築&lt;/h2&gt;

&lt;p&gt;IntelliJ IDEAにDocker PluginがインストールされているとRun/Debug ConfigurationsにDocker Deploymentを追加することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_41.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Debugポートに9999を指定すると画面下部にワーニングが表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Warning: Debug port forwarding not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このワーニングの右側にFixボタンを表示されるのでこれをクリックすると
port設定をしたjsonファイルの保存先を聞かれるので任意の場所に保存します。
アプリケーションツリーにあるcontainer_settings.jsonがそれになります。
このファイルはContainerタブのJSON fileの項目に設定されます。&lt;/p&gt;

&lt;p&gt;やっていることはContainerタブのport bindingsで9999ポートを追加したのと同じことなのですが、
port bindingsに設定してもワーニングが消えません。
ワーニングは消えなくてもport bindingsの設定は有効になるので
ワーニングが気にならないようであればport bindingsに設定しても良いです。
ただし注意点としてjsonファイルとport bindingsの両方を指定するとport bindingsの方の設定が無視されるようです。
9999以外のポートをバインドする場合は注意する必要があります。&lt;/p&gt;

&lt;p&gt;これでデバッグ起動すればステップ実行ができるようになります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Flex カスタムヘッダでセキュリティエラー</title>
      <link>https://kokuzawa.github.io/blog/2016/02/12/apache-flex-kasutamuhetudadesekiyuriteiera/</link>
      <pubDate>Fri, 12 Feb 2016 23:53:41 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/02/12/apache-flex-kasutamuhetudadesekiyuriteiera/</guid>
      <description>&lt;p&gt;ちょっと前の話だけれども、
Apache Flex でHTTPリクエストを投げる際にカスタムヘッダを設定するとセキュリティエラーが発生するようになった。
詳細は下記。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://bugbase.adobe.com/index.cfm?event=bug&amp;amp;id=3759971&#34;&gt;https://bugbase.adobe.com/index.cfm?event=bug&amp;amp;id=3759971&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dockerで始めるVMを利用した開発</title>
      <link>https://kokuzawa.github.io/blog/2016/02/11/dockerdeshi-meruvmwoli-yong-sitakai-fa/</link>
      <pubDate>Thu, 11 Feb 2016 16:49:26 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2016/02/11/dockerdeshi-meruvmwoli-yong-sitakai-fa/</guid>
      <description>&lt;p&gt;結構前からDockerの事を聞いていてそれは仮想化技術だと認識していました。
なんで今まで触ってこなかったのかというと仮想化環境を作るにはそれなりの
マシンスペックが必要なのだろうと。つまり貧弱なマシンを使っている僕には関係ない。
自宅のMac Book Proが壊れて新しくなったり、
会社のPCのスペックが上がったりしたのでこれは触りどきかと思って今手をつけてみたわけです。
というわけでまさに触り始めなわけで開発まではたどり着いていません。タイトル嘘という方向で。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;最初に何をしたかというと、DockerToolBoxというやつをインストールしました。
Homebrewでも入れられるみたいですがどこかのサイトにHomebrewで入れるとなかなか最新にならないよという
至極まっとうな記載があったのでひとまず最新がいいなあと思い、インストールモジュールをダウンロードしてみました。&lt;/p&gt;

&lt;p&gt;これ、インストールすると目に見えて分かるのは３つのソフトがインストールされるということです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker Quickstart Terminal&lt;/li&gt;
&lt;li&gt;Kitematic (Beta)&lt;/li&gt;
&lt;li&gt;VirtualBox&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もしかしたら見えないところに他のソフトがインストールされているのかもしれませんが、
まだよくわかっていません。&lt;/p&gt;

&lt;p&gt;最初にDocker Quickstart Terminalを起動します。
これはOSXのターミナルが起動します。ここの中でCUIで操作するようです。
で、ちょっとハマったのは起動したターミナルに別タブを開いてそこでDockerの起動とかしようとしても
仮想マシンに接続できないようで理解するまで時間がかかりました。&lt;/p&gt;

&lt;p&gt;Docker Quickstart Terminalを起動すると仮想マシンがdefaultという名前で起動します。
これはVirtualBoxを起動するとわかります。
今のところVirtualBoxを使って何かするということはなさそうだという理解です。
このdefaultの仮想マシンですが、間違ってログアウトしてしまったらログインのIDとパスワードがわからなくて難儀しました。
どうやらCore Linuxというものを使っているらしくそれのデフォルトのIDとパスワードでログインできるようです。
こういうDockerとは直接関係ない機能を試してみたくなるところが僕の悪いところで、
Dockerそのものをまだちゃんと触れていない状態です。&lt;/p&gt;

&lt;p&gt;Kitematicはいろいろな人がアップしたDockerイメージが登録されているDockerHubというところへの
アクセスをGUI経由でできるソフトのようです。
Dockerイメージとかもうよくわからないので、この本を買ってちゃんと勉強することにしました。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=FFFFFF&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=moonwhaleblog-22&amp;o=9&amp;p=8&amp;l=as1&amp;m=amazon&amp;f=ifr&amp;ref=qf_sp_asin_til&amp;asins=479814102X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;まだ最初の方しか読んでいませんが、
ざっくり言うとMavenみたいな感じですね！多分。&lt;/p&gt;

&lt;p&gt;というわけでこれからしばらくはDockerを使ってみたいと思っています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JdbcRealm with WildFly 9.0.1.Final</title>
      <link>https://kokuzawa.github.io/blog/2015/12/25/jdbcrealm-with-wildfly-9-dot-0-1-dot-final/</link>
      <pubDate>Fri, 25 Dec 2015 20:50:08 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/12/25/jdbcrealm-with-wildfly-9-dot-0-1-dot-final/</guid>
      <description>

&lt;p&gt;以前、「&lt;a href=&#34;http://kokuzawa.github.io/blog/2014/08/23/wildflydejdbcrealmwoshe-ding-suru/&#34;&gt;WildFlyでJdbcRealm&lt;/a&gt;」 という記事を書きました。
これを現在インストールしている9.0.1.Final上で設定したところ、認証がうまく行われないことがわかりました。
大枠の変更はないのですが、DBに登録するパスワードのハッシュ文字列が当時とは異なる値である必要があったので、
忘れないようにメモしておきます。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;差分&#34;&gt;差分&lt;/h2&gt;

&lt;p&gt;WildFly 8.0.0.Finalの時の設定:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;security-domain name=&amp;quot;app&amp;quot; cache-type=&amp;quot;default&amp;quot;&amp;gt;
    &amp;lt;authentication&amp;gt;
        &amp;lt;login-module name=&amp;quot;app_auth&amp;quot; code=&amp;quot;Database&amp;quot; flag=&amp;quot;required&amp;quot;&amp;gt;
            &amp;lt;module-option name=&amp;quot;dsJndiName&amp;quot; value=&amp;quot;java:jboss/datasources/ExampleDS&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;principalsQuery&amp;quot; value=&amp;quot;SELECT PASSWORD FROM ACCOUNTS WHERE EMAIL = ?&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;rolesQuery&amp;quot; value=&amp;quot;SELECT r.ROLENAME, &#39;Roles&#39; FROM ROLES r, ACCOUNTS a WHERE r.ACCOUNTID = a.ACCOUNTID AND a.EMAIL = ?&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;hashAlgorithm&amp;quot; value=&amp;quot;SHA-256&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;hashEncoding&amp;quot; value=&amp;quot;HEX&amp;quot;/&amp;gt;
        &amp;lt;/login-module&amp;gt;
    &amp;lt;/authentication&amp;gt;
&amp;lt;/security-domain&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WildFly 9.0.1.Finalの設定:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;security-domain name=&amp;quot;app&amp;quot; cache-type=&amp;quot;default&amp;quot;&amp;gt;
    &amp;lt;authentication&amp;gt;
        &amp;lt;login-module name=&amp;quot;app_auth&amp;quot; code=&amp;quot;Database&amp;quot; flag=&amp;quot;required&amp;quot;&amp;gt;
            &amp;lt;module-option name=&amp;quot;dsJndiName&amp;quot; value=&amp;quot;java:jboss/datasources/ExampleDS&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;principalsQuery&amp;quot; value=&amp;quot;SELECT PASSWORD FROM ACCOUNTS WHERE EMAIL = ?&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;rolesQuery&amp;quot; value=&amp;quot;SELECT r.ROLENAME, &#39;Roles&#39; FROM ROLES r, ACCOUNTS a WHERE r.ACCOUNTID = a.ACCOUNTID AND a.EMAIL = ?&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;hashAlgorithm&amp;quot; value=&amp;quot;SHA-256&amp;quot;/&amp;gt;
            &amp;lt;module-option name=&amp;quot;hashEncoding&amp;quot; value=&amp;quot;base64&amp;quot;/&amp;gt;
        &amp;lt;/login-module&amp;gt;
    &amp;lt;/authentication&amp;gt;
&amp;lt;/security-domain&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;違いは module-option の hashEncoding の値。
8.0.0.Finalの時は&lt;code&gt;HEX&lt;/code&gt;であり、9.0.1.Finalでは&lt;code&gt;base64&lt;/code&gt;にしています。
これはパスワードのハッシュエンコーディングの形式を指定している部分なのですが、
9.0.1.FinalではHEXを認識していない模様。
なので、DBに登録するパスワードのハッシュ文字列も設定に合わせて&lt;code&gt;HEX&lt;/code&gt;から&lt;code&gt;base64&lt;/code&gt;に変更します。&lt;/p&gt;

&lt;h2 id=&#34;パスワードのハッシュ文字列生成方法&#34;&gt;パスワードのハッシュ文字列生成方法&lt;/h2&gt;

&lt;p&gt;WildFlyには&lt;code&gt;base64&lt;/code&gt;のハッシュ文字列を生成するモジュールが入っているようです。
以下のコマンドで指定文字列のBase64ハッシュ値を取得することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -cp $JBOSS_HOME/modules/system/layers/base/org/picketbox/main/picketbox-4.9.2.Final.jar org.jboss.security.Base64Encoder [任意文字列] SHA-256
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考サイト&#34;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.eisele.net/2015/01/jdbc-realm-wildfly820-primefaces51.html&#34;&gt;JDBC Realm and Form Based Authentication with WildFly 8.2.0.Final, Primefaces 5.1 and MySQL 5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Server Sent Events</title>
      <link>https://kokuzawa.github.io/blog/2015/12/20/server-sent-events/</link>
      <pubDate>Sun, 20 Dec 2015 10:32:29 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/12/20/server-sent-events/</guid>
      <description>

&lt;p&gt;これは &lt;a href=&#34;http://qiita.com/advent-calendar/2015/javaee&#34;&gt;JavaEE Advent Calendar 2015&lt;/a&gt; の20日目の記事です。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/yumix_h&#34;&gt;@yumix_h&lt;/a&gt;さんの「&lt;a href=&#34;http://yumix.hatenablog.jp/entry/2015/12/19/205954&#34;&gt;「帰ってきたGlassFish Users Group Japan勉強会」の未発表資料&lt;/a&gt;」でした。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/emaggame&#34;&gt;@emaggame&lt;/a&gt;さんです。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;server-sent-eventsとは&#34;&gt;Server Sent Eventsとは&lt;/h2&gt;

&lt;p&gt;Server Sent Events (SSE) はサーバから送られたイベントという意味の通り、push型のデータ通信を行うことができます。
これはHTML5で追加された新機能です。
同じくpush型のデータ通信を行う方法としてWebsocketがありますが、WebsocketがHTTPとは別のプロトコルで通信をするのに対し、
SSEではHTTPプロトコルを利用します。そのため、既存のHTTPを利用した通信との互換性が高いというメリットがある反面、
Websocketのような双方向の通信を行うことはできません。
HTTPプロトコルでpush通信を実現するため、SSEではサーバからのレスポンスを受けても接続を終了せずに継続させます。
こうすることで、サーバ側からのデータを継続して受信することを実現します。
このようにSSEはHTTPプロトコルで接続を行うのですが、クライアントがSSEだと認識できるデータを送ってもらう必要があります。
そこで、サーバはMIMEタイプに&lt;code&gt;text/event-stream&lt;/code&gt;を設定する必要があります。&lt;/p&gt;

&lt;p&gt;JavaEE8にSSEのサポートが入るようですが、一足先にJAX-RSのRIであるJerseyでこの機能を試すことができます。&lt;/p&gt;

&lt;h2 id=&#34;server-sent-eventsを試す&#34;&gt;Server Sent Eventsを試す&lt;/h2&gt;

&lt;p&gt;今回実行した環境は下記の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX 10.11.1&lt;/li&gt;
&lt;li&gt;Java: Java&amp;trade; SE Runtime Environment (build 1.8.0_60-b27)&lt;/li&gt;
&lt;li&gt;APサーバ: GlasshFish-4.1.1&lt;/li&gt;
&lt;li&gt;ブラウザ: Safari-9.0.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際のコードはGithubにあるので、
コードを見れば分かる方は以降の実装の説明を読むより、
そちらを見ていただいた方が早いかと思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kokuzawa/sandbox/tree/master/sse-example&#34;&gt;sandbox/sse-example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装の説明&#34;&gt;実装の説明&lt;/h2&gt;

&lt;p&gt;Mavenを利用しているので、最初に下記のDependencyを追加します。
2015/12/10時点のMaven Centralの最新版は2.22.1のようです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jersey-media-sse&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.22.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サーバ側のリソースはMIMEタイプに&lt;code&gt;text/event-stream&lt;/code&gt;を設定する他に、
&lt;code&gt;org.glassfish.jersey.media.sse.EventOutput&lt;/code&gt;を返却する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GET
@Produces(SseFeature.SERVER_SENT_EVENTS)
public EventOutput getServerSentEvents()
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;EventOutput&lt;/code&gt;を返却するだけだと、クライアントとの接続が確立しているだけの状態なので、
実際にクライアントに送信するデータを書き込む必要があります。
書き込みは&lt;code&gt;EventOutput#write(OutboundEvent)&lt;/code&gt;で行います。
単純には下記のような実装になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final EventOutput eventOutput = new EventOutput();
final OutboundEvent.Builder builder = new OutboundEvent.Builder();
builder.name(&amp;quot;message-to-client&amp;quot;);
builder.data(String.class, &amp;quot;Hello world !&amp;quot;);
eventOutput.write(builder.build());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;builder.name(...)&lt;/code&gt;で指定している文字列はクライアント側でイベントのマッピングをするために利用します。&lt;/p&gt;

&lt;p&gt;今回クライアントはJavascriptにします。
JavascriptでSSEを利用するには&lt;code&gt;EventSource&lt;/code&gt;クラスを利用します。
&lt;code&gt;EventSource&lt;/code&gt;を利用した実装は下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var eventList = document.getElementById(&amp;quot;eventList&amp;quot;);
var eventSource = new EventSource(&amp;quot;http://localhost:8080/sse-example/api/sse/events&amp;quot;);
eventSource.addEventListener(&amp;quot;message-to-client&amp;quot;, function (e) {
    var newElement = document.createElement(&amp;quot;li&amp;quot;);
    newElement.innerHTML = &amp;quot;message: &amp;quot; + e.data;
    eventList.appendChild(newElement);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EventSourceコンストラクタの引数でAPIエンドポイントを指定します。
addEventListenerでサーバからのイベントをハンドリングします。
この時、リスナーに設定するイベント名として、サーバ側コードで指定したイベント名を指定します。
この例では&amp;rdquo;message-to-client&amp;rdquo;です。&lt;/p&gt;

&lt;p&gt;さて、実際のコードの説明です。&lt;br /&gt;
ユースケースとして複数のユーザがそれぞれブラウザの画面を表示している状態で、
データが登録されると、開いている画面に登録された旨を伝えるメッセージを表示することを考えます。
まず必要なのは接続を確立するために&lt;code&gt;EventOutput&lt;/code&gt;を返却するサービスです。
&lt;code&gt;EventOutput&lt;/code&gt;はクライアントごとにインスタンスが必要なので、
接続が確立した&lt;code&gt;EventOutput&lt;/code&gt;を格納するためのリストも合わせて定義します。
これらを踏まえて下記のコードを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private List&amp;lt;EventOutput&amp;gt; eventOutputs = new ArrayList&amp;lt;&amp;gt;();

@GET
@Path(&amp;quot;events&amp;quot;)
@Produces(SseFeature.SERVER_SENT_EVENTS)
public EventOutput getServerSentEvents()
{
    final EventOutput eventOutput = new EventOutput();
    eventOutputs.add(eventOutput);
    return eventOutput;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に登録をするためのサービスを作ります。が、実際に何かを登録するのは実装が面倒なので、
サービスが呼ばれたら各クライアントにメッセージをpushするだけにします。
こんな感じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PUT
@Path(&amp;quot;put&amp;quot;)
public void putData() throws IOException
{
    for (EventOutput eventOutput : eventOutputs) {
        final OutboundEvent.Builder builder = new OutboundEvent.Builder();
        builder.name(&amp;quot;message-to-client&amp;quot;);
        builder.data(String.class, &amp;quot;登録された！&amp;quot;);
        eventOutput.write(builder.build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでサービス側は実装完了です。
Javascriptクライアントを実装する前に正しく動くかcurlコマンドで確認してみます。
接続確立のサービスを下記のように呼び出します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/sse-example/api/sse/events
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロンプトが待ち状態になりました。接続されたままになったのでうまくいったようです！
別のプロンプトから次のコマンドを実行して最初のプロンプトに通知されるか確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X PUT http://localhost:8080/sse-example/api/sse/put
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初のプロンプトの方に以下のメッセージが表示されました。こちらもうまくいったようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event: message-to-client
data: 登録された！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サービス側が正常に動作することが確認できたので、
次にJavascriptクライアントを作ります。
HTMLを含めた全コードは下記のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;SSE Example&amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
        function startup() {
            var eventList = document.getElementById(&amp;quot;eventList&amp;quot;);
            var eventSource = new EventSource(&amp;quot;http://localhost:8080/sse-example/api/sse/events&amp;quot;);
            eventSource.addEventListener(&amp;quot;message-to-client&amp;quot;, function (e) {
                var newElement = document.createElement(&amp;quot;li&amp;quot;);
                newElement.innerHTML = &amp;quot;message: &amp;quot; + e.data;
                eventList.appendChild(newElement);
            });
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&amp;quot;startup()&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;イベント表示:&amp;lt;/h1&amp;gt;
    &amp;lt;ul id=&amp;quot;eventList&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;このようにSSEの実装は比較的簡単に行うことがでます。
ただ最初にも書いたようにSSEは一方向通信なので、push通信だけでなく双方向通信を行いたい場合は
Websocketを利用することになります。
利用シーンとしてはWebsocketの方が多くなりそうですが、
既存のアプリにpush通知機能を実装するという観点からであれば、
HTTPプロトコルで動作するSSEを利用した方が良いケースがあるかもしれないですね。&lt;/p&gt;

&lt;h2 id=&#34;参考にしたサイト&#34;&gt;参考にしたサイト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jersey.java.net/documentation/latest/sse.html&#34;&gt;Chapter 15. Server-Sent Events (SSE) Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JavaFXのUIをJUnit形式でテストする</title>
      <link>https://kokuzawa.github.io/blog/2015/12/10/testfx/</link>
      <pubDate>Thu, 10 Dec 2015 10:10:10 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/12/10/testfx/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2015/java&#34;&gt;Java Advent Calendar 2015&lt;/a&gt;と
&lt;a href=&#34;http://qiita.com/advent-calendar/2015/javafx&#34;&gt;JavaFX Advent Calendar 2015&lt;/a&gt;の10日目の記事です。&lt;/p&gt;

&lt;p&gt;昨日は下記のお二人でした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java Advent Calendarは&lt;a href=&#34;https://twitter.com/namihira_k&#34;&gt;@namihira_k&lt;/a&gt;さんの
「&lt;a href=&#34;http://namihira.hatenablog.com/entry/20151209/1449667895&#34;&gt;パフォーマンスを意識したJavaコーディング&lt;/a&gt;」&lt;/li&gt;
&lt;li&gt;JavaFX Advent Calendarは&lt;a href=&#34;https://twitter.com/skrb&#34;&gt;@skrb&lt;/a&gt;さんの
「&lt;a href=&#34;http://skrb.hatenablog.com/entry/2015/12/09/212241&#34;&gt;Interpolator で補間&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;明日は下記のお二人です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java Advent Calendarは&lt;a href=&#34;https://twitter.com/bitter_fox&#34;&gt;@bitter_fox&lt;/a&gt;さん&lt;/li&gt;
&lt;li&gt;JavaFX Advent Calendarは&lt;a href=&#34;https://twitter.com/y_q1m&#34;&gt;@y_q1m&lt;/a&gt;さん&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;testfxを知る&#34;&gt;TestFXを知る&lt;/h2&gt;

&lt;p&gt;先月ダウンロードしたJava Magazine vol23に面白い記事が載っていました。
テストについて特集された中の、TestFXによるJavaFXのテストについての記事です。
TestFXはJavaFXのユーザ・インターフェースをJUnitベースでテストするためのAPIということで、
JUnitで書いたロジック通りにユーザ・インターフェースのテストが実施されます。
単純にロジックをなぞるだけではなく、実際にユーザ・インターフェースを操作した結果を判定してくれるようです。
これは、実際にテストを実行した際に、JavaFXのアプリ上でマウスカーソルが自動的に動いてボタンをクリックしたりすることからもわかります。&lt;/p&gt;

&lt;p&gt;普段のプロジェクトでは、残念ながらJavaFXではなくFlexを使っているのですが、
ユーザ・インターフェース周りのテストの仕組みはあってもなかなか思ったようなテストができていないのが現実です。
TestFXはJUnitの延長上でテストができそうなので期待できそうです。&lt;/p&gt;

&lt;p&gt;内容を説明する前に、実際に実行した際の動画を記録しました。
動画だと自動で動いているのかわからないと思いますが、
テスト起動後には何も操作をしていません。&lt;/p&gt;

&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/JdgX6ywJ4GY&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;アプリの説明&#34;&gt;アプリの説明&lt;/h2&gt;

&lt;p&gt;テストに使ったアプリは、ラベルとボタンのあるシンプルなものです。
ボタンをクリックすることで、ラベルに「Hello World!」と表示します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_40.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;実際のコードは下記にあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kokuzawa/javafx-test&#34;&gt;https://github.com/kokuzawa/javafx-test&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;testfxを設定&#34;&gt;TestFXを設定&lt;/h2&gt;

&lt;p&gt;Mavenプロジェクトでは下記のDependencyを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.loadui&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;testFx&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1.2&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;テストを書く&#34;&gt;テストを書く&lt;/h2&gt;

&lt;p&gt;対象のテストクラスは、TestFXを使うために&lt;code&gt;org.loadui.testfx.GuiTest&lt;/code&gt;クラスを継承します。
&lt;code&gt;org.loadui.testfx.GuiTest&lt;/code&gt;クラスは&lt;code&gt;getRootNode()&lt;/code&gt;メソッドを持ち、そのメソッドでテストしたい画面のFXMLをロードします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi;

import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Parent;
import org.junit.Test;
import org.loadui.testfx.GuiTest;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import static org.junit.Assert.assertThat;
import static org.loadui.testfx.controls.Commons.hasText;

public class IndexControllerTest extends GuiTest
{
    @Override
    protected Parent getRootNode()
    {
        try {
            return FXMLLoader.load(getClass().getResource(&amp;quot;index.fxml&amp;quot;));
        }
        catch (IOException e) {
            Logger.getLogger(IndexControllerTest.class.getName()).log(Level.SEVERE, &amp;quot;&amp;quot;, e);
            return null;
        }
    }

    @Test
    public void testSay()
    {
        final Node node = find(&amp;quot;#button&amp;quot;);
        click(node);
        assertThat(&amp;quot;#greeting&amp;quot;, hasText(&amp;quot;Hello World!&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストメソッドは普通にJUnitの形式です。
内容ですが、まず&lt;code&gt;find(&amp;quot;#button&amp;quot;)&lt;/code&gt;でfx:idがbuttonのコントロールを見つけます。
見つけたボタンコントロールを&lt;code&gt;click&lt;/code&gt;メソッドを利用して実際にクリックします。
ラベルに「Hello World!」が設定されたことを&lt;code&gt;Assert.assertThat&lt;/code&gt;で検証します。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;TestFXはJUnitベースなので抵抗なくテストを実装することができました。
ただ、連続で何度か実行しているとエラーになることがありました。
原因を調べているのですが、まだちょっとわからない状態です。
とは言っても、エラーになるのは稀で、基本的は正常に動作します。&lt;/p&gt;

&lt;p&gt;テストコードの導入はプロジェクトの最初の頃に決めておかないと、プロダクトコードがテストしにくい形で作られてしまうことが多々あります。
特にクライアント側のコードはその傾向が強いと思いますので、もしこれからJavaFXのプロジェクトを始める際のであれば、
TestFXの導入を検討してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;今回この記事を書くきっかけになった、Java Magazineは下記からダウンロードすることができます。
&lt;a href=&#34;http://www.oracle.com/technetwork/jp/articles/java/overview/index.html?elq_mid=33486&amp;amp;sh=1612166126426151606143&amp;amp;cmid=JPFM15040092MPP006C005&#34;&gt;http://www.oracle.com/technetwork/jp/articles/java/overview/index.html?elq_mid=33486&amp;amp;sh=1612166126426151606143&amp;amp;cmid=JPFM15040092MPP006C005&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WildFly SwarmでEJBを試す</title>
      <link>https://kokuzawa.github.io/blog/2015/11/22/wildfly-swarmdeejbwoshi-su/</link>
      <pubDate>Sun, 22 Nov 2015 22:33:53 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/11/22/wildfly-swarmdeejbwoshi-su/</guid>
      <description>

&lt;p&gt;WildFly Swarmを試すのも今日で３回目です。
だんだんと実装方法に慣れてきました。
この辺で当初の目的であったWildFly SwarmでEJBを使ってみたいと思います。
EJBが使えないのならSpring Bootで全然構わないわけで、
EJBが使えるかどうかはとても大事なところです。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;ejbを組み込む&#34;&gt;EJBを組み込む&lt;/h2&gt;

&lt;p&gt;EJBのモジュールを組み込みます。
よくよく考えてみると、EJBだけでは動きを確認するのが大変なので、
リクエストの受け口だけはJAXRSで作ります。
なので、JAXRSのモジュールも合わせて組み込みます。&lt;/p&gt;

&lt;p&gt;また、JAXRSのリソースから&lt;code&gt;@Inject&lt;/code&gt;でEJBをDIするにはWeldも必要です。
そのため、JAXRSのモジュールはwildfly-swarm-jaxrs-weldを利用することにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;wildfly-swarm-jaxrs-weld&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0.Alpha5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;wildfly-swarm-ejb&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0.Alpha5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ejbを使ったアプリケーションを作る&#34;&gt;EJBを使ったアプリケーションを作る&lt;/h2&gt;

&lt;p&gt;まずはEJBです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi.ejb;

import javax.ejb.Stateless;

@Stateless
public class HelloEjb
{
    public String say()
    {
        return &amp;quot;Hello!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EJBを呼び出すRESTリソースです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi.ejb;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path(&amp;quot;/hello&amp;quot;)
public class HelloResource
{
    @Inject
    private HelloEjb helloEjb;

    @GET
    public String hello()
    {
        return helloEjb.say();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi.ejb;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath(&amp;quot;/rest&amp;quot;)
public class MyApplication extends Application
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実行する&#34;&gt;実行する&lt;/h2&gt;

&lt;p&gt;今回はMainクラスを作るのではなく、Warファイルを生成し、
それを実行する形にします。
まずpom.xmlのpackagingをwarにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにwarファイルを生成するので下記のプラグインをpom.xmlに追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;plugins&amp;gt;
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;failOnMissingWebXml&amp;gt;false&amp;lt;/failOnMissingWebXml&amp;gt;
        &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;wildfly-swarm-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${version.wildfly-swarm}&amp;lt;/version&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;準備ができたので下記のコマンドで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn wildfly-swarm:run
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;WildFLy SwarmでEJBも問題なく呼び出せることがわかりました。
あとはJPAを使うことができれば、システム開発で使う一通りの機能が使えること確認できそうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WildFly SwarmでJSFを試す</title>
      <link>https://kokuzawa.github.io/blog/2015/11/16/wildfly-swarmdejsfwoshi-su/</link>
      <pubDate>Mon, 16 Nov 2015 22:58:09 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/11/16/wildfly-swarmdejsfwoshi-su/</guid>
      <description>

&lt;p&gt;昨日はWildFly SwarmでJAXRSを触ったので、今日はJSFを試してみることにします。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;jsfを組み込む&#34;&gt;JSFを組み込む&lt;/h2&gt;

&lt;p&gt;仕様毎にモジュールが分かれているので、JAXRSの時と同じく、今回はJSFのモジュールを取り込みます。
あと、ここで特に記載はしませんがwildfly-swarm-pluginももちろん設定する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;wildfly-swarm-jsf&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0.Alpha5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jsfアプリケーションを作る&#34;&gt;JSFアプリケーションを作る&lt;/h2&gt;

&lt;p&gt;JSFアプリケーションを作ると言ってもJavaのコードを書くわけではなく、
動くことが分かれば良いのでXHTMLファイルだけを作るだけにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;quot; 
        &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;
      xmlns:h=&amp;quot;http://xmlns.jcp.org/jsf/html&amp;quot;&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;h:outputText value=&amp;quot;Hello JSF!&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あと、JAXRSの時と違い、web.xmlを作る必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&amp;quot;
         version=&amp;quot;3.1&amp;quot;&amp;gt;

    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;javax.faces.PROJECT_STAGE&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;Development&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;javax.faces.webapp.FacesServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;Faces Servlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.xhtml&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;動かす&#34;&gt;動かす&lt;/h2&gt;

&lt;p&gt;JAXRSの時と同じく、mainメソッドから実行するため、mainメソッドを持つクラスを作ります。
今回はJAXRSArchiveではなく、WARArchieをデプロイします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi.jsf;

import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.ClassLoaderAsset;
import org.wildfly.swarm.container.Container;
import org.wildfly.swarm.undertow.WARArchive;

public class Main
{
    public static void main(String... args) throws Exception
    {
        final Container container = new Container();

        final WARArchive warArchive = ShrinkWrap.create(WARArchive.class);
        warArchive.addAsWebResource(
                new ClassLoaderAsset(&amp;quot;index.xhtml&amp;quot;, Main.class.getClassLoader()), &amp;quot;index.xhtml&amp;quot;);
        warArchive.addAsWebInfResource(
                new ClassLoaderAsset(&amp;quot;WEB-INF/web.xml&amp;quot;, Main.class.getClassLoader()), &amp;quot;web.xml&amp;quot;);
        warArchive.addAllDependencies();

        container.start().deploy(warArchive);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行方法は下記の３通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IDEでmainメソッドを実行&lt;/li&gt;
&lt;li&gt;mvn wildfly-swarm:run&lt;/li&gt;
&lt;li&gt;jar -jar target/projectname-swarm.jar&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これで実際に実行しようとすると下記のエラーが発生します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;at org.wildfly.extension.undertow.deployment.UndertowDeploymentService$1.run(UndertowDeploymentService.java:85)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
	at org.jboss.threads.JBossThread.run(JBossThread.java:320)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;wildfly-swarm-weld&lt;/code&gt;を取り込んでいないためなので、
下記の記述をpom.xmlに追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;wildfly-swarm-weld&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ドキュメントを読んだだけではWeldが必要には見えなくて、
結局サンプルコードと何遍も見比べる必要がありましたが、
動いてしまえば、後は非常に快適です。
次はEJBが使えるのか試してみないと。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WildFly SwarmでJAXRSを試す</title>
      <link>https://kokuzawa.github.io/blog/2015/11/14/wildfly-swarmdejaxrswoshi-su/</link>
      <pubDate>Sat, 14 Nov 2015 16:08:44 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/11/14/wildfly-swarmdejaxrswoshi-su/</guid>
      <description>

&lt;p&gt;WildFly Swarmのサイトにも記載されていますが、WildFly Swarmは自己完結型のJava microservicesを作成するのに役立つプロジェクトとのこと。
この分野だとSpring Bootの方が運用実績もあり、先行しているようですが、
将来的にはEJBも使いたいのでWildFly Swarmの方を使ってみます。
WildFly Swarmは一つのモジュールというわけではなく、JavaEEの仕様毎に複数のモジュールに分かれていて、
自分の必要なモジュールを取り込んで利用する形になるようです。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;jaxrsを組み込む&#34;&gt;JAXRSを組み込む&lt;/h2&gt;

&lt;p&gt;今回は数あるモジュールの中からJAXRSのモジュールを利用してみます。
2015年11月時点での最新バージョンは1.0.0.Alpha5です。
pom.xmlに下記のdependencyを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;wildfly-swarm-jaxrs&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0.Alpha5&amp;lt;/version&amp;gt;
&amp;lt;dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを依存グラフで見てみると&amp;hellip;依存がすごいです（笑）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_39.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;JAXRSのモジュールを組み込んだだけではビルドしても実行できないので、
下記のpluginもpom.xmlに追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;wildfly-swarm-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0.Alpha5&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;package&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jaxrsアプリケーションを作る&#34;&gt;JAXRSアプリケーションを作る&lt;/h2&gt;

&lt;p&gt;WildFly Swarmの設定が一通り終わったので、次はJAXRSアプリケーションを作ります。
特別なことはなく、普通のJAXRSアプリケーションです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath(&amp;quot;/rest&amp;quot;)
public class MyApplication extends Application
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path(&amp;quot;/hello&amp;quot;)
public class HelloResource
{
    @GET
    public String hello()
    {
        return &amp;quot;Hello World!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;どうやってうごかすの&#34;&gt;どうやってうごかすの？&lt;/h2&gt;

&lt;p&gt;JAXRSアプリケーションも作ったけれどどうやって動かすのか？&lt;br /&gt;
WildFly Swarmでは通常のJavaアプリケーションのようにmainメソッドから動かします。
そのため、mainメソッドを持つクラスを新たに作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi;

import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.wildfly.swarm.container.Container;
import org.wildfly.swarm.jaxrs.JAXRSArchive;

public class Main
{
    public static void main(String... args) throws Exception
    {
        // コンテナの生成
        // Archiveを生成する前にインスタンス化しておかないと実行時にエラーが発生
        final Container container = new Container();

        // ShrinkWrapで仮想アーカイブを作成
        final JAXRSArchive archive = ShrinkWrap.create(JAXRSArchive.class);
        archive.addClass(MyApplication.class);
        archive.addClass(HelloResource.class);
        archive.addAllDependencies();

        container.start().deploy(archive);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mainメソッド内では、ShrinkWrapを利用して生成した仮想アーカイブを起動したコンテナにデプロイします。
コード中のコメントにも書きましたが、アーカイブを作る前にコンテナをインスタンス化しておかないと、
実行時にエラーになります。これで半日悩んだ..orz&lt;/p&gt;

&lt;p&gt;で、ここで作ったMainクラスをswarm-pluginに教える必要があります。
設定を追加したwildfly-swarm-pluginが下記になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.wildfly.swarm&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;wildfly-swarm-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0.Alpha5&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;mainClass&amp;gt;org.katsumi.Main&amp;lt;/mainClass&amp;gt;
    &amp;lt;/configuration&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;package&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mavenでビルド後に下記の方法で実行することができます。&lt;/p&gt;

&lt;h3 id=&#34;ideの場合&#34;&gt;IDEの場合&lt;/h3&gt;

&lt;p&gt;Mainクラスを実行&lt;/p&gt;

&lt;h3 id=&#34;mavenを利用する場合&#34;&gt;Mavenを利用する場合&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mvn wildfly-swarm:run
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;jarファイルを実行する場合&#34;&gt;Jarファイルを実行する場合&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;jar -jar target/projectname-swarm.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;今回のアプリですが、IntelliJ IDEA 15で作っています。
インストールしたままの環境でMavenビルドをしたのですが、下記エラーが発生してビルドができない状態でした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.lang.NoClassDefFoundError: org/eclipse/aether/RepositorySystemSession
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因はMavenのバージョンが古いためで、IntellijにデフォルトでバンドルされているMavenのバージョンは3.0.5であり、
このバージョンではエラーが発生するので、別途バージョン3.2.5をインストールしてそれを参照するようにしました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAX-RSでStreamを扱う</title>
      <link>https://kokuzawa.github.io/blog/2015/10/15/stream-in-jaxrs/</link>
      <pubDate>Thu, 15 Oct 2015 02:44:04 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/10/15/stream-in-jaxrs/</guid>
      <description>&lt;p&gt;JAX-RSでExcelファイルをダウンロードする際にストリームを直接触る必要があって、
どうすればストリームにアクセスできるかちょっと調べてみました。
Excelファイルの生成にはApache POIを使っています。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;Apache POIでExcelファイルを生成する場合、下記のようなコードを書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Workbook wb = new HSSFWorkbook();
final FileOutputStream fileOut = new FileOutputStream(&amp;quot;workbook.xls&amp;quot;);
wb.write(fileOut);
fileOut.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成したファイルをファイルとして保存せずにServletでダウンロードしようとした場合、
そのコードは下記のように&lt;code&gt;HttpServletResponse#getOutputStream()&lt;/code&gt;でアウトプットストリームを取得し、
レスポンスボディに対してストリーミング処理をすることになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Workbook wb = new HSSFWorkbook();
final FileOutputStream fileOut = new FileOutputStream(response.getOutputStream());
wb.write(fileOut);
fileOut.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここからが本題です。&lt;br /&gt;
JAX-RSでファイルをダウンロードするにはどうしたら良いのか。&lt;br /&gt;
通常のファイルの場合は下記のようなコードを書くことで実現できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final File file = new File(&amp;quot;workbook.xls&amp;quot;);
return Response.ok(file).build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Servletでのダウンロードのように、
レスポンスボディに対してストリーミング処理をする場合は&lt;code&gt;javax.ws.rs.core.StreamingOutput&lt;/code&gt;クラスを利用します。
そのコードは下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Workbook wb = new HSSFWorkbook();
final StreamingOutput so = out -&amp;gt; wb.write(out);
return Response.ok(stream).build();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Googleのテキスト読み上げAPIを組み込む（その２）</title>
      <link>https://kokuzawa.github.io/blog/2015/05/07/continue-translate-google/</link>
      <pubDate>Thu, 07 May 2015 15:34:12 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/05/07/continue-translate-google/</guid>
      <description>&lt;p&gt;先日書いたコードがiOSのSafariで上手く動きませんでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kokuzawa.github.io/blog/2015/05/03/translate-google/&#34;&gt;Googleのテキスト読み上げAPIを組み込む&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;子供向けなのでiPhoneまたはiPadで音声が再生されないと困ります。
いろいろ調べたけれど、JavaScriptから呼び出す方法がわからないので
勝手知ったるJavaの世界に取り込んでiOSのSafariでも音声が再生されるようにしました。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;下記がそのコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Path(&amp;quot;/tts&amp;quot;)
public class TTSResource
{
    @GET
    @Produces(&amp;quot;audio/mpeg&amp;quot;)
    public Response textToSpeech(@QueryParam(&amp;quot;text&amp;quot;) String text) throws IOException
    {
        final URL url = new URL(&amp;quot;http://translate.google.com/translate_tts?tl=en&amp;amp;q=&amp;quot; + text);
        final URLConnection connection = url.openConnection();
        connection.setRequestProperty(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla&amp;quot;);
        return Response.ok(connection.getInputStream()).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JAX-RSでGoogle Translateの結果をそのままレスポンスとして返すようにしています。
User-Agentを指定していないと上手く動きません。
ここで気がついたのですがUser-Agentで振る舞いが変わるようなので、
もしかしたらiOSからのアクセスの場合にもUser-Agentを偽装できれば音声が再生されるのかもしれないです。&lt;/p&gt;

&lt;p&gt;先日の記事にも書きましたがクライアント側（javaScript）は下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h:outputScript&amp;gt;
function play() {
    var voice = new Audio();
    voice.src = &amp;quot;${request.contextPath}/rest/tts?text=one&amp;quot;;
    voice.play();
}
&amp;lt;/h:outputScript&amp;gt;

&amp;lt;a href=&amp;quot;javascript:play()&amp;quot;&amp;gt;音声&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Googleのテキスト読み上げAPIを組み込む</title>
      <link>https://kokuzawa.github.io/blog/2015/05/03/translate-google/</link>
      <pubDate>Sun, 03 May 2015 22:12:37 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/05/03/translate-google/</guid>
      <description>&lt;p&gt;子供用の英単語帳Webアプリを作っています。
単語の読み上げ機能があると便利だなと思い、そんなAPIはないかと調べてみると、
Googleが提供しているテキスト読み上げAPIというのを見つけました。&lt;/p&gt;

&lt;p&gt;使い方はとても簡単で、下記のようなURLを呼び出せば良いようです。
この例ではoneという単語を読み上げてくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://translate.google.com/translate_tts?tl=en&amp;amp;q=one
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;これをHTMLに組み込みます。
HTMLで音声を再生するためにはaudioタグを利用します。
下記のように組み込むことで音声を再生するためのコントロールを表示することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;video src=&amp;quot;http://translate.google.com/translate_tts?tl=en&amp;amp;q=one&amp;quot; controls /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。&lt;/p&gt;

&lt;p&gt;&lt;video src=&#34;http://translate.google.com/translate_tts?tl=en&amp;q=one&#34; controls /&gt;&lt;/p&gt;

&lt;p&gt;実際のアプリはJSF-2.2でFaceletを利用しています。
このタグを組み込んだ場合、最初の一回目は正しく再生されますが
2回目以降が再生されません。
なぜダメなのか結局分からなかったのですが、
UI的にはaudioコントロールを表示したくなかったので、
タグを埋め込むのではなくJavaScriptで再生するようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
function play() {
  var audio = document.createElement(&amp;quot;audio&amp;quot;);
  audio.src = &amp;quot;http://translate.google.com/translate_tts?tl=en&amp;amp;q=one&amp;quot;;
  audio.play();
}
&amp;lt;/script&amp;gt;

&amp;lt;a href=&amp;quot;#&amp;quot; onClick=&amp;quot;play()&amp;quot;&amp;gt;再生&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合audioコントロールは表示されないのですが、
再生リンクをクリックするたびに正しく再生されます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>web.xmlのバージョン別DTD・XSDの宣言方法</title>
      <link>https://kokuzawa.github.io/blog/2015/04/07/web-dot-xmlfalsebaziyonbie-dtdxsdfalsexuan-yan-fang-fa/</link>
      <pubDate>Tue, 07 Apr 2015 23:24:07 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/04/07/web-dot-xmlfalsebaziyonbie-dtdxsdfalsexuan-yan-fang-fa/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;JavaでWebアプリを作る場合、Mavenのmaven-archetype-webappテンプレートを利用しています。
非常に便利なのですが、Servlet 3.1が出ている今、
生成されたwe.xmlがServlet 2.3の記述になっていてちょっと古すぎます。
そのため、毎回テンプレートから生成したあとにweb.xmlを書き換えなければなりません。
このちょっと面倒な作業を楽にするためにバージョン毎の宣言方法をメモしておきます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_servlet_2_3&#34;&gt;Servlet 2.3&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;maven-archetype-webappテンプレートで生成されるものです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;!DOCTYPE web-app PUBLIC
 &#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&#34;
 &#34;http://java.sun.com/dtd/web-app_2_3.dtd&#34; &amp;gt;

&amp;lt;web-app&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_servlet_2_4&#34;&gt;Servlet 2.4&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;web-app version=&#34;2.4&#34;
         xmlns=&#34;http://java.sun.com/xml/ns/j2ee&#34;
         xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
         xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/j2ee
         http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&#34; &amp;gt;

&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_servlet_2_5&#34;&gt;Servlet 2.5&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;web-app xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34;
           xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
           xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/javaee
           http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&#34;
           version=&#34;2.5&#34;&amp;gt;

&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_servlet_3_0&#34;&gt;Servlet 3.0&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;web-app xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34;
           xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
           xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/javaee
           http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&#34;
           version=&#34;3.0&#34;&amp;gt;

&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_servlet_3_1&#34;&gt;Servlet 3.1&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このバージョンからネームスペースが &lt;code&gt;java.sun.com&lt;/code&gt; から &lt;code&gt;xmlns.jcp.org&lt;/code&gt; に変わるんですね。&lt;br&gt;
感慨深い。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;web-app xmlns=&#34;http://xmlns.jcp.org/xml/ns/javaee&#34;
         xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
         xsi:schemaLocation=&#34;http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&#34;
         version=&#34;3.1&#34;&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_servlet_4_0&#34;&gt;Servlet 4.0&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;web-app xmlns=&#34;http://xmlns.jcp.org/xml/ns/javaee&#34;
         xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
         xsi:schemaLocation=&#34;http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&#34;
         version=&#34;4.0&#34;&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>OSXのアイコンキャッシュに悩む</title>
      <link>https://kokuzawa.github.io/blog/2015/02/01/osxfalseaikonkiyatusiyuninao-mu/</link>
      <pubDate>Sun, 01 Feb 2015 13:20:12 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/02/01/osxfalseaikonkiyatusiyuninao-mu/</guid>
      <description>

&lt;p&gt;自宅でのOfficeソフトですが、普段はApache OpenOfficeを使っています。
久しぶりに起動したら最新版へのダウンロードアイコンが表示されていたので、
アップデートをしようとOpenOfficeのサイトを開きました。
すると、それはなんかこう残念なデザインのサイトのままで、
じゃあLibreOfficeの方はどうなんだろうと覗いてみると、
すっきりした個人的に好みなサイトデザインでした。
ソフトウェアの品質には関係がないとわかっていたのですが、
それでもLibreOfficeの方が良さそうだなと思わせてもらうには十分だったので、
これを機会にApache OpenOfficeからLibreOfficeに置き換えることにしました。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;まず、インストールされているApache OpenOfficeをゴミ箱へ捨てます。
そのあと、ダウンロードしておいたLibreOfficeのdmgを起動して、
アプリをApplicationフォルダにコピーします。
これでインストールが完了しました。&lt;/p&gt;

&lt;h2 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;早速スプレットシートを起動してファイルを作成して保存すると、
なぜかファイルのアイコンがOpenOfficeのままになっています。
「情報を見る」で確認すると、アイコンはOpenOfficeなんですが、
プレビューの部分はLibreOfficeになっています。
この時点で、キャッシュが悪さしているのだろうとは思ったのですが、
どうやって直したものかかなり悩みました。&lt;/p&gt;

&lt;h2 id=&#34;キャッシュはどこだ&#34;&gt;キャッシュはどこだ？&lt;/h2&gt;

&lt;p&gt;調べると、OSXのキャッシュ情報は下記の3箇所にあるようです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/System/Library/Caches&lt;/li&gt;
&lt;li&gt;/Library/Caches&lt;/li&gt;
&lt;li&gt;/Users/UserName/Library/Caches&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この中のファイルをすべて削除すれば良さそうですが、
Cachesフォルダの中にIntellij14とかいうフォルダもあって、
何も考えずに削除すると大変なことになりそうな気がします。&lt;/p&gt;

&lt;p&gt;そこでファイルの名前からそれっぽいのを探してピンポイントで削除できないだろうかと、
3箇所の中を眺めていると/Library/Cachesに&lt;code&gt;com.apple.iconservices.store&lt;/code&gt;というそれっぽいフォルダを見つけました。
このフォルダをひとまずリネームしてOSを再起動すると、
スプレットシートのファイルのアイコンが無事にLibreOfficeのものに変わっていました。&lt;/p&gt;

&lt;p&gt;改めて/Library/Cachesを除くと、&lt;code&gt;com.apple.iconservices.store&lt;/code&gt;フォルダが新しく作られているので、
リネームした古いフォルダを削除します。これで完了です。&lt;/p&gt;

&lt;p&gt;一応おきまりの注意ですが、
たまたま上手く行っただけかもしれないので、
あくまでも自己責任でお願いします。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deprecated org.hibernate.ejb.HibernatePersistence</title>
      <link>https://kokuzawa.github.io/blog/2015/01/27/deprecated-org-dot-hibernate-dot-ejb-dot-hibernatepersistence/</link>
      <pubDate>Tue, 27 Jan 2015 23:46:21 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/01/27/deprecated-org-dot-hibernate-dot-ejb-dot-hibernatepersistence/</guid>
      <description>&lt;p&gt;どのバージョンからなのかはわからないが、Hibernate-4.3.8.Finalではpersistence.xmlのproviderに記載するHibernateのプロバイダクラスがdeprecatedになっていた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;provider&amp;gt;org.hibernate.ejb.HibernatePersistence&amp;lt;/provider&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記を下記に置き換える必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;provider&amp;gt;org.hibernate.jpa.HibernatePersistenceProvider&amp;lt;/provider&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Aizu Online Judge</title>
      <link>https://kokuzawa.github.io/blog/2015/01/08/aizu-online-judge/</link>
      <pubDate>Thu, 08 Jan 2015 23:39:37 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2015/01/08/aizu-online-judge/</guid>
      <description>&lt;p&gt;面白いサイトを見つけた。アルゴリズムに対する問題があり、その回答を評価してくれる。&lt;br /&gt;
対応言語は C, Java, D, Ruby, Python, PHP, JavaScript がある。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/index.jsp&#34;&gt;http://judge.u-aizu.ac.jp/onlinejudge/index.jsp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>java.util.Objectsを使おう</title>
      <link>https://kokuzawa.github.io/blog/2014/12/25/java-dot-util-dot-objectswoshi-ikonasou/</link>
      <pubDate>Thu, 25 Dec 2014 01:30:39 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/12/25/java-dot-util-dot-objectswoshi-ikonasou/</guid>
      <description>&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2014/java&#34;&gt;Java Advent Calendar 2014&lt;/a&gt;の25日目です。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/smogami/&#34;&gt;@smogami&lt;/a&gt;さんの「&lt;a href=&#34;http://blog.exoego.net/2014/12/lombok-and-lombok-pg-to-reduce-fat-java.html&#34;&gt;LombokとLombok-pg： Javaコードを減量する魔法のスパイス&lt;/a&gt;」でした。&lt;/p&gt;

&lt;p&gt;今年も様々な面白い記事がアップされました。
そんな楽しかった25日間も今日で最終日です。
最終日なのですが、ちょっと地味にJava7で追加されたjava.util.Objectsについて書きたいと思います。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;java.util.Objectsクラスでは今までありそうでなかった便利なユーティリティメソッドが用意されています。
Java7の時点では下記のメソッドが定義されています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;static &lt;T&gt; int compare(T a, T b, Comparator&amp;lt;? super T&amp;gt; c)&lt;/li&gt;
&lt;li&gt;static boolean deepEquals(Object a, Object b)&lt;/li&gt;
&lt;li&gt;static boolean equals(Object a, Object b)&lt;/li&gt;
&lt;li&gt;static int     hash(Object&amp;hellip; values)&lt;/li&gt;
&lt;li&gt;static int     hashCode(Object o)&lt;/li&gt;
&lt;li&gt;static &lt;T&gt; T   requireNonNull(T obj)&lt;/li&gt;
&lt;li&gt;static &lt;T&gt; T   requireNonNull(T obj, String message)&lt;/li&gt;
&lt;li&gt;static String  toString(Object o)&lt;/li&gt;
&lt;li&gt;static String  toString(Object o, String nullDefault)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳細は&lt;a href=&#34;https://docs.oracle.com/javase/jp/7/api/java/util/Objects.html&#34;&gt;Javadocを参照&lt;/a&gt;してもらうとして、
私はrequireNonNullメソッドをよく利用しています。
いろいろなプロジェクトでメソッドの引数チェックの方法がマチマチだったのが、
このメソッドのおかげで引数チェック方法が統一できたのが画期的でした。
Lombokの@NonNullアノテーションでチェックすればいいじゃない？という話もありますが&amp;hellip;(^^;&lt;/p&gt;

&lt;p&gt;その昔、メソッドの引数がnullだった場合に、IllegalArgumentExceptionをスローすべきか、
NullPointerExceptionをスローすべきかという議論があったのですが、
java.util.ObjectsクラスのrequireNonNullメソッドがNullPointerExceptionをスローするので、
この議論はNullPointerExceptionの勝ちですかね (^^;&lt;/p&gt;

&lt;p&gt;そして現在Java8がリリースされているわけですが、
さらに3つのメソッドが追加されました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;static boolean isNull(Object obj)&lt;/li&gt;
&lt;li&gt;static boolean nonNull(Object obj)&lt;/li&gt;
&lt;li&gt;static &lt;T&gt; T   requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;順当に利用頻度が高そうなメソッドが追加されています。
Supplierを第二引数に取るrequireNonNullメソッドの説明には「メッセージ・サプライヤを作成するコストが文字列メッセージを単に直接作成するコストよりも小さいことを考慮」
とありますが、サプライヤを生成するコストより文字列メッセージを生成するコストが上回るのはどのぐらいの文字列を生成しようとした場合ですかね？あとでちゃんと調べてみたいと思います。&lt;/p&gt;

&lt;p&gt;まだApache-CommonsのObjectUilsクラスには及びませんが、
だいぶ使い勝手が良くなってきているのではないでしょうか。&lt;br /&gt;
ぜひ、皆さんも使ってみてください。&lt;/p&gt;

&lt;p&gt;メリークリスマス！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[JSF-2.3]FacesContextをInjectする</title>
      <link>https://kokuzawa.github.io/blog/2014/12/23/jsf-2-dot-3defacecontextwoinjectsuru/</link>
      <pubDate>Tue, 23 Dec 2014 15:02:06 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/12/23/jsf-2-dot-3defacecontextwoinjectsuru/</guid>
      <description>&lt;p&gt;JSF-2.3の新しい機能として、UIViewRoot, ViewMap, ApplicationMap, ExternalContext, FacesContextがInjectできるようになります。
この記事ではFacesContextの古い取得方法である&lt;code&gt;FacesContext.getCurrentInstance()&lt;/code&gt;と、
Injectを利用した取得方法のサンプルを記載します。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;サンプルでは画面のボタンをクリックすると、&lt;code&gt;&amp;lt;h:messages/&amp;gt;&lt;/code&gt;タグと&lt;code&gt;FacesContext.addMessage(String, FacesMessage)&lt;/code&gt;を利用して
同じ画面上にインフォメーションメッセージを表示します。&lt;/p&gt;

&lt;p&gt;最初にFacesContextの古い取得方法を利用したManaged Beanです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javax.enterprise.context.RequestScoped;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.inject.Inject;
import javax.inject.Named;

@Named
@RequestScoped
public class IndexBean
{
    public void doClick()
    {
        final FacesContext context = FacesContext.getCurrentInstance();
        context.addMessage(null, new FacesMessage(FacesMessage.SEVERITY_INFO, &amp;quot;summary&amp;quot;, &amp;quot;detail&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にInjectを利用してFacesContextを取得するManaged Beanです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javax.enterprise.context.RequestScoped;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.inject.Inject;
import javax.inject.Named;

@Named
@RequestScoped
public class IndexBean
{
    @Inject
    private FacesContext context;

    public void doClick()
    {
        context.addMessage(null, new FacesMessage(FacesMessage.SEVERITY_INFO, &amp;quot;summary&amp;quot;, &amp;quot;detail&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面に表示するXHTMLは下記のようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE html
        PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;quot;
        &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;quot;&amp;gt;

&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;
      xmlns:h=&amp;quot;http://java.sun.com/jsf/html&amp;quot;&amp;gt;

&amp;lt;h:head&amp;gt;
    &amp;lt;title&amp;gt;Simple JSF Facelets page&amp;lt;/title&amp;gt;
&amp;lt;/h:head&amp;gt;

&amp;lt;h:body&amp;gt;
    &amp;lt;h:form&amp;gt;
        &amp;lt;h:messages showDetail=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;h:commandButton actionListener=&amp;quot;#{indexBean.doClick}&amp;quot; value=&amp;quot;OK&amp;quot;/&amp;gt;
    &amp;lt;/h:form&amp;gt;
&amp;lt;/h:body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このアプリをWildFly-8.0.0.Finalにデプロイします。
WildFlyにはJSFの実装が含まれているので、JSF-2.3が含まれるアプリをデプロイすると起動時にエラーになってしまいます。
そこで、アプリに含まれるJSF実装を利用させるために、下記の設定をweb.xmlに追加します。
パラメータを追加するだけで利用する実装を切り替えてくれるので便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;org.jboss.jbossfaces.WAR_BUNDLES_JSF_IMPL&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>RESTEasyとSpringの連携</title>
      <link>https://kokuzawa.github.io/blog/2014/12/20/resteasytospringfalselian-xi/</link>
      <pubDate>Sat, 20 Dec 2014 10:22:07 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/12/20/resteasytospringfalselian-xi/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://qiita.com/advent-calendar/2014/javaee&#34;&gt;Java EE Advent Calendar 2014&lt;/a&gt;の20日の記事です。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/yoshioterada&#34;&gt;@yoshioterada&lt;/a&gt;さんの「&lt;a href=&#34;http://yoshio3.com/2014/12/19/java-ee-8-new-features/&#34;&gt;Java EE 8 の新機能概要のご紹介&lt;/a&gt;」でした。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/suke_masa&#34;&gt;@suke_masa&lt;/a&gt;さんです。&lt;/p&gt;

&lt;p&gt;Jersey-1.8を使ったアプリを最新の2.14に置き換えようと思ったところが始まりです。
サーバーがWildFlyだからRESTEasyが含まれているので、JerseyではなくRESTEasyを使えば良いのだけれども、
アプリ内でJersey MultiPartを使っているのでひとまずバージョンアップを試みたのですが、
いろいろ問題があって結局RESTEasyに置き換えました。&lt;/p&gt;

&lt;p&gt;実際の運用はTomcatを使っているので、Tomcatでも動作する設定を考慮しています。
なので、WildFlyオンリーで考えた場合は不要な設定があるかもしれません。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX Yosemite 10.10&lt;/li&gt;
&lt;li&gt;Java: Java™ SE Runtime Environment (build 1.8.0-b132)&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;WildFly 8.0.0.Final&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pom-xml&#34;&gt;pom.xml&lt;/h2&gt;

&lt;p&gt;下記のdiendencyが必要です。JettisonじゃなくてJacksonを使いたいのでそのdependencyも追加しています。
あとファイルアップロードも使いたいので、&lt;code&gt;resteasy-multipart-provider&lt;/code&gt;も入れています。
&lt;code&gt;resteasy-spring&lt;/code&gt;に依存してRESTEasyのコアライブラリは入るので定義の必要ありません。
Tomcatの場合、サーバにはJAX-RSの実装は入っていないのでscopeはcompileを指定します。
WildFlyの場合はscopeをcompileにすると起動時にエラーが発生するのでprovidedを指定します。
これは既にRESTEasyがサーバに含まれているから。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-servlet-initializer&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-multipart-provider&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-jackson-provider&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.jboss.resteasy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;resteasy-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.10.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;web-xml&#34;&gt;web.xml&lt;/h2&gt;

&lt;p&gt;web.xml には下記を追加します。
url-pattarnが&lt;code&gt;/*&lt;/code&gt;以外の場合は&lt;code&gt;resteasy.servlet.mapping.prefix&lt;/code&gt;の設定が必要です。
&lt;code&gt;resteasy.scan&lt;/code&gt;で自動的にJAX-RSのコンポーネントをスキャンする設定ができるのですが、
springと連携する場合は自動スキャンはしちゃダメ。
自動スキャンしようとすると&lt;code&gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&lt;/code&gt;でエラーになります。&lt;/p&gt;

&lt;p&gt;ということは、@Providerとか@PathがついたクラスはすべてSpringのコンポーネントにしておく必要があります。
あとApplicationのサブクラスはなくても大丈夫です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&lt;/code&gt;を追加しているので、
&lt;code&gt;org.springframework.web.context.ContextLoaderListener&lt;/code&gt;は指定しちゃダメ。
指定すると起動に失敗します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;resteasy.servlet.mapping.prefix&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;/rest&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;
  
  &amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;

  &amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;
  
  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;Resteasy&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&amp;lt;/servlet-class&amp;gt;
  &amp;lt;/servlet&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;Resteasy&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/rest/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これでJAX-RSのリソースクラスにも@AutowiredでDIできるようになります。
RESTEasyのドキュメントに詳細に書いてあるんだけど、web.xmlの設定方法がServletのバージョンを考慮したパターンとか
いろいろありすぎて逆に困る。結局いろいろ試した末に上記の設定にたどり着きました。&lt;/p&gt;

&lt;p&gt;同じようなことをしようとしている人の何かの参考になれば。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaFXでMarkdownエディタを作る</title>
      <link>https://kokuzawa.github.io/blog/2014/12/06/javafxdemarkdownedeitawozuo-ru/</link>
      <pubDate>Sat, 06 Dec 2014 06:42:41 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/12/06/javafxdemarkdownedeitawozuo-ru/</guid>
      <description>

&lt;p&gt;この記事は &lt;a href=&#34;http://www.adventar.org/calendars/380&#34;&gt;JavaFX Advent Calendar 2014&lt;/a&gt; の6日目です。&lt;br /&gt;
昨日は&lt;a href=&#34;http://www.adventar.org/users/5558&#34;&gt;soutoku&lt;/a&gt;さんの&lt;a href=&#34;http://soutoku.hatenablog.com/entry/2014/12/05/013342&#34;&gt;JavaFX:WYSIWYGエディタを作る&lt;/a&gt;でした。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/backpaper0&#34;&gt;@backpaper0&lt;/a&gt;さんです。&lt;/p&gt;

&lt;p&gt;JavaFX 楽しいですよね。&lt;/p&gt;

&lt;p&gt;JavaFXには標準でWebページを表示するためのWebViewクラスがあり、これを使えばいろいろなことができます。
今回はこのWebViewクラスを使ってMarkdownエディタを作ってみることにします。
MarkdownといえばGitHubとかでも利用している人が多いかと思いますが、文書を記述するための軽量マークアップ言語です。
Markdownでテキストを入力し、それをパースしてWebViewに表示するという簡単な動作をするアプリケーションです。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX Yosemite 10.10&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;Java: Java SE Runtime Environment (build 1.8.0-b132)&lt;/li&gt;
&lt;li&gt;markdown4j-2.2-cj-1.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Markdownのパースには&lt;a href=&#34;https://code.google.com/p/markdown4j/&#34;&gt;markdown4j&lt;/a&gt;を使うことにしました。&lt;/p&gt;

&lt;h2 id=&#34;実際に動かしてみる&#34;&gt;実際に動かしてみる&lt;/h2&gt;

&lt;p&gt;実際に動作している動画です。&lt;/p&gt;

&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/zjFR_In-gik&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;fxmlで外枠を作る&#34;&gt;FXMLで外枠を作る&lt;/h2&gt;

&lt;p&gt;外枠を作るのはFXMLで書けばよいので簡単です。
IntelliJ IDEA 14 を使っているのでインラインScene Builderも使えますが&amp;hellip;という状態なので
スタンドアロンのScene Builderを使いました。
ささっと作ったFXMLは以下のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;?import javafx.scene.control.*?&amp;gt;
&amp;lt;?import javafx.scene.layout.*?&amp;gt;
&amp;lt;?import javafx.scene.text.TextFlow?&amp;gt;
&amp;lt;BorderPane maxHeight=&amp;quot;-Infinity&amp;quot;
            maxWidth=&amp;quot;-Infinity&amp;quot;
            minHeight=&amp;quot;-Infinity&amp;quot;
            minWidth=&amp;quot;-Infinity&amp;quot;
            prefHeight=&amp;quot;400.0&amp;quot;
            prefWidth=&amp;quot;600.0&amp;quot;
            xmlns=&amp;quot;http://javafx.com/javafx/8&amp;quot; xmlns:fx=&amp;quot;http://javafx.com/fxml/1&amp;quot;
	    fx:controller=&amp;quot;sample.Controller&amp;quot;&amp;gt;
   &amp;lt;center&amp;gt;
      &amp;lt;SplitPane dividerPositions=&amp;quot;0.5&amp;quot;
                 orientation=&amp;quot;VERTICAL&amp;quot;
                 prefHeight=&amp;quot;200.0&amp;quot;
                 prefWidth=&amp;quot;160.0&amp;quot;
                 BorderPane.alignment=&amp;quot;CENTER&amp;quot;&amp;gt;
        &amp;lt;items&amp;gt;
          &amp;lt;AnchorPane minHeight=&amp;quot;0.0&amp;quot; minWidth=&amp;quot;0.0&amp;quot; prefHeight=&amp;quot;100.0&amp;quot; prefWidth=&amp;quot;160.0&amp;quot;&amp;gt;
               &amp;lt;children&amp;gt;
                  &amp;lt;TextArea fx:id=&amp;quot;textArea&amp;quot;
		            prefHeight=&amp;quot;200.0&amp;quot;
                            prefWidth=&amp;quot;200.0&amp;quot;
                            AnchorPane.bottomAnchor=&amp;quot;0.0&amp;quot;
                            AnchorPane.leftAnchor=&amp;quot;0.0&amp;quot;
                            AnchorPane.rightAnchor=&amp;quot;0.0&amp;quot;
                            AnchorPane.topAnchor=&amp;quot;0.0&amp;quot;&amp;gt;
		  &amp;lt;/TextArea&amp;gt;
               &amp;lt;/children&amp;gt;
               &amp;lt;padding&amp;gt;
                  &amp;lt;Insets bottom=&amp;quot;5.0&amp;quot; left=&amp;quot;5.0&amp;quot; right=&amp;quot;5.0&amp;quot; top=&amp;quot;5.0&amp;quot; /&amp;gt;
               &amp;lt;/padding&amp;gt;
            &amp;lt;/AnchorPane&amp;gt;
          &amp;lt;AnchorPane minHeight=&amp;quot;0.0&amp;quot; minWidth=&amp;quot;0.0&amp;quot; prefHeight=&amp;quot;100.0&amp;quot; prefWidth=&amp;quot;160.0&amp;quot;&amp;gt;
               &amp;lt;children&amp;gt;
                  &amp;lt;WebView fx:id=&amp;quot;webView&amp;quot;
                           prefHeight=&amp;quot;200.0&amp;quot; 
                           prefWidth=&amp;quot;200.0&amp;quot; 
                           AnchorPane.bottomAnchor=&amp;quot;0.0&amp;quot; 
                           AnchorPane.leftAnchor=&amp;quot;0.0&amp;quot; 
                           AnchorPane.rightAnchor=&amp;quot;0.0&amp;quot; 
                           AnchorPane.topAnchor=&amp;quot;0.0&amp;quot; /&amp;gt;
               &amp;lt;/children&amp;gt;
               &amp;lt;padding&amp;gt;
                  &amp;lt;Insets bottom=&amp;quot;5.0&amp;quot; left=&amp;quot;5.0&amp;quot; right=&amp;quot;5.0&amp;quot; top=&amp;quot;5.0&amp;quot; /&amp;gt;
               &amp;lt;/padding&amp;gt;
            &amp;lt;/AnchorPane&amp;gt;
        &amp;lt;/items&amp;gt;
      &amp;lt;/SplitPane&amp;gt;
   &amp;lt;/center&amp;gt;
   &amp;lt;top&amp;gt;
      &amp;lt;MenuBar BorderPane.alignment=&amp;quot;CENTER&amp;quot;&amp;gt;
        &amp;lt;menus&amp;gt;
          &amp;lt;Menu mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;File&amp;quot;&amp;gt;
            &amp;lt;items&amp;gt;
              &amp;lt;MenuItem mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;Close&amp;quot; /&amp;gt;
            &amp;lt;/items&amp;gt;
          &amp;lt;/Menu&amp;gt;
          &amp;lt;Menu mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;Edit&amp;quot;&amp;gt;
            &amp;lt;items&amp;gt;
              &amp;lt;MenuItem mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;Delete&amp;quot; /&amp;gt;
            &amp;lt;/items&amp;gt;
          &amp;lt;/Menu&amp;gt;
          &amp;lt;Menu mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;Help&amp;quot;&amp;gt;
            &amp;lt;items&amp;gt;
              &amp;lt;MenuItem mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;About&amp;quot; /&amp;gt;
            &amp;lt;/items&amp;gt;
          &amp;lt;/Menu&amp;gt;
        &amp;lt;/menus&amp;gt;
      &amp;lt;/MenuBar&amp;gt;
   &amp;lt;/top&amp;gt;
&amp;lt;/BorderPane&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BorderPaneのtopに配置しているMenuBarは飾りです (^^;&lt;br /&gt;
本体はBorderPaneのcenterにSplitPaneを配置し、上半分にTextArea、下半分にWebViewを表示します。&lt;/p&gt;

&lt;h2 id=&#34;コントローラを作る&#34;&gt;コントローラを作る&lt;/h2&gt;

&lt;p&gt;この画面を操作するためのコントローラクラスを作ります。
コントローラがやることは、TextAreaに入力された値をパースしてWebViewに表示することです。
今回はTextAreaにイベントを張って、イベント発生毎にWebViewの内容を書き換える方法ではなく、
TextAreaのテキストプロパティにChangeListenerを設定し、値の変化を検知してWebViewを書き換えるようにします。
本当はWebView側にコンテンツをバインドできるプロパティが存在すればバインドを使いたいところです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package sample;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.TextArea;
import javafx.scene.web.WebView;
import org.markdown4j.Markdown4jProcessor;

import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;

public class Controller implements Initializable
{
    @FXML
    private TextArea textArea;

    @FXML
    private WebView webView;

    @Override
    public void initialize(URL location, ResourceBundle resources)
    {
        textArea.textProperty().addListener((observable, oldValue, newValue) -&amp;gt; {
            try {
                webView.getEngine().loadContent(new Markdown4jProcessor().process(newValue));
            }
            catch (StringIndexOutOfBoundsException | IOException e) {
                webView.getEngine().loadContent(newValue);
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ChangeListenerを設定するためには&lt;code&gt;TextArea#textProperty()&lt;/code&gt;メソッドからStringPropertyを取得し、
そのプロパティの持つ&lt;code&gt;addListener&lt;/code&gt;を使用します。
値の変更を検知するとChangeListenerのchangedメソッドがコールされるので、
ここでWebViewに対してHTMLを設定するようにします。
入力された文字列は&lt;code&gt;Markdown4jProcessor#process(String)&lt;/code&gt;メソッドを経由してHTMLに変換されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;WebView#loadContent(String)&lt;/code&gt;メソッドには&lt;code&gt;WebView#loadContent(String, String)&lt;/code&gt;という引数を２つ取るメソッドも存在します。
引数が２つのほうは、第二引数にコンテンツタイプを指定できます。引数が１つのほうは内部で引数が２つメソッドを呼び出しいて、
第二引数には&amp;rdquo;text/html&amp;rdquo;を渡しています。ですので、デフォルトではHTMLを表示することになりますね。&lt;/p&gt;

&lt;h2 id=&#34;まとめとちょっと考察&#34;&gt;まとめとちょっと考察&lt;/h2&gt;

&lt;p&gt;これでシンプルなMarkdownエディタができました。
実は、ChangeListenerの代わりにInvalidationListenerを使うこともできます。
ChangeListenerとInvalidationListenerの違いは下記のサイトを参考にさせてもらいました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://skrb.hatenablog.com/entry/2013/09/08/174826&#34;&gt;JavaFX in the Box:JavaFX Hands on Lab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/nodamushi/20141012/1413136054&#34;&gt;プログラムdeタマゴ:JavaFXのInvalidationListenerやChangeListenerやObservableListやBindingについて&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;textArea.textProperty().addListener(observable -&amp;gt; {
    final String value = ((StringProperty) observable).get();
    try {
        webView.getEngine().loadContent(new Markdown4jProcessor().process(value));
    }
    catch (StringIndexOutOfBoundsException | IOException e) {
        webView.getEngine().loadContent(value);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、InvalidationListenerを使うと次のような問題が発生します。&lt;/p&gt;

&lt;p&gt;日本語入力においてChangeListenerだと確定前文字が入力された場合だけイベントが呼ばれるのですが、
InvalidationListenerだと確定前文字が入力された時と入力文字を確定した場合の2度イベントが発生します。
正確には、一回の値変更でイベントが2度発生するので計4回のイベントを受け取る形です。
確定前文字と入力文字を確定した時の文字は同じものであるため2回目のイベントが無駄になってしまいます。
使い方がまずいのかもしれないのですが、ChangeListenerを使ったほうが無難な様子です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FlexとJavaFXでREST-APIを呼び出す</title>
      <link>https://kokuzawa.github.io/blog/2014/11/03/javafxderest-apiwohu-bichu-su/</link>
      <pubDate>Mon, 03 Nov 2014 17:12:02 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/11/03/javafxderest-apiwohu-bichu-su/</guid>
      <description>

&lt;p&gt;FlexとJavaFXからREST-APIを呼び出してみました。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX Yosemite 10.10&lt;/li&gt;
&lt;li&gt;Java: Java&amp;trade; SE Runtime Environment (build 1.8.0-b132)&lt;/li&gt;
&lt;li&gt;Flex SDK 4.6&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;WildFly 8.0.0.Final&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;サーバの用意&#34;&gt;サーバの用意&lt;/h2&gt;

&lt;p&gt;今回の本題ではないので、ここでは簡単な文字列を返すだけのAPIを作成します。
引数で受け取った文字を加工して「Hello XXX!」という文字を返します。
RESTの実装にはJersey-2.8を利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;

@Path(&amp;quot;/hello&amp;quot;)
public class HelloService
{
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello(@QueryParam(&amp;quot;string&amp;quot;) String string)
    {
        return String.format(&amp;quot;Hello %s!&amp;quot;, string);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flexからのrest-api呼び出し&#34;&gt;FlexからのREST-API呼び出し&lt;/h2&gt;

&lt;p&gt;JavaFXとの比較のためにFlexからのREST-API呼び出しを提示します。&lt;/p&gt;

&lt;p&gt;画面構成を管理するMXMLです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Main.mxml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;s:WindowedApplication
        xmlns:fx=&amp;quot;http://ns.adobe.com/mxml/2009&amp;quot;
        xmlns:s=&amp;quot;library://ns.adobe.com/flex/spark&amp;quot;
        xmlns:local=&amp;quot;*&amp;quot; 
        title=&amp;quot;Hello World&amp;quot; 
        width=&amp;quot;230&amp;quot; 
        height=&amp;quot;80&amp;quot;&amp;gt;
    &amp;lt;fx:Declarations&amp;gt;
        &amp;lt;local:Controller id=&amp;quot;controller&amp;quot;/&amp;gt;
    &amp;lt;/fx:Declarations&amp;gt;
    &amp;lt;s:VGroup paddingBottom=&amp;quot;10&amp;quot; 
              paddingLeft=&amp;quot;10&amp;quot; 
              paddingRight=&amp;quot;10&amp;quot; 
              paddingTop=&amp;quot;10&amp;quot; 
              gap=&amp;quot;10&amp;quot; 
              minHeight=&amp;quot;0&amp;quot;&amp;gt;
        &amp;lt;s:HGroup&amp;gt;
            &amp;lt;s:TextInput id=&amp;quot;stringField&amp;quot;/&amp;gt;
            &amp;lt;s:Button label=&amp;quot;Button&amp;quot; click=&amp;quot;{controller.buttonAction(event)}&amp;quot;/&amp;gt;
        &amp;lt;/s:HGroup&amp;gt;
        &amp;lt;s:Label id=&amp;quot;stringLabel&amp;quot;/&amp;gt;
    &amp;lt;/s:VGroup&amp;gt;
&amp;lt;/s:WindowedApplication&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面をコントロールするコントローラクラスです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller.as:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-as&#34;&gt;package {
    import flash.events.MouseEvent;

    import mx.core.IMXMLObject;
    import mx.rpc.events.ResultEvent;
    import mx.rpc.http.mxml.HTTPService;

    public class Controller implements IMXMLObject
    {
        private var _document:Main;

        public function initialized(document:Object, id:String):void
        {
            _document = document as Main;
        }

        public function buttonAction(event:MouseEvent):void
        {
            var service:HTTPService = new HTTPService(&amp;quot;http://localhost:8080&amp;quot;);
            service.url = &amp;quot;/jaxrs/rest/hello&amp;quot;;
            service.addEventListener(ResultEvent.RESULT, function (e:ResultEvent):void
            {
                _document.stringLabel.text = e.result as String;
            });
            service.send({string:_document.stringField.text});
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動すると下記の画面が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_37.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;javafxからrest-apiを呼び出す&#34;&gt;JavaFXからREST-APIを呼び出す&lt;/h2&gt;

&lt;p&gt;JavaFXからの呼び出し例を提示します。&lt;/p&gt;

&lt;p&gt;画面構成を管理するFXMLです。
画面レイアウトにはSceneBuilder-2.0を利用しました。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sample.fxml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;?import javafx.geometry.Insets?&amp;gt;
&amp;lt;?import javafx.scene.control.Button?&amp;gt;
&amp;lt;?import javafx.scene.control.Label?&amp;gt;
&amp;lt;?import javafx.scene.control.TextField?&amp;gt;
&amp;lt;?import javafx.scene.layout.*?&amp;gt;
&amp;lt;GridPane alignment=&amp;quot;center&amp;quot; 
          hgap=&amp;quot;10&amp;quot; 
          prefHeight=&amp;quot;46.0&amp;quot; 
          prefWidth=&amp;quot;324.0&amp;quot; 
          vgap=&amp;quot;10&amp;quot; 
          xmlns=&amp;quot;http://javafx.com/javafx/8&amp;quot; 
          xmlns:fx=&amp;quot;http://javafx.com/fxml/1&amp;quot; 
          fx:controller=&amp;quot;sample.Controller&amp;quot;&amp;gt;
   &amp;lt;columnConstraints&amp;gt;
      &amp;lt;ColumnConstraints /&amp;gt;
      &amp;lt;ColumnConstraints minWidth=&amp;quot;10.0&amp;quot; prefWidth=&amp;quot;60.0&amp;quot; /&amp;gt;
   &amp;lt;/columnConstraints&amp;gt;
   &amp;lt;rowConstraints&amp;gt;
      &amp;lt;RowConstraints /&amp;gt;
      &amp;lt;RowConstraints minHeight=&amp;quot;10.0&amp;quot; prefHeight=&amp;quot;30.0&amp;quot; /&amp;gt;
   &amp;lt;/rowConstraints&amp;gt;
   &amp;lt;children&amp;gt;
      &amp;lt;TextField fx:id=&amp;quot;stringField&amp;quot; prefHeight=&amp;quot;26.0&amp;quot; prefWidth=&amp;quot;205.0&amp;quot; /&amp;gt;
      &amp;lt;Button mnemonicParsing=&amp;quot;false&amp;quot; text=&amp;quot;Button&amp;quot; GridPane.columnIndex=&amp;quot;1&amp;quot; onAction=&amp;quot;#buttonAction&amp;quot;/&amp;gt;
      &amp;lt;Label fx:id=&amp;quot;stringLabel&amp;quot; GridPane.columnSpan=&amp;quot;2&amp;quot; GridPane.rowIndex=&amp;quot;1&amp;quot; /&amp;gt;
   &amp;lt;/children&amp;gt;
   &amp;lt;padding&amp;gt;
      &amp;lt;Insets bottom=&amp;quot;10.0&amp;quot; left=&amp;quot;10.0&amp;quot; right=&amp;quot;10.0&amp;quot; top=&amp;quot;10.0&amp;quot; /&amp;gt;
   &amp;lt;/padding&amp;gt;
&amp;lt;/GridPane&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaによるREST-API呼び出しは、JAX-RSクライアントを利用するため、
下記ライブラリを追加します。（Mavenの設定）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.glassfish.jersey.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jersey-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.8&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面をコントロールするコントローラクラスです。
ボタンがクリックされた場合にREST-APIを呼び出して結果をラベルに設定します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.MediaType;

public class Controller
{
    @FXML
    private TextField stringField;

    @FXML
    private Label stringLabel;

    public void buttonAction()
    {
        final Client client = ClientBuilder.newClient();
        try {
            final String result = client.target(&amp;quot;http://localhost:8080/jaxrs/rest&amp;quot;)
                    .path(&amp;quot;hello&amp;quot;)
                    .queryParam(&amp;quot;string&amp;quot;, stringField.getText())
                    .request(MediaType.TEXT_PLAIN_TYPE)
                    .get(String.class);
            stringLabel.setText(result);
        }
        finally {
            client.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動すると下記の画面が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_38.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;javafxからの呼び出しを非同期にする&#34;&gt;JavaFXからの呼び出しを非同期にする&lt;/h2&gt;

&lt;p&gt;FlexもJavaFXもほぼ同じようなコードでREST-APIを呼び出すことができるのですが、
Flexの方は非同期呼び出しであり、JavaFXの方は同期呼び出しという違いがあります。
そこでJavaFXの方でも非同期呼び出しをさせてみたいと思います。&lt;/p&gt;

&lt;p&gt;JAX-RSクライアントには非同期呼び出しの仕組みがあるので、
それを利用するようにREST-APIの呼び出し部分を下記のように書き換えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Client client = ClientBuilder.newClient();
client.target(&amp;quot;http://localhost:8080/jaxrs/rest&amp;quot;)
      .path(&amp;quot;hello&amp;quot;)
      .queryParam(&amp;quot;string&amp;quot;, stringField.getText())
      .request(MediaType.TEXT_PLAIN_TYPE)
      .async()
      .get(new InvocationCallback&amp;lt;String&amp;gt;()
      {
          @Override
          public void completed(String result)
          {
              stringLabel.setText(result);
          }

          @Override
          public void failed(Throwable throwable)
          {
              throwable.printStackTrace();
          }
      });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出しチェーンに&lt;code&gt;async()&lt;/code&gt;メソッドを追加します。
結果は戻り値ではなく、&lt;code&gt;InvocationCallback&amp;lt;T&amp;gt;&lt;/code&gt;インターフェースの&lt;code&gt;completed(T)&lt;/code&gt;メソッドで受け取るようになります。
また、呼び出し後にclientをクローズしてしまうと非同期によるレスポンスを受け取る前に接続が切れてしまいます。
そのため、ここではクローズは行いません。&lt;/p&gt;

&lt;p&gt;これで非同期になると思いきや、実行すると下記エラーが発生します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;javax.ws.rs.ProcessingException: java.lang.IllegalStateException: Not on FX application thread; currentThread = jersey-client-async-executor-0
	at org.glassfish.jersey.client.ClientRuntime.processFailure(ClientRuntime.java:173)
	at org.glassfish.jersey.client.ClientRuntime.access$400(ClientRuntime.java:69)
	at org.glassfish.jersey.client.ClientRuntime$1.run(ClientRuntime.java:155)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaFXアプリのスレッド以外でアクセスしようとしたのでエラーが発生しています。
というわけで&lt;code&gt;async()&lt;/code&gt;メソッドは使えません。
そこで、&lt;code&gt;javafx.concurrent.Service&lt;/code&gt;クラスを利用します。
このクラスを利用すると、JavaFXアプリにおいて別スレッドを利用できるようになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javafx.concurrent.Service&lt;/code&gt;クラスを利用したクラスが下記になります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HelloService.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.concurrent.Service;
import javafx.concurrent.Task;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.MediaType;

public class HelloService extends Service&amp;lt;String&amp;gt;
{
    private StringProperty string = new SimpleStringProperty();

    public StringProperty stringProperty()
    {
        return string;
    }

    @Override
    protected Task&amp;lt;String&amp;gt; createTask()
    {
        return new Task&amp;lt;String&amp;gt;()
        {
            @Override
            protected String call() throws Exception
            {
                if (false == string.get().isEmpty()) {
                    final Client client = ClientBuilder.newClient();
                    try {
                        return client.target(&amp;quot;http://localhost:8080/jaxrs/rest&amp;quot;)
                                .path(&amp;quot;hello&amp;quot;)
                                .queryParam(&amp;quot;string&amp;quot;, string.get())
                                .request(MediaType.TEXT_PLAIN_TYPE)
                                .get(String.class);
                    }
                    finally {
                        client.close();
                    }
                }
                return null;
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作成したサービスクラスを利用するようにコントローラクラスを書き換えます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;

import java.net.URL;
import java.util.ResourceBundle;

public class Controller implements Initializable
{
    @FXML
    private TextField stringField;

    @FXML
    private Label stringLabel;

    private HelloService service = new HelloService();

    public void buttonAction()
    {
        service.restart();
    }

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle)
    {
        service.stringProperty().bind(stringField.textProperty());
        service.setOnSucceeded(e -&amp;gt; stringLabel.setText((String)e.getSource().getValue()));
        service.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Initializable&lt;/code&gt;インターフェースの&lt;code&gt;initialize(URL, ResourceBundle)&lt;/code&gt;メソッド内で
入力フィールドをサービスクラスへバインドし、サービスの処理完了時に呼ばれる&lt;code&gt;setOnSucceeded&lt;/code&gt;メソッドで
ラベルに対してレスポンスを書き出すようにします。&lt;code&gt;start()&lt;/code&gt;メソッドでサービスを開始します。&lt;/p&gt;

&lt;p&gt;また、書き換え前のコードではボタンクリックのハンドラ内でREEST-APIを呼び出していましたが、
新しいコードではサービスクラスの&lt;code&gt;restart()&lt;/code&gt;メソッドを呼び出し、
サービスの起動状態をキャンセルして再起動させます。こうすることにより、サービス内のタスクが再度生成されるので、
入力された値がサーバーに送信されるようになります。
入力値はバインドを利用しているので、サービスへの再設定は必要ありません。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;FlexとJavaFXでの簡単な呼び出しにおいてはほとんど違いがないことがわかるかと思います。
JavaFXで非同期呼び出しをしようとした場合にちょっとだけ面倒になりますが、
非同期にしたい部分だけ今回のようにサービスにするだけなので、
JavaFXを利用する上ではそれほど問題にならないかな、と思っています。&lt;/p&gt;

&lt;p&gt;Flexでは同期呼び出しにするという選択肢がないので、
同期と非同期を切り替えられるJavaFXの方がメリットがありそうです。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javafx/2/threads/jfxpub-threads.htm&#34;&gt;Concurrency in JavaFX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JSFのCSRF対策</title>
      <link>https://kokuzawa.github.io/blog/2014/10/08/jsffalsecsrfdui-ce/</link>
      <pubDate>Wed, 08 Oct 2014 02:29:57 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/10/08/jsffalsecsrfdui-ce/</guid>
      <description>

&lt;p&gt;だいぶ前にリリースされたJSF 2.2ではCSRF対策の機能が追加されました。
そこで、JSFをどのように利用している場合にCSRFの脆弱性が発生するのかと、
JSF 2.2で追加されたCSRF対策を実施すると、この問題をどのように防げるのかを確認してみます。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX 10.9.4&lt;/li&gt;
&lt;li&gt;Java: Java&amp;trade; SE Runtime Environment (build 1.8.0-b132)&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;WildFly 8.0.0.Final&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;アプリを作る&#34;&gt;アプリを作る&lt;/h2&gt;

&lt;p&gt;CSRFの脆弱性がある、といわれても具体例がないとなかなかイメージするのが難しいかもしれません。
そこで、ここでは実際に攻撃を受けるアプリを作り、脆弱性を露呈されてみたいと思います。
コードの構成は下記のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JSFCSRFSample
    +- src
    |  +- main
    |  |   +- java
    |  |       +- org.katsumi.bean
    |  |           +- FormBean.java
    |  +- webapp
    |      +- index.xhtml
    |      +- result.xhtml
    |      +- warning.xhtml
    |      +- WEB-INF
    |          +- jboss-web.xml
    |          +- faces-config.xml
    |          +- web.xml
    +- pom.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;index.xhtmlページでボタンをクリックすることで、result.xhtmlページに遷移します。
ユースケースとして、result.xhtmlでindex.xhtmlから受け取ったパラメータを登録して、その値を表示することを想定します。
サンプルコードでは、index.xhmlから送信したパラメータをFormBean.javaで受け取り、
その値を加工して結果を表示しています。
index.xhtml、result.xhtml、FormBean.javaは下記のように非常にシンプルな構成です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.xhtml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;
      xmlns:h=&amp;quot;http://xmlns.jcp.org/jsf/html&amp;quot;
      xmlns:f=&amp;quot;http://xmlns.jcp.org/jsf/core&amp;quot;&amp;gt;
&amp;lt;f:view transient=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;h:button value=&amp;quot;Jump!&amp;quot; outcome=&amp;quot;/result?text=ああああ&amp;quot;/&amp;gt;
&amp;lt;/f:view&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;result.xhtml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;
      xmlns:h=&amp;quot;http://xmlns.jcp.org/jsf/html&amp;quot;
      xmlns:f=&amp;quot;http://xmlns.jcp.org/jsf/core&amp;quot;&amp;gt;
&amp;lt;f:view&amp;gt;
    &amp;lt;f:metadata&amp;gt;
        &amp;lt;f:viewParam name=&amp;quot;text&amp;quot; value=&amp;quot;#{formBean.text}&amp;quot;/&amp;gt;
    &amp;lt;/f:metadata&amp;gt;
    &amp;lt;p&amp;gt;結果を表示:&amp;lt;/p&amp;gt;
    &amp;lt;h:outputText value=&amp;quot;#{formBean.text}&amp;quot;/&amp;gt;
&amp;lt;/f:view&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;FormBean.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi.bean;

import lombok.Setter;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;

@Named
@RequestScoped
public class FormBean
{
    @Setter
    private String text;

    public String getText()
    {
        return String.format(&amp;quot;登録しました「%s」&amp;quot;, text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;攻撃する&#34;&gt;攻撃する&lt;/h2&gt;

&lt;p&gt;準備はできたので、実際に動作させて攻撃してみます。
起動後にindex.xhtmlにアクセスすると下記の画面が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_32.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「Jump!」ボタンをクリックすると、パラメータが送信されてresult.xhtmlが表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_33.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで、攻撃者が用意した下記のリンクを踏んだと仮定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost/jsf-csrf/result.xhtml?text=攻撃
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同一ブラウザであれば、同じセッションIDがサーバーに送信されるはずなので、
認証をセッションIDベースで行っている場合は問題なくスルーされるはずです。
というわけで、下記の結果になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_34.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;意図していない文字列が登録されてしまいました。&lt;/p&gt;

&lt;h2 id=&#34;対策をする&#34;&gt;対策をする&lt;/h2&gt;

&lt;p&gt;このように悪意を持ったリンクを踏んでしまうと、
ユーザの意図しない文字列を簡単に登録できてしまうという脆弱性がこのアプリには存在します。
CSRFの対策は、元の画面にトークンを埋め込み、受け取り先でそのトークンの一致を検証することで
正しいルートからのリクエストであることを判定する方法が一般的です。
JSF 2.2からこの仕組みを利用できるようになっているので対策をします。&lt;/p&gt;

&lt;p&gt;faces-config.xmlに下記を追記してresult.xhtmlページを保護します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;faces-config.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;protected-views&amp;gt;
    &amp;lt;url-pattern&amp;gt;/result.xhtml&amp;lt;/url-pattern&amp;gt;
&amp;lt;/protected-views&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSFでは保護されたページに不正にアクセスすると&lt;code&gt;javax.faces.application.ProtectedViewException&lt;/code&gt;がスローされます。
そこで、保護されたページにアクセスした場合に表示されるエラーページの設定をweb.xmlに追記します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;warning.xhtml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;
      xmlns:f=&amp;quot;http://xmlns.jcp.org/jsf/core&amp;quot;&amp;gt;
&amp;lt;f:view&amp;gt;
    &amp;lt;h1&amp;gt;不正なリクエストです。&amp;lt;/h1&amp;gt;
&amp;lt;/f:view&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;web.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;error-page&amp;gt;
    &amp;lt;exception-type&amp;gt;javax.faces.application.ProtectedViewException&amp;lt;/exception-type&amp;gt;
    &amp;lt;location&amp;gt;/warning.xhtml&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;攻撃者が用意した先ほどのリンクを送信すると下記の結果になりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_35.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;うまく機能しているようです。
正しいルートでリクエストを送信すると、下記のようにトークンが付与されていることがわかります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_36.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;このようにJSFでもCSRF対策が簡単にできるようになりました。
とはいってもそもそもGETでデータを登録しようとしているのが問題のような気もします。
というのは、JSFのManagedBeanのプロパティへバインディングする形でPOSTリクエストを送信している場合、
今回のような攻撃ができないからです。JSFでは画面表示時にコンポーネントツリーを形成していて、
値のバインディングがそのツリーを利用して行われています。
そのため、今回のようにリクエストパラメータを直接プロパティへバインディングしようとしなければ、
簡単に攻撃できないように感じます（色々試してみたのですが攻撃できませんでした。
攻撃方法があるようでしたらこっそり教えて頂けると嬉しいです）&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/クロスサイトリクエストフォージェリ&#34;&gt;クロスサイトリクエストフォージェリ - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/JSF-CSRF-Demo/JSF2.2CsrfDemo.html&#34;&gt;Java Platform, Enterprise Edition 7: JSON Processing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Javaで文書検索をする (Apache Solr)</title>
      <link>https://kokuzawa.github.io/blog/2014/09/07/apache-solrnidui-sitejavadewen-shu-jian-suo-wosuru/</link>
      <pubDate>Sun, 07 Sep 2014 22:04:16 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/09/07/apache-solrnidui-sitejavadewen-shu-jian-suo-wosuru/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://kokuzawa.github.io/blog/2014/09/05/apache-solrdequan-wen-jian-suo-nihong-reru/&#34;&gt;前回&lt;/a&gt;
Apache Solrに対してJavaで文書登録をして、APIでその結果が取得できるところまでやってみました。
今回はAPIではなく、登録した文書をJavaで検索してみようと思います。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX 10.9.4&lt;/li&gt;
&lt;li&gt;Java: Oracle Corporation Java HotSpot™ 64-Bit Server VM (1.8.0 25.0-b70)&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;Apache Solr-4.10.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;javaで文書検索&#34;&gt;Javaで文書検索&lt;/h2&gt;

&lt;p&gt;文書登録時と同じく、Apache Solrjが必要です。
ライブラリの取得方法は前回を参照して頂くとして、早速サンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrServer;
import org.apache.solr.client.solrj.impl.HttpSolrServer;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.common.SolrDocument;
import org.apache.solr.common.SolrDocumentList;

public class SolrClient
{
    public static void main(String... args) throws Exception
    {
        final SolrServer solr = new HttpSolrServer(&amp;quot;http://localhost:8983/solr/collection1&amp;quot;);
        final SolrQuery solrQuery = new SolrQuery();
        solrQuery.set(&amp;quot;q&amp;quot;, &amp;quot;ストリーム&amp;quot;);
        final QueryResponse response = solr.query(solrQuery);
        final SolrDocumentList results = response.getResults();
        final SolrDocument document = results.get(0);
        System.out.println(document.get(&amp;quot;id&amp;quot;));
        System.out.println(document.get(&amp;quot;content_type&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件は前回と同じ「ストリーム」を指定します。
上記を実行すると以下のような出力結果になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javamagazinevol16.pdf
[application/pdf]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;サポートしているファイルタイプ&#34;&gt;サポートしているファイルタイプ&lt;/h2&gt;

&lt;p&gt;PDFファイルの登録と検索ができることは確認しましたが、他のファイルはどうなのか気になります。
業務アプリとして利用するにはOfficeファイル、みんなが大好きExcelは検索したいところです。
Solrのリファレンスガイドを読むと下記のファイルをサポートしているようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xml, json, csv, pdf, doc, docx, ppt, pptx, xls, xlsx, odt, odp, ods, rtf, htm, html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;業務で必要となりそうなファイルは大体そろっていますが個人的にはiWorkの文書もサポートして欲しいところ&amp;hellip;。
内部的にはApache Tikaを利用しているので、iWorkもサポートされているはずと思い試してみたのですが、
下記エラーが出て登録ができませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Exception in thread &amp;quot;main&amp;quot; org.apache.solr.client.solrj.SolrServerException: error reading streams
	at org.apache.solr.client.solrj.impl.HttpSolrServer.createMethod(HttpSolrServer.java:434)
	at org.apache.solr.client.solrj.impl.HttpSolrServer.request(HttpSolrServer.java:210)
	at org.apache.solr.client.solrj.impl.HttpSolrServer.request(HttpSolrServer.java:206)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何か方法があるのかもしれませんが、今日のところは時間切れ。
あとでまた調べてみたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache solrで全文検索に触れる</title>
      <link>https://kokuzawa.github.io/blog/2014/09/05/apache-solrdequan-wen-jian-suo-nihong-reru/</link>
      <pubDate>Fri, 05 Sep 2014 00:12:34 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/09/05/apache-solrdequan-wen-jian-suo-nihong-reru/</guid>
      <description>

&lt;p&gt;Javaで簡単に全文検索を体験するには Apache Solr (ソーラー)が便利です。&lt;br /&gt;
今回は現時点での最新バージョンである 4.10.0 を利用して全文検索を体験したいと思います。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS: Mac OSX 10.9.4&lt;/li&gt;
&lt;li&gt;Java: Oracle Corporation Java HotSpot&amp;trade; 64-Bit Server VM (1.8.0 25.0-b70)&lt;/li&gt;
&lt;li&gt;メモリ: 4GB&lt;/li&gt;
&lt;li&gt;Apache Solr-4.10.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solrを起動する&#34;&gt;Solrを起動する&lt;/h2&gt;

&lt;p&gt;SolrはWebアプリケーションの形になっています。
ZIPファイルをダウンロードして解凍すると、distフォルダにWARファイルが入っているので、
これをアプリケーションサーバにデプロイすれば良さそうですが、
今回はexampleフォルダにあるstart.jarを単独起動させます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar start.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動するとログが出力されて分かるのですが、Jettyを内包しているようです。
数秒で起動するので、下記URLにアクセスして起動していることを確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:8983/solr/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;文書登録&#34;&gt;文書登録&lt;/h2&gt;

&lt;p&gt;Solrを紹介しているサイトを確認すると、XMLファイルを読み込ませてインデックスを作成する例が多く見つかります。
ですが、実際の業務としてはOfficeファイルやPDFなどのファイルの内容をインデックス化したいという要求の方が多いので、
XMLではなく、それらのファイルを読み込ませてインデックスを作ってみることにします。
おそらく起動したSolr管理画面からもファイルの登録ができると思うのですが、
今回はJavaで書いたプログラムからファイルの登録を実行します。&lt;/p&gt;

&lt;p&gt;JavaからSolrにアクセスするにはApache Solrjというライブラリが必要です。
これはMavenに登録されているのでそこから取得します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.solr&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;solr-solrj&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.10.0&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SolrjからPDFファイルを登録するサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.solr.client.solrj.SolrServer;
import org.apache.solr.client.solrj.impl.HttpSolrServer;
import org.apache.solr.client.solrj.request.AbstractUpdateRequest;
import org.apache.solr.client.solrj.request.ContentStreamUpdateRequest;

import java.io.File;

public class App
{
    public static void main(String... args) throws Exception
    {
        final SolrServer solr = 
                new HttpSolrServer(&amp;quot;http://localhost:8983/solr/collection1&amp;quot;);
        final ContentStreamUpdateRequest update = 
                new ContentStreamUpdateRequest(&amp;quot;/update/extract&amp;quot;);
        update.addFile(
                new File(&amp;quot;/Users/Katsumi/Downloads/javamagazinevol16.pdf&amp;quot;), 
                &amp;quot;application/pdf&amp;quot;);
        update.setParam(&amp;quot;literal.id&amp;quot;, &amp;quot;javamagazinevol16.pdf&amp;quot;);
        update.setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);
        solr.request(update);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょうど手元に以前ダウンロードした「Javaマガジン日本語版 vol16」があったので、
それを登録しています。実行するとわかるのですがcommons-loggingのクラスがない旨を表すエラーがでます。
Mavenの依存ライブラリには含まれていないようなのですが、内部で使っているのでしょうね。
しょうがないので、commons-loggingも取得するようにMavenに追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再度実行すると今度はエラーも発生せずに正常に終了しました。
登録したPDFファイルは66ページ、24.6MBですが、数秒で登録が終わりました。&lt;/p&gt;

&lt;h2 id=&#34;文書検索&#34;&gt;文書検索&lt;/h2&gt;

&lt;p&gt;以下のURLを実行して登録されていることを確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:8983/solr/collection1/select?q=ストリーム&amp;amp;wt=xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PDFファイル中に「ストリーム」という単語があるので、これを検索条件（q）としています。
また、検索結果フォーマット（wt）はxmlを指定します。他にjsonも指定できるようです。
検索結果は以下のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;response&amp;gt;
  &amp;lt;lst name=&amp;quot;responseHeader&amp;quot;&amp;gt;
    &amp;lt;int name=&amp;quot;status&amp;quot;&amp;gt;0&amp;lt;/int&amp;gt;
    &amp;lt;int name=&amp;quot;QTime&amp;quot;&amp;gt;1&amp;lt;/int&amp;gt;
    &amp;lt;lst name=&amp;quot;params&amp;quot;&amp;gt;
      &amp;lt;str name=&amp;quot;q&amp;quot;&amp;gt;ストリーム&amp;lt;/str&amp;gt;
      &amp;lt;str name=&amp;quot;wt&amp;quot;&amp;gt;xml&amp;lt;/str&amp;gt;
    &amp;lt;/lst&amp;gt;
  &amp;lt;/lst&amp;gt;
  &amp;lt;result name=&amp;quot;response&amp;quot; numFound=&amp;quot;1&amp;quot; start=&amp;quot;0&amp;quot;&amp;gt;
    &amp;lt;doc&amp;gt;
      &amp;lt;arr name=&amp;quot;links&amp;quot;&amp;gt;...&amp;lt;/arr&amp;gt;
      &amp;lt;str name=&amp;quot;id&amp;quot;&amp;gt;javamagazinevol16.pdf&amp;lt;/str&amp;gt;
      &amp;lt;date name=&amp;quot;last_modified&amp;quot;&amp;gt;2014-05-21T07:44:33Z&amp;lt;/date&amp;gt;
      &amp;lt;arr name=&amp;quot;title&amp;quot;&amp;gt;
        &amp;lt;str/&amp;gt;
      &amp;lt;/arr&amp;gt;
      &amp;lt;arr name=&amp;quot;content_type&amp;quot;&amp;gt;
        &amp;lt;str&amp;gt;application/pdf&amp;lt;/str&amp;gt;
      &amp;lt;/arr&amp;gt;
      &amp;lt;arr name=&amp;quot;content&amp;quot;&amp;gt;
        &amp;lt;str&amp;gt;
          JAVA //MARCH/APRIL 2014 / 注目のキーワ ドー： ラムダ式 / Nashorn / 日付と時間 / 組込み
          ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次回はJavaから文書検索をしてみたいと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Change at Sep 6, 2014&lt;/strong&gt;&lt;br /&gt;
誤字脱字を修正。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WildFlyでJdbcRealm</title>
      <link>https://kokuzawa.github.io/blog/2014/08/23/wildflydejdbcrealmwoshe-ding-suru/</link>
      <pubDate>Sat, 23 Aug 2014 15:50:18 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/08/23/wildflydejdbcrealmwoshe-ding-suru/</guid>
      <description>

&lt;p&gt;今回は WildFly 8.0.0.Final を利用してJdbcRealmを試してみます。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;wildfly-の設定&#34;&gt;WildFly の設定&lt;/h2&gt;

&lt;p&gt;WildFly 8.0.0.Final に JDBCRealm を構築します。&lt;br /&gt;
まず、PostgreSQL を使ってとてもシンプルなテーブル構成を作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_28.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Security Domain を追加します。
追加は WildFly の GUI コンソールから行います。
追加する Security Domain は Name: app, Cache Type: default です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_29.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;追加した Security Domain を開き、Login Module を追加します。
追加する Login Modile は Code: Database, Flg: required です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_30.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;追加した Login Module に Module Option を追加します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_31.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;追加する Module Option は下記表になります。
dsJndiName で指定するのは事前に登録した Datasource です。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Key&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dsJndiName&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java:/jdbc/realmSample&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;hashAlgorithm&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SHA-256&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;hashEncoding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;HEX&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;principalsQuery&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SELECT password FROM accounts WHERE email = ?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;rolesQuery&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SELECT r.rolename, &amp;lsquo;Roles&amp;rsquo; FROM roles r, accounts a WHERE r.accountid = a.accountid AND a.email = ?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;データの投入&#34;&gt;データの投入&lt;/h2&gt;

&lt;p&gt;最初に作ったテーブルにデータを投入します。
パスワードに設定するのは、SHA256で暗号化、HEXエンコードした文字列です。
ここでは &amp;lsquo;test&amp;rsquo; という文字列をパスワードにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO accounts (email, password) VALUES (&#39;hoge&#39;, &#39;9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08&#39;);
INSERT INTO roles (rolename, accountid) VALUES (&#39;MEMBER&#39;, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jboss-web-xml-の設定&#34;&gt;jboss-web.xml の設定&lt;/h2&gt;

&lt;p&gt;追加した Security Domain を利用するために、jboss-web.xml へ Security Domain を指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;security-domain&amp;gt;app&amp;lt;/security-domain&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;web-xml-の設定&#34;&gt;web.xml の設定&lt;/h2&gt;

&lt;p&gt;BASIC認証が行われるように web.xml を設定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;security-role&amp;gt;
    &amp;lt;role-name&amp;gt;MEMBER&amp;lt;/role-name&amp;gt;
&amp;lt;/security-role&amp;gt;

&amp;lt;security-constraint&amp;gt;
    &amp;lt;web-resource-collection&amp;gt;
        &amp;lt;web-resource-name&amp;gt;Member Resource&amp;lt;/web-resource-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/web-resource-collection&amp;gt;
    &amp;lt;auth-constraint&amp;gt;
        &amp;lt;role-name&amp;gt;MEMBER&amp;lt;/role-name&amp;gt;
    &amp;lt;/auth-constraint&amp;gt;
&amp;lt;/security-constraint&amp;gt;

&amp;lt;login-config&amp;gt;
    &amp;lt;auth-method&amp;gt;BASIC&amp;lt;/auth-method&amp;gt;
    &amp;lt;realm-name&amp;gt;Authentication&amp;lt;/realm-name&amp;gt;
&amp;lt;/login-config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これですべての設定が完了です。
WildFly にアプリをデプロイしてアクセスするとBASIC認証のダイアログが表示されると思います。
そこで事前に登録したアカウント情報を入力すると認証に成功するはずです。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Oct 28, 2014 脱字修正&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Jenkins用のpom.xmlの基本設定</title>
      <link>https://kokuzawa.github.io/blog/2014/05/24/jenkinsnishi-waserupom-dot-xmlfalseji-ben-she-ding/</link>
      <pubDate>Sat, 24 May 2014 16:30:10 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/05/24/jenkinsnishi-waserupom-dot-xmlfalseji-ben-she-ding/</guid>
      <description>

&lt;p&gt;だんだんと暑くなってきた先週、Java7 を導入できることになって大喜びして
IntelliJ IDEA の Inspect Code を使って Java7 に対応するコードに一括変換をした月曜日、
今年は良い夏を迎えられそうだと思っていたら、OS が Java7 をサポートしてなくてコードを
Java6 にダウングレードするという、モチベーションがだだ下がりな作業したところです。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;ただ Java6 にダウングレードするというものやってられないので、
Eclipse の Web アプリ構成のプロジェクトを Maven 構成のプロジェクトに置き換えようと考えました。
Maven 構成に変えるのはフォルダの位置を変更するだけなのでとても簡単で、
かつ、ライブラリはビルド時に取得してくれるから、今までのように VCS に jar ファイルも一緒にコミットする必要がなくなり、
アプリのリソース自体も小さくなってチェックアウト（クローン）が速くできるようになったりなどメリットが一杯です。&lt;/p&gt;

&lt;p&gt;ビルドに ant を使っているので、Jenkins 上でも ant で動作させています。
今度は Maven を使うようにするので、Maven 用に設定を書き換える必要があります。
やりたいことは、ユニットテスト、カバレッジ、PMD、CPD、Findbugs を実行することです。
ant での設定は下記の本を参考にすると簡単なのですが、この本は Maven の設定に詳しくありません。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?t=moonwhaleblog-22&amp;o=9&amp;p=8&amp;l=as1&amp;asins=4774148911&amp;ref=qf_sp_asin_til&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;m=amazon&amp;lc1=0000FF&amp;bc1=FFFFFF&amp;bg1=FFFFFF&amp;f=ifr&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;そこで色々なサイトを参考に自分で pom.xml を構築しようとしたのですが、
記述が古かったり、書き方もまちまち、さらには Maven Plugin のバージョンで動作が変わってしまったりなど、
どれを参考にしたら良いのか判断が難しい。
あーでもない、こーでもないとやっているうちに、ユニットテスト、カバレッジ、PMD、CPD、Findbugs を
実行できるようになったので公開したいと思います。&lt;/p&gt;

&lt;p&gt;pom.xml の完全なファイルは&lt;a href=&#34;https://bitbucket.org/kokuzawa/pomtemplate&#34;&gt;こちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;指定したテストケースだけ実行&#34;&gt;指定したテストケースだけ実行&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
	&amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;2.7.2&amp;lt;/version&amp;gt;
	    &amp;lt;configuration&amp;gt;
		&amp;lt;systemPropertyVariables&amp;gt;
		    &amp;lt;jdbc.driverClassName&amp;gt;${jdbc.driverClassName}&amp;lt;/jdbc.driverClassName&amp;gt;
		    &amp;lt;jdbc.url&amp;gt;${jdbc.url}&amp;lt;/jdbc.url&amp;gt;
		    &amp;lt;jdbc.username&amp;gt;${jdbc.username}&amp;lt;/jdbc.username&amp;gt;
		    &amp;lt;jdbc.password&amp;gt;${jdbc.password}&amp;lt;/jdbc.password&amp;gt;
		&amp;lt;/systemPropertyVariables&amp;gt;
		&amp;lt;includes&amp;gt;
		    &amp;lt;include&amp;gt;**/*Test.java&amp;lt;/include&amp;gt;
		&amp;lt;/includes&amp;gt;
	    &amp;lt;/configuration&amp;gt;
	&amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定したテストクラスだけを実行するために &lt;code&gt;maven-surefire-plugin&lt;/code&gt; を利用します。
&lt;code&gt;systemPropertyVariables&lt;/code&gt; の部分はおまけで、profiles からテスト用の DB 設定を取得しています。
本質は &lt;code&gt;includes&lt;/code&gt; の部分で、ここに実行したいテストクラスを記述します。&lt;/p&gt;

&lt;h2 id=&#34;カバレッジの取得&#34;&gt;カバレッジの取得&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
	&amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;cobertura-maven-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;2.5.2&amp;lt;/version&amp;gt;
	    &amp;lt;configuration&amp;gt;
		&amp;lt;check/&amp;gt;
		&amp;lt;formats&amp;gt;
		    &amp;lt;format&amp;gt;xml&amp;lt;/format&amp;gt;
		&amp;lt;/formats&amp;gt;
	    &amp;lt;/configuration&amp;gt;
	&amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;カバレッジ取得に &lt;code&gt;cobertura-maven-plugin&lt;/code&gt; を利用します。
&lt;code&gt;check&lt;/code&gt; タグは必須なのですが、デフォルトの設定値を変える必要はないため空で宣言しています。
また、&lt;code&gt;formats&lt;/code&gt; に xml を指定していますが、何も指定していないと site に表示する html が生成されます。
Jenkins で解析するので xml を出力するように指定します。&lt;/p&gt;

&lt;h2 id=&#34;pmd-の取得&#34;&gt;PMD の取得&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
	&amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;maven-jxr-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;2.3&amp;lt;/version&amp;gt;
	&amp;lt;/plugin&amp;gt;
	&amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;maven-pmd-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
	&amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;

&amp;lt;reporting&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;maven-jxr-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;2.3&amp;lt;/version&amp;gt;
	&amp;lt;/plugin&amp;gt;
	&amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;maven-pmd-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
	&amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/repoting&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PMD を取得するためのプラグインを指定します。
&lt;code&gt;maven-jxr-plugin&lt;/code&gt; は PMD 取得に直接関係ないのですが、下記のサイトでの WORNING を回避するために指定しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://maven.40175.n5.nabble.com/PMD-plugin-source-xref-not-generated-unless-JXR-runs-first-td2622198.html&#34;&gt;PMD plugin: source xref not generated unless JXR runs first&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CPD は PMD と同じ設定で生成することができるので、個別の設定は必要ありません。&lt;/p&gt;

&lt;h2 id=&#34;findbugs-の実行&#34;&gt;Findbugs の実行&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
	&amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;findbugs-maven-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;2.5.4&amp;lt;/version&amp;gt;
	    &amp;lt;configuration&amp;gt;
		&amp;lt;effort&amp;gt;Max&amp;lt;/effort&amp;gt;
		&amp;lt;xmlOutput&amp;gt;true&amp;lt;/xmlOutput&amp;gt;
	    &amp;lt;/configuration&amp;gt;
	&amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;

&amp;lt;reporting&amp;gt;
    &amp;lt;plugins&amp;gt;
	&amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;findbugs-maven-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;2.5.4&amp;lt;/version&amp;gt;
	&amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/reporting&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Findbugs を実行するために &lt;code&gt;findbugs-maven-plugin&lt;/code&gt; を利用します。
&lt;code&gt;effort&lt;/code&gt; は分析レベルです。ここでは Max を指定していますが、何も指定しない（Default）でも良いかもしれません。
あとは Jenkins で解析するので xml での出力が必要です。&lt;/p&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;Maven-3.2.1 で実行しようとすると下記サイトでのエラーが出ることがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://issues.jenkins-ci.org/browse/JENKINS-22252&#34;&gt;Maven 3.2.1: IllegalAccessError on AbstractMapBasedMultimap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理由はコメントに書いてある通りなのですが、Jenkins で利用している Guava のバージョンと Maven の Guava のバージョンが
一致していないために発生する問題のようです。なので、最新の Maven ではなく一つ古い 3.2.1 を使う必要があるかもしれません。&lt;/p&gt;

&lt;p&gt;ちなみに、Jenkins での Maven の goal は下記を指定しています。
（cobertura でテストクラスのコンパイルも行われるのですが、Java6 だと JDK のバグでコンパイラが止まってしまうので、
あえて &lt;code&gt;compile&lt;/code&gt; を呼び出しています）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;clean compile cobertura:cobertura pmd:pmd pmd:cpd findbugs:findbugs javadoc:javadoc&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Change at May 29, 2014&lt;/strong&gt;&lt;br /&gt;
resource ゴールが呼ばれないため、Jenkinsで指定している goal のうち、compiler:compile compiler:testCompile を compile に変更。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初めてのAnglarJS</title>
      <link>https://kokuzawa.github.io/blog/2014/05/10/chu-metefalseangularjs/</link>
      <pubDate>Sat, 10 May 2014 18:50:20 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/05/10/chu-metefalseangularjs/</guid>
      <description>

&lt;p&gt;AngularJS + JAX-RS + JPA でアプリを作ってます。
今回 AngularJS を初めて使っているんですがとても便利ですね。
どの辺りがと言われると、具体的に答えられるほど使い込んでいないので答えに窮するのですが、
今分かっている範囲では、テストが簡単にできるのが良い感じです。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;

&lt;p&gt;AngularJS を利用するためには当たり前ですが、jsファイルを呼び出す必要があります。
これは AngularJS の&lt;a href=&#34;https://angularjs.org&#34;&gt;公式サイト&lt;/a&gt;からダウンロードできるので、そこから取得しました。
ダウンロードしたファイルを任意の場所に配置し、下記を &lt;code&gt;head&lt;/code&gt; タグの間に追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;angular.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あと、下記の &lt;code&gt;ng-app&lt;/code&gt; を忘れずに &lt;code&gt;html&lt;/code&gt; タグに追加します。
これは、このページが AngularJS のページだよと宣言するためのディレクティブだそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html ng-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;初期値の設定&#34;&gt;初期値の設定&lt;/h2&gt;

&lt;p&gt;AngularJS は &lt;code&gt;ng-repeat&lt;/code&gt; というディレクティブを利用することで繰り返し処理をすることができます。
繰り返し処理で出力するデータは下記のように &lt;code&gt;ng-init&lt;/code&gt; を利用して初期値を設定することができます。
まあ、下記のコードだと繰り返し処理をさせる意味はあまりないのですが&amp;hellip;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&amp;quot;angular.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-init=&amp;quot;names = [&#39;Taro&#39;, &#39;Jiro&#39;, &#39;Hanako&#39;]&amp;quot;&amp;gt;
      &amp;lt;div ng-repeat=&amp;quot;name in names&amp;quot;&amp;gt;
        {{name}}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると以下のような画面が表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Taro
Jiro
Hanako
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とても簡単です。
ここで表示している Taro, Jiro, Hanako の値を API から取得して表示しようとした場合は下記のようなコードになります。&lt;/p&gt;

&lt;p&gt;{% raw %}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html ng-app=&amp;quot;myApp&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&amp;quot;angular.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;angular-resource.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      var myApp = angular.module(&#39;myApp&#39;, [&#39;ngResource&#39;]);

      myApp.factory(&#39;testService&#39;, [&#39;$resource&#39;, function($resource)
      {
        return $resource(&#39;/test/rest/names&#39;, {query: {method: &#39;GET&#39;, isArray: true}});
      }]);

      myApp.controller(&#39;myCtrl&#39;, [&#39;testService&#39;, &#39;$scope&#39;, function(testService, $scope)
      {
        $scope.names = testService.query();
      }]);
    &amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&amp;quot;myCtrl&amp;quot;&amp;gt;
      &amp;lt;div ng-repeat=&amp;quot;name in names&amp;quot;&amp;gt;
        {{name}}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% endraw %}&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;p&gt;以下のサイトを参考にしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://angularjs.org&#34;&gt;AngularJS 公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dotinstall.com/lessons/basic_angularjs&#34;&gt;ドットインストール - AngularJS入門&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Derby does not start</title>
      <link>https://kokuzawa.github.io/blog/2014/03/09/derby-does-not-start/</link>
      <pubDate>Sun, 09 Mar 2014 14:43:26 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/03/09/derby-does-not-start/</guid>
      <description>

&lt;p&gt;Java8を入れたらGlassFishに付属しているDerbyが起動できなくなっていたので、下記を&lt;code&gt;$JAVA_HONE/jre/lib/security/java.policy&lt;/code&gt;に追記しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;permission java.net.SocketPermission &amp;quot;localhost:1527&amp;quot;, &amp;quot;listen,resolve&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/seraphy/20140214&#34;&gt;Java7u51以降でApache Derbyのネットワークサーバを使う場合の設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>How to set the value in ValueChangeListener</title>
      <link>https://kokuzawa.github.io/blog/2014/02/12/how-to-set-the-value-in-valuechangelistener/</link>
      <pubDate>Wed, 12 Feb 2014 00:58:25 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/02/12/how-to-set-the-value-in-valuechangelistener/</guid>
      <description>&lt;p&gt;JSFには値が変更されたことをハンドリングするためのイベントとしてValueChangeEventが用意されています。
このイベントは、コンポーネントのValueChangeListenerによって発行されます。
ValueChangEventを利用してテキストフィールドに入力された値の検証を行っているのですが、
値が不正だった場合に、エラーを表示するのではなく正常な値を設定したい場合があります。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;このとき、単純にValueChangeListenerの中でテキストフィールドのプロパティに値を設定しても、画面には反映されません。
これは、ValueChangeEventがJSFのライフサイクルのUpdate Model Valuesフェーズの前に呼ばれるからであり、
ValueChangeListenerで設定した値はUpdate Model Valuesフェーズで入力値によって上書きされてしまうからです。&lt;/p&gt;

&lt;p&gt;これを解決するには、ValueChangeListenerにおいて、ちょっとした工夫が必要です。
以下にその例を示します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void valueChangeListener(ValueChangeEvent event)
{
    if (event.getPhaseId() == PhaseId.UPDATE_MODEL_VALUES) {
        property = &amp;quot;9:00&amp;quot;;
    }
    else {
        String value = (String) event.getNewValue();
        if (false == value.matches(&amp;quot;([0-9]{1,2}|1[0-9]|2[0-3]):[0-5][0-9]&amp;quot;) {
            event.setPhaseId(PhaseId.UPDATE_MODEL_VALUES);
            event.queue();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この例では、時間の入力に対する検証を行い、不正な値が入力された場合にデフォルト値である「9:00」を設定しています。
値の検証をUpdate Model Valuesフェーズの前に実施し、値が不正である場合には、ValueChangeEventをUpdate Model Valuesフェーズにエンキューします。
このようにすることで、Update Model Valuesフェーズでもう一度ValueChangeListenerが呼び出されます。
二度ValueChangeListenerが呼ばれることになるので、イベントのフェーズIDを判定し、
Update Model Valuesフェーズで呼ばれた場合にデフォルト値を設定することで画面にその値を反映させます。&lt;/p&gt;

&lt;p&gt;JSFは、ライフサイクルを知っていないと対処が難しい場合があるのがちょっといけてないですね&amp;hellip;。
というわけで何かの参考になれば幸いです。&lt;/p&gt;

&lt;p&gt;Enjoy !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Examples to FizzBuzz of Java8</title>
      <link>https://kokuzawa.github.io/blog/2014/02/10/examples-to-fizzbuzz-of-java8/</link>
      <pubDate>Mon, 10 Feb 2014 23:25:24 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/02/10/examples-to-fizzbuzz-of-java8/</guid>
      <description>&lt;p&gt;業務では未だJava6だし、Java7自体いつ導入されるか分からないし、Java8を本格的に使うようになるのはすごい先だと思うけど、
Java8を触っている時間がほとんどなくて、Lambdaの構文自体を忘れてしまいそうなので、ちょっとリハビリでFizzBuzzを書いた。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;FizzBuzzとはこれのことです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html&#34;&gt;CODING HORROR&lt;/a&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a program that prints the numbers from 1 to 100. But for multiples of three print &amp;ldquo;Fizz&amp;rdquo; instead of the number and for the multiples of five print &amp;ldquo;Buzz&amp;rdquo;. For numbers which are multiples of both three and five print &amp;ldquo;FizzBuzz&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;コードは下記になります。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kokuzawa/8916709.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Enjoy !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>EclipseLinkでの一意制約例外</title>
      <link>https://kokuzawa.github.io/blog/2014/01/31/entityexistsexception/</link>
      <pubDate>Fri, 31 Jan 2014 22:52:45 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/01/31/entityexistsexception/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://twitter.com/kikutaro_&#34;&gt;@kikutaro_&lt;/a&gt;さんのブログで、
EclipseLinkの一意制約例外について書かれた
「&lt;a href=&#34;http://kikutaro777.hatenablog.com/entry/2013/04/24/225439&#34;&gt;EclipseLinkで一意制約の例外を拾ってみたけど…&lt;/a&gt;」
の記事が Twitterで言及されていたので、ちょっと読んでたら&lt;code&gt;javax.persistence.EntityExistsException&lt;/code&gt;がスローされないってあって、
あれ、そうだったけ？とちょっと疑問に思ったので調べてみた。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;で、まあググると確かにスローされないって言っている人が沢山いたけど、
やっぱり自分で試してみないと気が済まないので、下記のようなコードを書いて試してみる。&lt;br /&gt;
（コードにはlombokを適用してます）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;persistence.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;persistence xmlns=&amp;quot;http://java.sun.com/xml/ns/persistence&amp;quot; version=&amp;quot;2.0&amp;quot;&amp;gt;
    &amp;lt;persistence-unit name=&amp;quot;testPU&amp;quot; transaction-type=&amp;quot;RESOURCE_LOCAL&amp;quot;&amp;gt;
        &amp;lt;provider&amp;gt;org.eclipse.persistence.jpa.PersistenceProvider&amp;lt;/provider&amp;gt;
        &amp;lt;class&amp;gt;entity.Account&amp;lt;/class&amp;gt;
        &amp;lt;properties&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.driver&amp;quot; value=&amp;quot;org.apache.derby.jdbc.ClientDriver&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.url&amp;quot; value=&amp;quot;jdbc:derby://localhost/test;create=true&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.user&amp;quot; value=&amp;quot;APP&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.password&amp;quot; value=&amp;quot;APP&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;eclipselink.ddl-generation&amp;quot; value=&amp;quot;drop-and-create-tables&amp;quot;/&amp;gt;
        &amp;lt;/properties&amp;gt;
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Account.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
@NoArgsConstructor
@RequiredArgsConstructor
public class Account
{
    @Getter
    @NonNull
    @Id
    private Long id;

    @Getter @Setter
    @NonNull
    private String name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AccountTest.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test(expected = EntityExistsException.class)
public void testPersist() throws Exception
{
    Account account = new Account(1L, &amp;quot;名前&amp;quot;);
    em.persist(account);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;accountテーブルには事前にid=1のデータを投入。&lt;br /&gt;
この状態で実行すると下記のようなエラーがでる。確かに&lt;code&gt;EntityExistsException&lt;/code&gt;はスローされない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javax.persistence.PersistenceException: Exception [EclipseLink-4002] (Eclipse Persistence Services - 2.5.1.v20130918-f2b9fc5): org.eclipse.persistence.exceptions.DatabaseException
Internal Exception: java.sql.SQLIntegrityConstraintViolationException: このステートメントは、ユニークまたは主キー制約、または &#39;ACCOUNT&#39; 上で定義された &#39;SQL140131234011701&#39; によって識別されるユニーク索引において重複キー値の原因となる可能性があったため、打ち切られました。
Error Code: -1
Call: INSERT INTO account (ID, NAME) VALUES (?, ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うーん、仕様としては存在しているのだから、何かが間違っているのか&amp;hellip;&lt;br /&gt;
わからないので、EclipseLinkのコードを追ってみることに。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;org.eclipse.persistence.internal.jpa.EntityManagerImpl.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {
    getActivePersistenceContext(checkForTransaction(false)).registerNewObjectForPersist(entity, new IdentityHashMap());
} catch (RuntimeException exception) {
    if (exception instanceof ValidationException) {
        throw new EntityExistsException(exception.getLocalizedMessage(), exception);
    }
    throw exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードを見る限り、&lt;code&gt;EntityManager#persist()&lt;/code&gt;で&lt;code&gt;EntityExistsException&lt;/code&gt;をスローしているように見える。
この&lt;code&gt;ValidationException&lt;/code&gt;とは何なのか？どこから来たんだろう&amp;hellip;。
というわけでここからどんどん辿って行くと、最終的にフラグが立っている場合にチェックしていることが分かる。
で、そのフラグがどこで立つのかをさらに辿って行くと、&lt;code&gt;eclipselink.validate-existence&lt;/code&gt;というプロパティを参照している様子。&lt;/p&gt;

&lt;p&gt;ああ、これはpersistence.xmlで設定できるやつだ、ということで下記をpersistence.xmlに設定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;property name=&amp;quot;eclipselink.validate-existence&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一回実行してみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javax.persistence.EntityExistsException: 
Exception Description: Cannot persist detached object [Account(id=1, name=名前)]. 
Class&amp;gt; entity.Account Primary Key&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でた！確証を得るためにEclipseLinkのドキュメントを見てみる。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.eclipse.org/eclipselink/documentation/2.5/jpa/extensions/p_validate_existence.htm&#34;&gt;EclipseLink&lt;/a&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use the eclipselink.validate-existence persistence property configures to specify if EclipseLink should verify an object&amp;rsquo;s existence on persist().&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「eclipselink.validate-existenceプロパティを使用して、EclipseLinkがpersist()でオブジェクトの存在を検証するかどうかを指定します。」
ということなのでこれで合っているようだけど、デフォルトがfalseなので検証しないようだ。
ただ、ちょっと気になるのは使用方法の部分、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;EclipseLink will throw an error if a validated object is not in the persistence context.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;not in the persistence context ってことは存在しない場合にエラーがスローされるの？&lt;br /&gt;
この記述あってるのかなぁ？英語は得意じゃないので解釈が間違っているのかもしれない。
あ、persistence context に存在しないってことは、DBに存在していてfindしていなければエラーになるってことかな。&lt;/p&gt;

&lt;p&gt;Enjoy !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>java7u51 Web Startセキュリティアップデートの回避方法</title>
      <link>https://kokuzawa.github.io/blog/2014/01/16/java7u51-web-start-security-update-workaround/</link>
      <pubDate>Thu, 16 Jan 2014 07:08:26 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2014/01/16/java7u51-web-start-security-update-workaround/</guid>
      <description>

&lt;p&gt;1月14日にJava7u51がリリースされました。
このアップデートによってセキュリティが強化されて、署名のないアプレットが起動できなくなりました。
また署名があっても、ユーザ独自の署名の場合ではその証明書をクライアントにインポートしておかないと、
同じく起動することができないようです。&lt;/p&gt;

&lt;p&gt;あまり頻繁に行う作業ではないので、手順をまとめておきたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;1-manifest-mfの編集&#34;&gt;1. MANIFEST.MFの編集&lt;/h2&gt;

&lt;p&gt;jarファイル内のMANIFEST.MFに下記を追記します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Permissions: all-permissions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mavenを利用している場合は、下記をpom.xmlに追加することで、
ビルド時にMANIFEST.MFに追加することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;archive&amp;gt;
                    &amp;lt;manifestEntries&amp;gt;
                        &amp;lt;Permissions&amp;gt;all-permissions&amp;lt;/Permissions&amp;gt;
                        &amp;lt;Codebase&amp;gt;*&amp;lt;/Codebase&amp;gt;
                    &amp;lt;/manifestEntries&amp;gt;
                &amp;lt;/archive&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Antであれば下記で同様のことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;target name=&amp;quot;dist&amp;quot;&amp;gt;
    &amp;lt;jar destfile=&amp;quot;${basedir}/out/sample.jar&amp;quot; basedir=&amp;quot;${basedir}/out/classes/&amp;quot;&amp;gt;
        &amp;lt;manifest&amp;gt;
            &amp;lt;attribute name=&amp;quot;Permissions&amp;quot; value=&amp;quot;all-permissions&amp;quot;/&amp;gt;
            &amp;lt;attribute name=&amp;quot;Codebase&amp;quot; value=&amp;quot;*&amp;quot;/&amp;gt;
        &amp;lt;/manifest&amp;gt;
    &amp;lt;/jar&amp;gt;
&amp;lt;/target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-jnlpファイルの編集&#34;&gt;2. jnlpファイルの編集&lt;/h2&gt;

&lt;p&gt;jnlpファイルに下記を追記します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;security&amp;gt;
    &amp;lt;all-permissions/&amp;gt;
&amp;lt;/security&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-keystoreの生成&#34;&gt;3. keystoreの生成&lt;/h2&gt;

&lt;p&gt;keystoreを生成します。[]内は任意の文字列を指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -selfcert -alias [sample] -genkey -keystore [sample.keystore] -validity [3650]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-証明書の生成&#34;&gt;4. 証明書の生成&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;keytool -export -keystore [sample.keystore] -alias [sample] -file [sample.csr]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-jarファイルの署名&#34;&gt;5. jarファイルの署名&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -keystore [sample.keystore] [sample.jar] [sample]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-証明書のインポート&#34;&gt;6. 証明書のインポート&lt;/h2&gt;

&lt;p&gt;証明書をインポートすることでAppletを起動できるようになります。&lt;br /&gt;
Windowsの場合は、「コントロールパネル」 -&amp;gt; 「Java」 -&amp;gt; 「セキュリティタブ」 -&amp;gt; 「証明書の管理」と選択、
ユーザタブで証明書タイプを「署名者のCA」を選び、sample.csrをインポートします。&lt;/p&gt;

&lt;p&gt;これでWeb StartでAppletを起動すると、
警告ダイアログが表示されるようになります。&lt;/p&gt;

&lt;p&gt;Enjoy !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAX-RSで複数ファイルをアップロードするには</title>
      <link>https://kokuzawa.github.io/blog/2013/12/22/jaxrs-upload-multiple-files/</link>
      <pubDate>Sun, 22 Dec 2013 09:20:55 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/12/22/jaxrs-upload-multiple-files/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/145&#34;&gt;Java Advent Calendar 2013&lt;/a&gt;の22日目の記事です。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/nagaseyasuhito&#34;&gt;@nagaseyasuhito&lt;/a&gt;さんの「&lt;a href=&#34;http://www.nagaseyasuhito.net/2013/12/21/368/&#34;&gt;mvn siteのtips三連発&lt;/a&gt;」でした。&lt;br /&gt;
明日は monzou さんです。&lt;/p&gt;

&lt;p&gt;ファイルアップロードを実現するために何を使っていますか？&lt;br /&gt;
私はもっぱらJAX-RSを使っています。&lt;/p&gt;

&lt;p&gt;ファイルアップロードはAX-RSの仕様には含まれていないのですが、ほとんどの実装でサポートされているようです。
その実装の中から、今回はJerseyを使った複数ファイルのアップロードについて紹介しようかと思います。&lt;/p&gt;

&lt;p&gt;今回利用したJerseyはGlassFish4に含まれているものを利用します。&lt;br /&gt;
ライブラリとしては以下のjarになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jersey-media-multipart&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.4.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さっそくHTMLから。複数のファイルをアップロードするので同じnameのfileフィールドを用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;/&amp;gt;
    &amp;lt;title&amp;gt;JAX-RS upload multiple files example&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;rest/upload/multipleFiles&amp;quot;&amp;gt;
        &amp;lt;div&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot;/&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot;/&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Upload&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、実際にリクエストを受け取るJavaのコード。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package org.katsumi.resources;

import org.glassfish.jersey.media.multipart.FormDataBodyPart;
import org.glassfish.jersey.media.multipart.FormDataParam;

import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

/**
 * 複数ファイルのアップロードサンプル
 * @author Katsumi
 * @since 2013/12/21
 */
@Path(&amp;quot;/upload&amp;quot;)
public class Upload
{
    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Produces(MediaType.TEXT_PLAIN)
    @Path(&amp;quot;/multipleFiles&amp;quot;)
    public String upload(@FormDataParam(&amp;quot;file&amp;quot;)List&amp;lt;FormDataBodyPart&amp;gt; bodyParts) throws IOException
    {
        for (FormDataBodyPart part : bodyParts) {
            Files.copy(part.getValueAs(InputStream.class),
                    Paths.get(&amp;quot;/Users/Katsumi/Downloads&amp;quot;, part.getFormDataContentDisposition().getFileName()));
        }
        return &amp;quot;finish!!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fileフィールドの値は、@FormDataParam(&amp;ldquo;file&amp;rdquo;)アノテーションを引数につけることで受け取ることができます。
また、今回は複数のファイルを受け取るので、引数の方を&lt;code&gt;java.util.List&lt;/code&gt;にしています。
&lt;code&gt;FormDataBodyPart&lt;/code&gt;に実際のファイルの情報が含まれているので、ここから必要なものを取り出します。&lt;/p&gt;

&lt;p&gt;ネットで検索すると、ファイルのアップロードを受け取る際に、
&lt;code&gt;InputStream&lt;/code&gt;と&lt;code&gt;FormDataContentDisposition&lt;/code&gt;の2つをパラメータとして受け取るサンプルが良く見つかりますが、
&lt;code&gt;FormDataBodyPart&lt;/code&gt;にはこの2つの情報が含まれているので、こちらを利用した方が良いのではないかと思います。&lt;/p&gt;

&lt;p&gt;ちなみに、&lt;code&gt;FormDataBodyPart&lt;/code&gt;から&lt;code&gt;InputStream&lt;/code&gt;を取り出すには&lt;code&gt;getValueAs(InputStream.class)&lt;/code&gt;を利用します。&lt;br /&gt;
ここがちょっと分かりにくいところかもしれません。&lt;/p&gt;

&lt;p&gt;あと、このコードだと、日本語ファイル名の場合に文字化けしてしまうので適切なエンコードが必要になりますが、
文字コードの変換部分は今回の本質的な部分ではないので割愛します。&lt;/p&gt;

&lt;p&gt;もう一点、今回の実装で注意する部分があります。&lt;br /&gt;
JAX-RSのリソースクラスをweb.xmlで登録しているのですが、マルチパートを処理するに当たり登録対象として
&lt;code&gt;org.glassfish.jersey.media.multipart.MultiPartFeature&lt;/code&gt;クラスを含める必要あるようです。
ですので、web.xmlの該当部分は下記のような宣言としています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;MyApplication&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.glassfish.jersey.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;jersey.config.server.provider.classnames&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;
            org.katsumi.resources.Upload,
            org.glassfish.jersey.media.multipart.MultiPartFeature
        &amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全なコードは&lt;a href=&#34;https://bitbucket.org/kokuzawa/jaxrs-rs-upload-multiple-files/src&#34;&gt;Bitbacket&lt;/a&gt;にアップしています。&lt;/p&gt;

&lt;h2 id=&#34;ちょっと発展&#34;&gt;ちょっと発展&lt;/h2&gt;

&lt;p&gt;HTML5ではファイルインプットフィールドにmultiple属性が追加されました。&lt;br /&gt;
これを使うと、一つのファイルフィールドで複数のファイルを設定できるようになります。&lt;/p&gt;

&lt;p&gt;HTMLをmultipleに変更します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;/&amp;gt;
    &amp;lt;title&amp;gt;JAX-RS upload multiple files example&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;post&amp;quot; 
          action=&amp;quot;rest/upload/multipleFiles&amp;quot;&amp;gt;
        &amp;lt;div&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot; multiple=&amp;quot;multiple&amp;quot;/&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Upload&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルを複数選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_27.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Uploadボタンをクリックするとファイルが無事アップロードできました。
Javaのコードの修正は必要ないですね。当たり前と言えば当たり前なのですが&amp;hellip; :P&lt;/p&gt;

&lt;p&gt;ファイルアップロードというと面倒な処理を書かないといけないと思うかもしれませんが、
JAX-RSというかJerseyを利用すると、このように簡単にアップロードを行うことができます。&lt;/p&gt;

&lt;p&gt;皆さんも試してみてはいかがでしょうか？&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JSF 2.2 でさらに便利になったMarkupを使ってみよう</title>
      <link>https://kokuzawa.github.io/blog/2013/12/18/jsf-2-dot-2-markup/</link>
      <pubDate>Tue, 17 Dec 2013 00:12:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/12/18/jsf-2-dot-2-markup/</guid>
      <description>

&lt;p&gt;この記事は、&lt;a href=&#34;http://www.adventar.org/calendars/152&#34;&gt;Java EE Advent Calendar 2013&lt;/a&gt;の18日目の記事です。&lt;br /&gt;
昨日は &lt;a href=&#34;https://twitter.com/yumix_h&#34;&gt;@yumix_h&lt;/a&gt; さんの&lt;a href=&#34;http://yumix.hatenablog.jp/entry/2013/12/17/235838&#34;&gt;私がJava EE開発の現場から学んだこと&lt;/a&gt;でした。&lt;br /&gt;
明日は誕生日の &lt;a href=&#34;https://twitter.com/aoetk&#34;&gt;@aoetk&lt;/a&gt; さんです。&lt;/p&gt;

&lt;p&gt;みなさんJSF使ってますか？&lt;br /&gt;
JSFってちょっと取っ付きにくいところがありますよね。でもそんなJSFもバージョンが2.2になって、
ちょっと良い感じになってきたので使ってみませんか、
ということでJSFのマークアップについて書いてみたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;デザイナーとプログラマの作業の分担&#34;&gt;デザイナーとプログラマの作業の分担&lt;/h2&gt;

&lt;p&gt;JSFはデザイナーとプログラマで作業が分担できるということを良く聞きます。
デザイナーを雇うほど大きなプロジェクトでJSFを使ったことがないし、
分担しているということもあまり見聞きしませんが、実際この分担というのはどういうことなんでしょう？&lt;/p&gt;

&lt;p&gt;デザイナーはHTMLは分かりますがJSFはわかりません。&lt;br /&gt;
プログラマはHTMLもJSFも分かりますが、デザインセンスはそれを専属でやっているデザイナーのほうに
一日の長があると思うので、素直にデザインは任せた方が良いでしょう。&lt;/p&gt;

&lt;p&gt;このようにHTMLしか分からない人が、HTMLに注力できるようにするには、
そのファイルがHTMLとして認識、つまりAPサーバーを経由しなくても、ブラウザでレイアウトが表示できる必要があります。
昔のJSPのように、JSPのタグやスクリプトレットで動的にレイアウトをするようにしていると、
ブラウザでレイアウトが表示できないのでダメということですね。&lt;/p&gt;

&lt;p&gt;JSFはFaceletsというテンプレートエンジンを取り込んでいるので、
特別なファイルではなく、XHTMLとして画面を作ることができます。
そのため、JSFのコンポーネントを埋め込まなければ、このままブラウザで表示することができます。&lt;/p&gt;

&lt;p&gt;ですが、何も埋め込まないのでは静的なHPと何も変わらないので、
JSFのコンポーネントを埋め込んでいく必要があり、下記のようなコンポーネントを埋め込んでしまうと、
デザイナーが理解できない状態、ブラウザでレイアウトを確認できない状態になってしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h:commandButton value=&amp;quot;OK&amp;quot; action=&amp;quot; #{managedBean.doAction}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ではどうしたら良いのでしょう？&lt;/p&gt;

&lt;h2 id=&#34;jsf-2-1&#34;&gt;JSF 2.1&lt;/h2&gt;

&lt;p&gt;JSF 2.1では、例えば下記のようにHTMLのタグにJSFのコンポーネント名を設定することによって、
JSFのコンポーネントとして認識させることができます。もちろんJSF 2.2でもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot; jsfc=&amp;quot;h:commandButton&amp;quot; action=&amp;quot;#{managedBean.doAction}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをブラウザで表示してみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;h:commandButtonの方は見事に表示されませんが、jsfc属性で書いた方は普通のボタンとして表示されています。&lt;/p&gt;

&lt;h2 id=&#34;jsf-2-2&#34;&gt;JSF 2.2&lt;/h2&gt;

&lt;p&gt;jsfc属性でJSFコンポーネントをHTMLとして認識させるのには十分でしたが、
それぞれのJSFコンポーネント名をいちいち記載するのは面倒でした。コンポーネント名を正確に覚えていなければならないし&amp;hellip;。
JSF 2.2ではそこがさらに改善され、下記のようにコンポーネント名を書かなくても、JSFコンポーネントとして認識してくれるようになりました。
namespaceは&lt;code&gt;xmlns:jsf=&amp;quot;http://xmlns.jcp.org/jsf&amp;quot;&lt;/code&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;OK&amp;quot; jsf:action=&amp;quot;#{managedBean.doAction}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;http://docs.oracle.com/javaee/7/tutorial/doc/&#34;&gt;Java EE 7 Tutorial&lt;/a&gt;を参考にしてください。&lt;/p&gt;

&lt;h2 id=&#34;ちょっと発展&#34;&gt;ちょっと発展&lt;/h2&gt;

&lt;p&gt;ここまでで、JSFコンポーネントのマークアップが簡単だということが分かりました。
ただ、ビジネスアプリでは必ず登場するテーブルのJSFコンポーネントはちょっと考え方を変えないと、
HTMLとして認識させるのは難しそうです。&lt;/p&gt;

&lt;p&gt;通常、JSFのテーブルコンポーネントは下記の形になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h:dataTable var=&amp;quot;item&amp;quot; value=&amp;quot;#{managedBean.items}&amp;quot;&amp;gt;
    &amp;lt;h:column&amp;gt;
        &amp;lt;f:facet name=&amp;quot;header&amp;quot;&amp;gt;ヘッダ１&amp;lt;/f:facet&amp;gt;
        &amp;lt;h:outputText value=&amp;quot;#{item.value1}&amp;quot;/&amp;gt;
    &amp;lt;/h:column&amp;gt;
    &amp;lt;h:column&amp;gt;
        &amp;lt;f:facet name=&amp;quot;header&amp;quot;&amp;gt;ヘッダ２&amp;lt;/f:facet&amp;gt;
        &amp;lt;h:outputText value=&amp;quot;#{item.value2}&amp;quot;/&amp;gt;
    &amp;lt;/h:column&amp;gt;
&amp;lt;/h:dataTable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ、前から思ってたんですけど、HTMLのテーブルタグに慣れていると、
ちょっと直感的ではないのですぐに組み方を忘れてしまいませんか？
僕はいつも忘れてしまいます。
それにHTMLとして表示もできません。
これをHTMLとして表示できるように、なるべくテーブルタグに近づけていきたいと思います。&lt;/p&gt;

&lt;p&gt;まずは通常のテーブルタグを書きます。ここまではデザイナーの分担ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;table&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;ヘッダ１&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;ヘッダ２&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;値１&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;値２&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここにJSFのコンポーネントを組み込んでいきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;table&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;ヘッダ１&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;ヘッダ２&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody&amp;gt;
        &amp;lt;tr jsfc=&amp;quot;ui:repeat&amp;quot; var=&amp;quot;item&amp;quot; value=&amp;quot;#{managedBean.items}&amp;quot;&amp;gt;
            &amp;lt;td&amp;gt;#{item.value1}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;#{item.value2}&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tbodyのtrタグの部分にjsfc属性で&lt;code&gt;ui:repeat&lt;/code&gt;を組み込みます。
JSF 2.2のjsfプレフックスは使えません。
こうすることでサーバー経由で表示した&lt;code&gt;h:dataTable&lt;/code&gt;と同じになるはずです。
そうそう、ちゃんとHTMLとして表示されなければ意味がないので確認してみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_26.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;分かりにくいのでボーダーを表示していますが、ちゃんとレイアウト通り表示されました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;こんな具合にJSFコンポーネントの情報を、HTMLのタグの属性として組み込めるようになっているので、
今までよりもずっとデザイナーとプログラマの作業の分担がやり易くなっていると思います。
まあ、デザイナーがいなくてもHTMLとして認識できるようにしておけば、
いちいちサーバーを起動しなくてもレイアウトが確認できるので、
JSFを使う場合は固有のタグではなく、HTMLの属性としてJSFを利用するようにした方が良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;IntelliJ IDEA 13 でもjsfプレフィックスでの補完は完全には効かなかったので、
知らないとちょっと面倒かも :P&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA 13で作るJavaFXアプリケーション</title>
      <link>https://kokuzawa.github.io/blog/2013/12/08/javafx-on-intellij-idea/</link>
      <pubDate>Sun, 08 Dec 2013 00:15:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/12/08/javafx-on-intellij-idea/</guid>
      <description>

&lt;p&gt;この記事は、&lt;a href=&#34;http://www.adventar.org/calendars/146&#34;&gt;JavaFX Advent Calendar 2013&lt;/a&gt;の8日目です。&lt;br /&gt;
昨日は&lt;a href=&#34;http://twitter.com/aoetk&#34;&gt;@aoetk&lt;/a&gt;さんの&lt;a href=&#34;http://d.hatena.ne.jp/aoe-tk/20131206/1386345344&#34;&gt;ListViewやTableViewのセルをカスタマイズする方法&lt;/a&gt;でした。&lt;br /&gt;
明日は&lt;a href=&#34;http://twitter.com/sk44_&#34;&gt;@sk44_&lt;/a&gt;さんです。&lt;/p&gt;

&lt;h2 id=&#34;祝-intellij-idea-13-リリース&#34;&gt;祝！IntelliJ IDEA 13 リリース&lt;/h2&gt;

&lt;p&gt;IntelliJ IDEA 13 が 12月3日にリリースされました！めでたいですね！&lt;br /&gt;
たぶん説明はいらないと思うので書きませんが、Java界隈の人なら知る人ぞ知る素敵なIDEです。&lt;br /&gt;
IntelliJの最新版であるver.13はJavaFXもサポートされているので、
今回はこれを使ってJavaFXの簡単なアプリケーションを作ってみたいと思います。&lt;br /&gt;
6日目の記事で&lt;a href=&#34;http://twitter.com/khasunuma&#34;&gt;@khasunuma&lt;/a&gt;さんが書かれた、
「&lt;a href=&#34;http://www.coppermine.jp/docs/programming/2013/12/efxclipse.html&#34;&gt;e(fx)clipseで作るJavaFXアプリケーション&lt;/a&gt;」のIntelliJ版ですね。&lt;/p&gt;

&lt;h2 id=&#34;早速作ってみる&#34;&gt;早速作ってみる&lt;/h2&gt;

&lt;p&gt;IntelliJを初めて起動すると以下のような画面が表示されるので、右側にある「Create New project」を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今度はプロジェクトの作成画面が表示されるので、
左側からプロジェクトのタイプとして「JavaFX Application」を選択、右側の「Project name」に任意のプロジェクト名を入れます。
今回は「HelloJavaFX」という名前にしました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finishボタンをクリックすると、プロジェクトが作られます。
プロジェクトには簡単なファイルが3つ用意されていて、それぞれ以下のような内容になっています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mainクラスがちゃんと書かれているのでこれだけでも動きます。
初めてJavaFXのアプリケーションを作る人に必要最低限のファイルとコードを示すのに十分です。
これ以上のコードがあると、本来は不必要なものまで必要だと勘違いしてしまうと思います。
ただControllerとFXMLは空っぽなので、このままだと枠しか表示されなくて面白くない&amp;hellip;。&lt;br /&gt;
ボタンをクリックしたら文字を表示するというぐらいはやりたいので、
ボタンとラベルをFXMLに追加していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?import javafx.geometry.Insets?&amp;gt;
&amp;lt;?import javafx.scene.layout.GridPane?&amp;gt;

&amp;lt;?import javafx.scene.control.Button?&amp;gt;
&amp;lt;?import javafx.scene.control.Label?&amp;gt;
&amp;lt;GridPane fx:controller=&amp;quot;sample.Controller&amp;quot;
          xmlns:fx=&amp;quot;http://javafx.com/fxml&amp;quot; alignment=&amp;quot;center&amp;quot; hgap=&amp;quot;10&amp;quot; vgap=&amp;quot;10&amp;quot;&amp;gt;

    &amp;lt;Label fx:id=&amp;quot;label&amp;quot; GridPane.columnIndex=&amp;quot;0&amp;quot; GridPane.rowIndex=&amp;quot;0&amp;quot;/&amp;gt;
    &amp;lt;Button fx:id=&amp;quot;button&amp;quot; text=&amp;quot;OK&amp;quot; onAction=&amp;quot;#click&amp;quot; 
            GridPane.columnIndex=&amp;quot;0&amp;quot; GridPane.rowIndex=&amp;quot;1&amp;quot; GridPane.halignment=&amp;quot;CENTER&amp;quot;/&amp;gt;

&amp;lt;/GridPane&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、以下のような感じでちょっとだけ入力すると補完候補が出てきます。
この辺はIntelliJ様々です。他のIDEもできるのかもしれないですけど。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次はControllerに動作を書いていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package sample;

import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.Label;

public class Controller
{
    @FXML
    private Label label;

    @FXML
    private Button button;

    public void click()
    {
        label.setText(&amp;quot;ボタンをクリックしたよ！&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードの左側に表示されているマークをクリックすると、
@FXMLでマッピングしたコンポーネントにジャンプできます。
この辺もちょっとしたことですけど嬉しい機能です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;起動する&#34;&gt;起動する&lt;/h2&gt;

&lt;p&gt;では、実際に起動してみます。
IntelliJでは右上に実行のアイコンが表示されているので、これをクリックします。
mainメソッドを持つクラスが自動的に認識されているので、特に設定は必要ないようです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表示されたウィンドウの真ん中に表示されたボタンをクリックすると、
文字が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;本当はScene Builderとか使えば、レイアウトが楽だったりするのですが、
IntelliJだけでも補完機能が優れているので、何となくレイアウトできてしまったりします。
実は今回試してみるまで、&lt;code&gt;GridPane&lt;/code&gt;のレイアウトで使う&lt;code&gt;GridPane.columnIndex&lt;/code&gt;という属性は知らなかった&amp;hellip;。
補完で出てきてくれたので、何となくこういう意味なんだろうなというノリで作れてしまいました。&lt;/p&gt;

&lt;p&gt;というわけで、他のIDEの事情はちょっと分からないのですが、
IntelliJを使うことで、以外と簡単にJavaFXのアプリが作れることが分かって頂けると嬉しいなぁと思ったりしています。&lt;/p&gt;

&lt;p&gt;最後に、IntelliJのAdvent CalendarじゃなくてJavaFXのAdvent Calendarです、念のため :P&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BootstrapのRemote Modal</title>
      <link>https://kokuzawa.github.io/blog/2013/11/13/bootstrapfalseremote-modal/</link>
      <pubDate>Wed, 13 Nov 2013 03:55:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/11/13/bootstrapfalseremote-modal/</guid>
      <description>

&lt;p&gt;bootstrap-3.0.2のRemote Modalの書き方がやっと分かった。&lt;br /&gt;
今までは.modal-bodyだけが書き変わっていたのに、バージョン3以降は中身が全部書き変わるみたい。&lt;/p&gt;

&lt;p&gt;つまり呼び出し元はこれだけでいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;inner.html&amp;quot; data-toggle=&amp;quot;modal&amp;quot; data-target=&amp;quot;myModal&amp;quot;&amp;gt;Click&amp;lt;/a&amp;gt;
&amp;lt;div class=&amp;quot;modal fade&amp;quot; id=&amp;quot;myModal&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し先に実際の内容を書く。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inner.html:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;modal-dialog&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;modal-header&amp;quot;&amp;gt;
      &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; data-dismiss=&amp;quot;modal&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;amp;#215;&amp;lt;/button&amp;gt;
      &amp;lt;h4 class=&amp;quot;modal-title&amp;quot; id=&amp;quot;editModalLabel&amp;quot;&amp;gt;${msg[&#39;mypage.edit_time&#39;]}&amp;lt;/h4&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;modal-body&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;modal-footer&amp;quot;&amp;gt;
      &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot; data-dismiss=&amp;quot;modal&amp;quot;&amp;gt;Close&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分かってみれば簡単だったけど、ドキュメントからは読み取れなかったなぁ。&lt;/p&gt;

&lt;h3 id=&#34;add-nov-27-2013&#34;&gt;Add Nov 27, 2013&lt;/h3&gt;

&lt;p&gt;このままだとinner.htmlの内容が動的に変わる場合、最初にモーダルを表示した内容から書き変わらないので、
以下のスクリプトを追加する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;#myModal&#39;).on(&#39;hidden.bs.modal&#39;, function() {
    $(this).removeData(&#39;bs.modal&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Best Regards.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JUnitでJPAのテスト</title>
      <link>https://kokuzawa.github.io/blog/2013/11/03/unit-test-of-jpa/</link>
      <pubDate>Sun, 03 Nov 2013 01:39:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/11/03/unit-test-of-jpa/</guid>
      <description>

&lt;p&gt;JPAで作ったデータアクセスクラスのテストをJUnitで作る際に、EntityManagerの扱いが問題になってきます。
プロダクトコードだと、PersistenceUnitのtransactionTypeをJTAとするため、
この設定のままユニットテストを実行には、APサーバが起動している必要があります。
この状態だとJenkinsに食わせたりするときに色々大変だし、
そもそもテスト用にはデータベースを別にしたいので、設定をテスト時だけ書き直す必要が出てきて面倒です。
そこでプロダクトコードとテストコードで参照するPersistenceUnitを変更するようにしてみました。&lt;/p&gt;

&lt;h2 id=&#34;ファイル構成&#34;&gt;ファイル構成&lt;/h2&gt;

&lt;p&gt;ファイルは下記のように、プロダクトコードとテストコード用にそれぞれpersistence.xmlを用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root
 └ src
   ├ main
   │  ├ java
   │  │  ├ Account.java
   │  │  └ AccountFacade.java
   │  └ resources
   │     └ META-INF
   │        └ persistence.xml
   └ test
      ├ java
      │  └ AccountFacadeTest.java
      └ resources
         └ META-INF
            └ persistence.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロダクトコードのpersistence.xmlはこんな感じ。
transaction-typeをJTAにしているので、jta-data-sourceにAPサーバで設定したデータソース名を指定しています。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;persistence.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;persistence xmlns=&amp;quot;http://java.sun.com/xml/ns/persistence&amp;quot; version=&amp;quot;2.0&amp;quot;&amp;gt;
    &amp;lt;persistence-unit name=&amp;quot;mytestPU&amp;quot; transaction-type=&amp;quot;JTA&amp;quot;&amp;gt;
        &amp;lt;jta-data-source&amp;gt;jdbc/mytest&amp;lt;/jta-data-source&amp;gt;
        &amp;lt;properties&amp;gt;
            &amp;lt;property name=&amp;quot;eclipselink.ddl-generation&amp;quot; value=&amp;quot;create-tables&amp;quot;/&amp;gt;
        &amp;lt;/properties&amp;gt;
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストコードのpersistence.xmlはこんな感じ。
プロダクトコードとは違い、APサーバが起動していなくてもユニットテストが実行できるように
transaction-typeをRESOURCE_LOCALにしています。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;persistence.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;persistence xmlns=&amp;quot;http://java.sun.com/xml/ns/persistence&amp;quot; version=&amp;quot;2.0&amp;quot;&amp;gt;
    &amp;lt;persistence-unit name=&amp;quot;mytestTPU&amp;quot; transaction-type=&amp;quot;RESOURCE_LOCAL&amp;quot;&amp;gt;
        &amp;lt;provider&amp;gt;org.eclipse.persistence.jpa.PersistenceProvider&amp;lt;/provider&amp;gt;
        &amp;lt;class&amp;gt;org.mytest.entity.Account&amp;lt;/class&amp;gt;
        &amp;lt;properties&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.driver&amp;quot; value=&amp;quot;org.postgresql.Driver&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.url&amp;quot; value=&amp;quot;jdbc:postgresql://localhost:5432/mytest_test&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.user&amp;quot; value=&amp;quot;demo&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.password&amp;quot; value=&amp;quot;demo&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;eclipselink.ddl-generation&amp;quot; value=&amp;quot;drop-and-create-tables&amp;quot;/&amp;gt;
        &amp;lt;/properties&amp;gt;
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは下記のコードを用意します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Account.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
public class Account
{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long accountId;
    private String email;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AccountFacade.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestScoped
@Transactional
public class AccountFacade
{
    @PersistentContext(unitName = &amp;quot;mytestPU&amp;quot;)
    private EntityManager em;

    public void persist(Account account)
    {
        Objects.requireNonNull(account);
        em.persist(account);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AccountFacadeTest.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AccountFacadeTest
{
    private EntityManager em;
    private AccountFacade accountFacade = new AccountFacade();

    @Before
    public void setUp() throws Exception
    {
        em = Persistence.createEntityManagerFactory(&amp;quot;mytestTPU&amp;quot;).createEntityManager();
        accountFacade.em = em;
    }

    @After
    public void tearDown() throws Exception
    {
        em.close();
    }

    @Test
    public void testPersist() throws Exception
    {
        final Account account = new Account(&amp;quot;xxxxx@hoge.com&amp;quot;);

        em.getTransaction().begin();
        accountFacade.persist(account);
        em.getTransaction().commit();

        assert account.getAccountId() &amp;gt; 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストコードではmytestTPUからEntityManagerを生成します。
プロダクトコードでは@Transactionalでトランザクションを管理していますが、
テストコードでは@Transactionalでのトランザクション管理はできないので、
トランザクション制御のためのコードを書く必要があります。&lt;/p&gt;

&lt;p&gt;Best Regards.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>springframeworkのjarファイル一式をダウンロードするには？</title>
      <link>https://kokuzawa.github.io/blog/2013/10/15/springframework/</link>
      <pubDate>Tue, 15 Oct 2013 00:16:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/10/15/springframework/</guid>
      <description>&lt;p&gt;久しぶりにSpringのサイトを見に行ったら、Spring Framework一式がZIPでダウンロードできなくなってた。
サイトは今風になって素敵なんだけど。&lt;/p&gt;

&lt;p&gt;MavenとかGradleを使って取得するのが正しい方法として挙げられているけれども、一式を取得する方法は特に記載がない。
Mavenを利用したことがなくて一式欲しいという需要があるようなので、ここで一つの方法を書いてみようと思う。
Gradleの方が記述が簡単そうだけど、ちゃんと使ったことがないので今回はMavenを利用する。&lt;/p&gt;

&lt;p&gt;Mavenでは maven-asembly-plugin がこの要望を満たしてくれる。
maven-assembly-plugin は pom.xml とは別に個別の設定ファイルが必要なので、それを用意する。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;distribution.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;assembly xmlns=&amp;quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2&amp;quot;
          xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
          xsi:schemaLocation=&amp;quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2
                              http://maven.apache.org/xsd/assembly-1.1.2.xsd&amp;quot;&amp;gt;
    &amp;lt;id&amp;gt;distribution&amp;lt;/id&amp;gt;
    &amp;lt;formats&amp;gt;
        &amp;lt;format&amp;gt;zip&amp;lt;/format&amp;gt;
    &amp;lt;/formats&amp;gt;
    &amp;lt;dependencySets&amp;gt;
        &amp;lt;dependencyset&amp;gt;
            &amp;lt;unpack&amp;gt;false&amp;lt;/unpack&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
            &amp;lt;outputDirectory&amp;gt;/out&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;/dependencyset&amp;gt;
    &amp;lt;/dependencySets&amp;gt;
&amp;lt;/assembly&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルの内容を簡単に説明すると、format には出力形式として zip, tar, tar.gz が指定できる。
unpack では、取得する jar ファイルを解凍して一つの jar とするかどうかを指定する。
scope は、Maven の dependency の scope と同じ意味なので、必要な値を指定、
outputDirectory は zip の出力先を指定する。&lt;/p&gt;

&lt;p&gt;次にpom.xmlにプラグインの追加とdistribution.xmlの場所を定義する必要がある。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pom.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.1&amp;lt;/version&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;descriptors&amp;gt;
                    &amp;lt;descriptor&amp;gt;distributions.xml&amp;lt;/descriptor&amp;gt;
                &amp;lt;/descriptors&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring Framework のライブラリはリポジトリを別途指定する必要があるので、それを pom.xml に定義する。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pom.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
        &amp;lt;id&amp;gt;com.springsource.repository.bundles.release&amp;lt;/id&amp;gt;
        &amp;lt;name&amp;gt;SpringSource Enterprise Bundle Repository - SpringSource Bundle Releases&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http://repository.springsource.com/maven/bundles/release&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
    &amp;lt;repository&amp;gt;
        &amp;lt;id&amp;gt;com.springsource.repository.bundle.external&amp;lt;/id&amp;gt;
        &amp;lt;name&amp;gt;SpringSource Enterprise Bundle Repository - External Bundle Releases&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http://repository.springsource.com/maven/bundles/external&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
    &amp;lt;repository&amp;gt;
        &amp;lt;id&amp;gt;com.springsource.repository.libraries.release&amp;lt;/id&amp;gt;
        &amp;lt;name&amp;gt;SpringSource Enterprise Bundle Repository - SpringSource Library Releases&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http://repository.springsource.com/maven/libraries/release&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
    &amp;lt;repository&amp;gt;
        &amp;lt;id&amp;gt;com.springsource.repository.libraries.external&amp;lt;/id&amp;gt;
        &amp;lt;name&amp;gt;SpringSource Enterprise Bundle Repository - External Library Releases&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http://repository.springsource.com/maven/libraries/external&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
&amp;lt;/repositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは Spring framework の実体を指す dependency を追加すれば完成。
これは&lt;a href=&#34;http://ebr.springsource.com/repository/app/library/version/detail?name=org.springframework.spring&amp;amp;version=3.2.3.RELEASE&#34;&gt;ここ&lt;/a&gt;を
参考にすれば良いと思う。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pom.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;org.springframework.spring-library&amp;lt;/artifactId&amp;gt;
    &amp;lt;type&amp;gt;libd&amp;lt;/type&amp;gt;
    &amp;lt;version&amp;gt;3.2.3.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでpom.xmlが完成したので、あとは以下のコマンドを実行すればdistribution.xmlで定義したoutディレクトリに
Spring Frameworkのjarファイル一式が含まれたzipファイルが生成されるはず。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mvn assembly:assembly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Best regards.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>バブルソートをJavaFXで可視化</title>
      <link>https://kokuzawa.github.io/blog/2013/09/05/run-javafx/</link>
      <pubDate>Thu, 05 Sep 2013 03:15:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/09/05/run-javafx/</guid>
      <description>

&lt;p&gt;『アルゴリズムとデータ構造』という本の一番最初に出てくるバブルソートを可視化したいと思い、JavaFXでアプリケーションを作った。
作るのはそれほど難しい話ではないので、ちょっとした解説を加えつつ紹介しようと思う。&lt;/p&gt;

&lt;p&gt;実行モジュールもあとで提示するので確認して頂ければ幸い。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;IDEはIntelliJ IDEAを使った。IntelliJ IDEAにはJavaFXモジュール用のプロジェクトを作ることができるのでそれを利用する。
ビルドすると親切なことにjarファイルだけでなく、JNLPやHTMLファイルを生成してくれるので非常に便利。&lt;/p&gt;

&lt;p&gt;ビルドされた実行モジュールを見てもらった方が分かり易いと思い、
Appletとしてブラウザ上で動かそうと思ったのだが、
IDEAが生成してくれたHTMLをSafariで開いても、いつまでたっても起動しない。
HTMLのソースを見てみると、dtjava.jsというJavaScriptを使って起動しようとしているようだが、
少なくともSafariではうんともすんとも言わない。
他のブラウザなら動作するのだろうかと思い、Chromeで実行すると、今度は「このブラウザではサポートされていない」という趣旨の
メッセージが表示される。多分Macだとダメなのだろう。もし起動する方法を知っていたら教えて頂きたい。&lt;/p&gt;

&lt;p&gt;ということで、Appletとして動かすことは諦めたので、JNLPファイルへのリンクを提示する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dl.dropboxusercontent.com/u/46295066/javafx/BubbleSort/JavaFXApp.jnlp&#34;&gt;JavaFXApp.jnlp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このJNLPをダウンロードして起動すると、バブルソートが実行される。
OSXの場合だと、セキュリティによって起動できないかもしれない。
その場合、ダウンロードしたJNLPファイルをCtrl＋クリックして「このアプリケーションで開く」-&amp;gt; 「Java Web Start」とメニューを
選択して行けば、起動しても良いか尋ねてくれるので、ここから起動が出来ると思う。&lt;/p&gt;

&lt;h2 id=&#34;アプリについて&#34;&gt;アプリについて&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ソート対象となる100本の黒ラインはランダムに並んでいて、現在処理中のラインを赤で表している。
実際に動作を見ると、短い黒ラインがだんだんと左側に寄って行くのが分かる。&lt;/p&gt;

&lt;h2 id=&#34;コード&#34;&gt;コード&lt;/h2&gt;

&lt;p&gt;初期データは&lt;code&gt;Collections.shuffle(Collection)&lt;/code&gt;でシャッフルする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (int i = 1; i &amp;lt;= N; i++) {
    data.add(i);
}
Collections.shuffle(data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ステージの初期化。黒ラインと赤ラインを表すPathを2つ。
repaint()メソッドで描画した結果から必要になった幅をステージの幅として設定する。+10はパディング分になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;path.setStrokeWidth(3.0);
path.setStroke(Color.GRAY);
currentPath.setStrokeWidth(4.0);
currentPath.setStroke(Color.RED);
root.getChildren().add(path);
root.getChildren().add(currentPath);

final int width = repaint();

primaryStage.setTitle(&amp;quot;Bubble Sort&amp;quot;);
primaryStage.setResizable(false);
primaryStage.setScene(new Scene(root, width + 10, VIEW_HEIGHT));
primaryStage.show();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際のライン描画処理。
JavaFXではTimelineクラスを使うと秒毎の処理が書けるので簡単にアニメーションを作ることができる。
待機時間無しだとソートが一瞬で終わってしまい、過程を見ることができないので、
ここでは待機時間に10ミリ秒を指定している。&lt;code&gt;new Duration(10)&lt;/code&gt;の部分。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;timeline.getKeyFrames().addAll(
        new KeyFrame(new Duration(10), new EventHandler&amp;lt;ActionEvent&amp;gt;()
        {
            @Override
            public void handle(ActionEvent actionEvent)
            {
                if (data.get(counter) &amp;gt; data.get(counter + 1)) {
                    flag = true;
                    Collections.swap(data, counter, counter + 1);
                }

                counter++;

                repaint();

                if (counter &amp;gt;= N - 1 - k) {
                    if (!flag) {
                        repaint();
                        timeline.stop();
                    }
                    flag = false;
                    counter = 0;
                    k++;
                }
            }
         })
);
timeline.setCycleCount(Timeline.INDEFINITE);
timeline.play();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バブルソートなので入れ替えが発生しなくなるまでソートを繰り返す。
入れ替えの発生有無は&lt;code&gt;flag&lt;/code&gt;によって制御している。この&lt;code&gt;flag&lt;/code&gt;がfalseのまま最終ラインまで処理されると、
&lt;code&gt;timeline.stop()&lt;/code&gt;を呼び出し、タイムラインを停止する。&lt;/p&gt;

&lt;p&gt;入れ替えが発生した場合は、下記のrepaint()メソッドを呼び出し、
画面の再描画を行っている。
JavaFXでラインを引く場合、&lt;code&gt;MoveTo&lt;/code&gt;クラスで座標を移動し、&lt;code&gt;LineTo&lt;/code&gt;クラスで指定座標までのラインを引く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int repaint()
{
    path.getElements().clear();
    currentPath.getElements().clear();
    int position = 10;
    int localCounter = 0;
    for (Integer i : data) {
        if (counter == localCounter) {
            currentPath.getElements().add(new MoveTo(position, (VIEW_HEIGHT - 10)));
            currentPath.getElements().add(new LineTo(position, ((VIEW_HEIGHT - 10) - (i * 2))));
        }
        else {
            path.getElements().add(new MoveTo(position, (VIEW_HEIGHT - 10)));
            path.getElements().add(new LineTo(position, ((VIEW_HEIGHT - 10) - (i * 2))));
        }
        position += 5;
        localCounter++;
    }

    return position;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースコードはbitbucketにあるので完全版はそちらを参照してください。
&lt;a href=&#34;https://bitbucket.org/kokuzawa/bubblesort&#34;&gt;https://bitbucket.org/kokuzawa/bubblesort&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JDBCRealmのパッケージが変更 #glassfish-4</title>
      <link>https://kokuzawa.github.io/blog/2013/06/30/jdbcrealmfalsepatukezigabian-geng-number-glassfish-4/</link>
      <pubDate>Sun, 30 Jun 2013 11:09:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/06/30/jdbcrealmfalsepatukezigabian-geng-number-glassfish-4/</guid>
      <description>&lt;p&gt;GlassFish-4.0からJDBCRealmクラスのパッケージが変更になった。&lt;br /&gt;
今までのパッケージは下記の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GlassFish-4.0からは下記のパッケージとなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;com.sun.enterprise.security.ee.auth.realm.jdbc.JDBCRealm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Embeddedとして利用しているとかじゃないとあまり影響はないかもしれない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaEE 7 リリース！</title>
      <link>https://kokuzawa.github.io/blog/2013/06/14/javaee7-release/</link>
      <pubDate>Fri, 14 Jun 2013 01:53:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/06/14/javaee7-release/</guid>
      <description>

&lt;p&gt;JavaEE 7 がというかGlassFish 4 がリリースされた。&lt;br /&gt;
会社でテストサーバとして使っているのは、GlassFish 3.1.2.2 なので早速入れ替えてみた。
余談だが運用サーバはTomcatなので、どちらかというとテストサーバの方が性能が良い。&lt;/p&gt;

&lt;p&gt;で、意気揚々と起動してみた訳なのだが、起動できない。&lt;br /&gt;
理由は単純で、GlassFish 4 はJDK7が必須にもかかわらず、プロジェクトのJDKのバージョンがJDK6なのである。
まあコンパイル時にサーバのクラスのバージョンよりも古いバージョンでコンパイルしているよ、という警告が出ていたので
何となくは思っていたのだが、改めて起動できないとちょっとショックではある。&lt;/p&gt;

&lt;p&gt;ひとまず、DataSourceの設定が今までと同じように出来ることは確認したので、
それについて書こうと思う。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;ドライバの配置&#34;&gt;ドライバの配置&lt;/h2&gt;

&lt;p&gt;GlassFishで利用できるJDBCドライバには下記のものがある。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://glassfish.java.net/docs/4.0/administration-guide.pdf&#34;&gt;Administration Guide&lt;/a&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;■ IBM DB2 Database Type 2 Driver&lt;br /&gt;
■ IBM DB2 Database Type 4 Driver&lt;br /&gt;
■ Java DB/Derby Type 4 Driver&lt;br /&gt;
■ MySQL Server Database Type 4 Driver&lt;br /&gt;
■ Oracle 10 Database Driver&lt;br /&gt;
■ Oracle 11 Database Driver&lt;br /&gt;
■ PostgreSQL Type 4 Driver&lt;br /&gt;
■ DataDirect Type 4 Driver for IBM DB2 Database&lt;br /&gt;
■ DataDirect Type 4 Driver for IBM Informix&lt;br /&gt;
■ DataDirect Type 4 Driver for Microsoft SQL Server Database&lt;br /&gt;
■ DataDirect Type 4 Driver for MySQL Server Database&lt;br /&gt;
■ DataDirect Type 4 Driver for Oracle 11 Database&lt;br /&gt;
■ DataDirect Type 4 Driver for Sybase Database&lt;br /&gt;
■ Inet Oraxo Driver for Oracle Database&lt;br /&gt;
■ Inet Merlia Driver for Microsoft SQL Server Database&lt;br /&gt;
■ Inet Sybelux Driver for Sybase Database&lt;br /&gt;
■ JConnect Type 4 Driver for Sybase ASE 12.5 Database&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;沢山あるので困らないと思う。主に使っているのはPostgreSQLなので、今回はそのドライバを使うことにした。
ドライバといってもjarファイルなので、ダウンロードしてきたjarファイルをGlassFishが認識できるクラスパスに配置する必要がある。
これもAdministration Guideに記載があり、下記にあるように&lt;code&gt;domain-dir/lib&lt;/code&gt;に配置すれば良いようだ。以前との変更点は無い。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://glassfish.java.net/docs/4.0/administration-guide.pdf&#34;&gt;Administration Guide&lt;/a&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Making the JDBC Driver JAR Files Accessible
To integrate the JDBC driver into a GlassFish Server domain, copy the JAR files into the domain-dir/lib directory, then restart the server.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;サーバを起動したら&lt;code&gt;localhost:4848&lt;/code&gt;にアクセスし、Resources -&amp;gt; JDBC -&amp;gt; JDBC Connection Pools と選択する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Newボタンをクリックすると、コネクションプールの作成画面に変わる。
今回はPostgreSQLのDataSourceを作るので、Resource Typeは&lt;code&gt;javax.sql.DataSource&lt;/code&gt;、Database Driver Vendorは&lt;code&gt;Postgresql&lt;/code&gt;を選択する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;必要事項の入力が終わったらNextボタンをクリックしよう。
すると、コネクションプールの詳細な設定画面が表示されるが、上の方の設定はひとまず変更せず、
一番下にあるAdditional Propertiesを設定する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;設定が終わったらFinishボタンをクリックしよう。っとその前に上の方の設定にPingというのがあるので、
これをONにしておく。ここをONにしておけば、コネクションプールがちゃんとDBと接続できるか確認してくれるのだ。
うまく接続できれば画面上部に成功を表すメッセージが表示されるはず。&lt;/p&gt;

&lt;p&gt;次にResources -&amp;gt; JDBC -&amp;gt; JDBC Resources と選択する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Newボタンをクリックしてリソース設定画面を表示する。
Pool Nameにはさっき作成したコネクションプールを指定する。あとはJNDI Nameに任意の名前を設定してOKボタンをクリックすればJNDIリソースの完成だ。
このリソースは、こんな風に取得することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Context ctx = new InitialContext();
final DataSource dataSource = (DataSource) ctx.lookup(&amp;quot;jdbc/demo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまで設定できれば、あとは色々なWebアプリから利用するだけ。
なんだかJavaEE 7 にはあまり関係がないが、今までと同じように設定が出来るということを報告しておく。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JSF2.0でCSSリソース内の画像を読み込む</title>
      <link>https://kokuzawa.github.io/blog/2013/06/10/load-images-within-css-resources-in-jsf-2-dot-0/</link>
      <pubDate>Mon, 10 Jun 2013 03:10:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/06/10/load-images-within-css-resources-in-jsf-2-dot-0/</guid>
      <description>

&lt;p&gt;JSF 2.0 でCSSリソース内の画像を読み込むにはコツが必要です。&lt;br /&gt;
Bootstrapのglyphicons-halflings.pngを読み込むのに暫く悩んだのでそのメモなど。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;フォルダ構成は次のようになっています。（Mavenです）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root
 +-- src
     +-- webapp
         +-- resources
             +-- css
             |   +-- bootstrap.min.css
             +-- img
                 +-- glyphicons-halflings.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSFなのでXHTMLを使い、CSSの読み込みは以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;h:outputStylesheet library=&amp;quot;css&amp;quot; name=&amp;quot;bootstrap.min.css&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このとき、bootstrap.min.css内のイメージのパスは&lt;code&gt;../img/glyphicons-halflings.png&lt;/code&gt;となっていますが、
このままでは画像が読み込まれません。まあ、パスからも明らかですね。&lt;/p&gt;

&lt;p&gt;問題を解決するには次のように、イメージのパスを変更する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;background-image:url(&amp;quot;#{resource[&#39;img/glyphicons-halflings.png&#39;]}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jun-20-2013-追記&#34;&gt;Jun 20, 2013 追記&lt;/h2&gt;

&lt;p&gt;twitterで&lt;a href=&#34;https://twitter.com/den2sn&#34;&gt;@den2sn&lt;/a&gt;さんに教えてもらったのですが、outputStylesheetを下記のようにlibraryを削除して宣言することにより、
bootstrap.min.cssを書き換えなくても良くなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;h:outputStylesheet name=&amp;quot;css/bootstrap.min.css&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>cookie on java web start (JWS)</title>
      <link>https://kokuzawa.github.io/blog/2013/06/07/cookie-on-jnlp/</link>
      <pubDate>Fri, 07 Jun 2013 01:41:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/06/07/cookie-on-jnlp/</guid>
      <description>

&lt;p&gt;今更感がありますが、JWSでのcookieの扱い、というかjsessionidの扱いについて。&lt;/p&gt;

&lt;p&gt;JWSからサーバへの最初のアクセスでjsessionidの指定が無いと、サーバでjsessionidが発行されます。
すると、JWSからのそれ以降のアクセスには、その生成されたjsessionidがcookieとしてサーバに送信されます。
これは良く出来た仕組みで、プログラマが意識しなくてもセッションを継続することが可能になります。
ただ、自動でjsessionidを送信してしまうため、意図したセッションを継続させることが出来ないことがあります。&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&#34;任意のjsessionidを送信したい&#34;&gt;任意のjsessionidを送信したい&lt;/h2&gt;

&lt;p&gt;前提として以下のことが成り立っているとします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;認証はプラウザで行う&lt;/li&gt;
&lt;li&gt;認証状態をセッションで維持している&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JWSでもその認証状態を維持したい、つまり認証されていなければJWSを操作させたくない場合、
簡単な方法としてJWS起動時にsessionidを渡せば、JWSからのリクエストにjsessionidを付与することが可能になり、
認証状態のあるセッションを継続することが出来るようになります。&lt;/p&gt;

&lt;p&gt;例えば、以下のようにJWSからHttpURLConnectionを利用してリクエストを送信するケースですが、
&lt;code&gt;HttpURLConection#setRequestProperty(String, String)&lt;/code&gt;を使うことによってcookieにjsessionidを含めることが可能です。
もちろん、URLの最後に&lt;code&gt;;jsessionid=XXXXX&lt;/code&gt;という形でjsessionidを付けても問題ありません。
ちなみに、URLの最後に付けるのと、&lt;code&gt;setRequestProperty&lt;/code&gt;での設定と両方の指定がある場合は、
&lt;code&gt;setRequestProperty&lt;/code&gt;の方が優先されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final HttpURLConnection connection = 
    (HttpURLConnection) new URL(&amp;quot;http://localhost/mycontext&amp;quot;).openConnection();
connection.setRequestProperty(&amp;quot;Cookie&amp;quot;, &amp;quot;JSESSIONID=&amp;quot; + sessionid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このリクエストがJWSからの最初のリクエストでは無く、かつ最初のリクエストでjsessionidを明示的に送っていない場合、
Cookieには2つのjsessionidが設定された状態でリクエストされます。
サーバではこの2つのjsessionidのうち、最初に設定されている方を有効と見なして処理が行われます。
よって、上記コードで明示的に設定したjsessionidが無視されることになります。&lt;/p&gt;

&lt;p&gt;では、このケースで明示的に設定したjsessionidを有効にするにはどうしたら良いのか。&lt;/p&gt;

&lt;h2 id=&#34;自動で設定されるcookieを無効にする&#34;&gt;自動で設定されるcookieを無効にする&lt;/h2&gt;

&lt;p&gt;自動で設定されるcookieは&lt;code&gt;CookieHandler&lt;/code&gt;で設定されるようです。
なので、この&lt;code&gt;CookieHandler&lt;/code&gt;を機能させなくすれば、cookieが自動で設定されなくなるはず。
というわけで、下記のコードを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CookieHandler.setDefault(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでcookieの自動設定が行われないはずなのですが、実はこのメソッド、セキュリティが
all-permissionsでないと、&lt;code&gt;AccessControlException&lt;/code&gt;がスローされてしまいます。
JWSでall-permissionsにするには、jarファイルに署名しなければなりません。&lt;/p&gt;

&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;

&lt;p&gt;jarファイルに署名できないような政治的な事情がある場合はこの方法が取れないので、
JWSからの最初のリクエストにちゃんとjsessionidが付与されるようにしましょう。&lt;/p&gt;

&lt;p&gt;まあ、署名するための証明書もオレオレ証明書じゃない場合は、
それなりに費用もかかるので、署名できないことも多い訳ですが&amp;hellip; :P&lt;/p&gt;

&lt;p&gt;それにしても、JNLPのこととか、JWSなどの記事が軒並み古いので、
もうほとんど使われてないのかなぁと思ったりした快晴の木曜日でした。&lt;/p&gt;

&lt;p&gt;enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>how to cancel drag-and-drop on esc key</title>
      <link>https://kokuzawa.github.io/blog/2013/05/27/how-to-cancel-drag-and-drop-on-esc-key/</link>
      <pubDate>Mon, 27 May 2013 01:12:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/05/27/how-to-cancel-drag-and-drop-on-esc-key/</guid>
      <description>

&lt;p&gt;Flex-4.5.1で、ツリーノードのDrag and DropをEscキーでキャンセルしてみよう、という話です。&lt;br /&gt;
標準機能としてはありませんが、これ以降のバージョンで対応されている可能性もあるという前提になります。&lt;/p&gt;

&lt;p&gt;実はDrag and DropをEscキーを使ってキャンセルできることは知りませんでした。
Windowsでもできるようですが、普段使っているMacでもできることにさっき気がついたぐらいなので、
そんな操作を利用している人は少ないのではないかと思ってました。
ですが、検索してみると意外と多くの人が利用しているようです。&lt;/p&gt;

&lt;h2 id=&#34;実装する&#34;&gt;実装する&lt;/h2&gt;

&lt;p&gt;機能が無いので実装することにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;s:Application xmlns:fx=&amp;quot;http://ns.adobe.com/mxml/2009&amp;quot;
               xmlns:s=&amp;quot;library://ns.adobe.com/flex/spark&amp;quot;
               xmlns:mx=&amp;quot;library://ns.adobe.com/flex/mx&amp;quot;
               creationComplete=&amp;quot;creationComplete(event)&amp;quot;&amp;gt;

    &amp;lt;fx:Script&amp;gt;&amp;lt;![CDATA[
        import mx.events.FlexEvent;
        import mx.managers.DragManager;
        import mx.managers.dragClasses.DragProxy;

        protected function creationComplete(event:FlexEvent):void
        {
            addEventListener(KeyboardEvent.KEY_DOWN, function (event:KeyboardEvent):void
            {
                if (event.keyCode == Keyboard.ESCAPE) {
                    DragManager.acceptDragDrop(null);
                    myTree.hideDropFeedback(null);
                    myTree.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));
                    var dragProxy:DragProxy = DragManager.mx_internal::dragProxy;
                    if (dragProxy) {
                        dragProxy.mouseUpHandler(new MouseEvent(MouseEvent.MOUSE_UP));
                    }
                }
            });
        }
        ]]&amp;gt;&amp;lt;/fx:Script&amp;gt;

    &amp;lt;s:layout&amp;gt;
        &amp;lt;s:HorizontalLayout/&amp;gt;
    &amp;lt;/s:layout&amp;gt;

    &amp;lt;mx:Tree id=&amp;quot;myTree&amp;quot;
             width=&amp;quot;200&amp;quot;
             height=&amp;quot;300&amp;quot;
             dragMoveEnabled=&amp;quot;true&amp;quot;
             dragEnabled=&amp;quot;true&amp;quot;
             dropEnabled=&amp;quot;true&amp;quot;
             labelField=&amp;quot;@label&amp;quot;&amp;gt;
        &amp;lt;mx:XMLListCollection id=&amp;quot;treeData&amp;quot;&amp;gt;
            &amp;lt;fx:XMLList&amp;gt;
                &amp;lt;node label=&amp;quot;Mail Box&amp;quot;&amp;gt;
                    &amp;lt;node label=&amp;quot;Inbox&amp;quot;&amp;gt;
                        &amp;lt;node label=&amp;quot;AAAAA&amp;quot;/&amp;gt;
                        &amp;lt;node label=&amp;quot;BBBBB&amp;quot;/&amp;gt;
                        &amp;lt;node label=&amp;quot;CCCCC&amp;quot;/&amp;gt;
                    &amp;lt;/node&amp;gt;
                    &amp;lt;node label=&amp;quot;Outbox&amp;quot;&amp;gt;
                        &amp;lt;node label=&amp;quot;DDDDD&amp;quot;/&amp;gt;
                        &amp;lt;node label=&amp;quot;EEEEE&amp;quot;/&amp;gt;
                    &amp;lt;/node&amp;gt;
                &amp;lt;/node&amp;gt;
            &amp;lt;/fx:XMLList&amp;gt;
        &amp;lt;/mx:XMLListCollection&amp;gt;
    &amp;lt;/mx:Tree&amp;gt;

&amp;lt;/s:Application&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大したことはしてなくて、重要なのは下記の部分。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;addEventListener(KeyboardEvent.KEY_DOWN, function (event:KeyboardEvent):void
{
    if (event.keyCode == Keyboard.ESCAPE) {
        DragManager.acceptDragDrop(null);
        myTree.hideDropFeedback(null);
        myTree.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));
        var dragProxy:DragProxy = DragManager.mx_internal::dragProxy;
        if (dragProxy) {
            dragProxy.mouseUpHandler(new MouseEvent(MouseEvent.MOUSE_UP));
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単に説明すると、まず、ツリーコンポーネントの上以外でもEscキーをハンドリングする必要があるので、キーイベントのリスナーはApplicationに付けます。
で、Escが叩かれたらdrag-and-dropをキャンセルさせるためにコンポーネントに通知します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DragManager.acceptDragDrop(null);&lt;/code&gt;でドロップを無効に、ドラッグすると移動先にラインが表示されるので、
&lt;code&gt;myTree.hideDropFeedback(null);&lt;/code&gt;でラインを消します。
ドラッグ中はマウスをダウンしたままなので、キャンセルに合わせてツリーコンポーネントに対して
&lt;code&gt;myTree.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));&lt;/code&gt;を通知します。&lt;/p&gt;

&lt;p&gt;そのあとがちょっと特殊で、mx_internalでDragManagerの内部変数を参照し、マウスアップイベントを通知します。
この通知が無いと、ドラッグ操作をキャンセルしたと認識されません。&lt;/p&gt;

&lt;p&gt;もっと良いやり方や、最新バージョンだと出来るよとか教えて頂けると嬉しいです :D&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Edit breakpoint of the IntelliJ IDEA</title>
      <link>https://kokuzawa.github.io/blog/2013/04/01/edit-breakpoints/</link>
      <pubDate>Mon, 01 Apr 2013 22:35:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/04/01/edit-breakpoints/</guid>
      <description>

&lt;p&gt;IntelliJも他のIDE同様デバッグが簡単にできます。&lt;br /&gt;
もちろん複数のスレッドを同時にデバッグできるのですが、初期設定だと一つのスレッドが終わるまですべてのスレッドがSuspendされます。
最初はこういうものかなと思っていたんですが、設定で切り替えることができるようです。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;ブレークポイントをCtrl+クリックしてEditメニューを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表示されたポップアップのSuspendのところ、Allにチェックが入っていると思います。
これをThreadに変更します。もし今後すべての動作をThreadにするのであれば、右にある「Make Default」ボタンをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これでスレッド毎にSuspendされるようになりました。&lt;/p&gt;

&lt;p&gt;Best regards,&lt;br /&gt;
Katsumi&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jersey on glassfish-4</title>
      <link>https://kokuzawa.github.io/blog/2013/03/24/jersey-on-glassfish4/</link>
      <pubDate>Sun, 24 Mar 2013 12:32:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/03/24/jersey-on-glassfish4/</guid>
      <description>&lt;p&gt;GlassFish-4を使ってみたらJerseyのパッケージが変わってた。
GlassFish-3.1.2.2までは以下のようにcom.sunパッケージにあるJerseyのサーブレットがロードできていたけど、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;servlet-name&amp;gt;jersey-serlvet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.sun.jersey.spi.container.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GlassFish-4ではcom.sunパッケージにJerseyはなく、org.glassfishのパッケージとなっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;servlet-name&amp;gt;jersey-serlvet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.glassfish.jersey.servlet.ServletContainer&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>IntelliJ IDEAでglassfish-web.xmlを自動生成するには</title>
      <link>https://kokuzawa.github.io/blog/2013/03/21/generate-glassfish-web-dot-xml-automatically/</link>
      <pubDate>Thu, 21 Mar 2013 00:04:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/03/21/generate-glassfish-web-dot-xml-automatically/</guid>
      <description>

&lt;p&gt;NetBeansだとsun-web.xmlとして自動生成されるファイルのことです。
JavaEE6の&lt;a href=&#34;http://docs.oracle.com/javaee/6/tutorial/doc/javaeetutorial6.pdf&#34; target=&#34;_blank&#34;&gt;ドキュメント&lt;/a&gt;を読む限り、
glassfish-web.xmlが正式名称のようですが&amp;hellip;。&lt;/p&gt;

&lt;p&gt;このファイル、通常は必要ないのですが、GlassFishのBASIC認証とかDIGEST認証にJDBCレルムを使おうとすると必要になります。
XMLファイルなので、DTDのパスとか&amp;hellip;まあその辺の入力が面倒な訳で、テンプレートは検索すれば見つかりますけど、出来ればIntelliJで生成できないかなと。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;画面上部のツールバーからProject Structureを選択。もしくはCmd+;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表示された画面からModules-&amp;gt;Webと選択し、右ペイン中にあるAdd Aplication Server specific descriptorボタンをクリック。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表示されたポップアップのApplication ServerをGlassfish Serverに、Descriptorは選択肢が2つで最後にOracleとなっている方を選択。
(以下のイメージでは既にOracleを設定済みなのでSunしか表示されていない。)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これでglassfish-web.xmlのテンプレートが自動生成される。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;glassfish-web.xml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE glassfish-web-app PUBLIC &amp;quot;-//GlassFish.org//DTD GlassFish Application Server 3.1 Servlet 3.0//EN&amp;quot;
    &amp;quot;http://glassfish.org/dtds/glassfish-web-app_3_0-1.dtd&amp;quot;&amp;gt;
&amp;lt;glassfish-web-app&amp;gt;
&amp;lt;/glassfish-web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはここに必要な記述を追加して行くだけ。IntelliJは補完が強力なので、ここまでファイルが出来てくれれば後は楽。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gitで複数のブランチを一括削除するには</title>
      <link>https://kokuzawa.github.io/blog/2013/03/11/delete-all-of-git-branches/</link>
      <pubDate>Mon, 11 Mar 2013 23:59:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/03/11/delete-all-of-git-branches/</guid>
      <description>&lt;p&gt;ブランチがこんな感じにある場合を想定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch
TEST-001
TEST-002
master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TEST-001とTEST-002の作業は終わったので、ブランチを削除したい。
ただ、ブランチ削除のコマンドを2回実行するのは面倒。
そんなときは次のコマンドを実行すると一括で削除可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch | grep TEST | xargs git branch -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ブランチを削除する場合、ブランチ名にワイルドカードが使えません。
なので、コマンドをパイプでつなげて一括削除を実現します。&lt;/p&gt;

&lt;p&gt;便利ですね :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Performance of JPA</title>
      <link>https://kokuzawa.github.io/blog/2013/01/27/performance-of-jpa/</link>
      <pubDate>Sun, 27 Jan 2013 12:08:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/01/27/performance-of-jpa/</guid>
      <description>

&lt;p&gt;JPAはJavaSE上でも動作するので、DBアクセスをする場合、最近はもっぱらJDBCではなくJPAを利用している。
サーバサイドを利用しない、クライアントアプリでDBアクセスをするのは、主にデータ移行ツールとかが多く、
ひとつのトランザクション内で処理されるレコード数が数万レコードになる事が多い。&lt;/p&gt;

&lt;p&gt;数万レコードを移行する為に、JPAを利用した移行ツールを作り、実データでテストをしたところ、
想定外のパフォーマンス劣化が発生し、その解決に幾分か時間が掛かってしまった。
そのため、パフォーマンスが劣化する状況とその解決方法を簡易に示す為の簡易なコードを作成、備忘録として残しておく。&lt;/p&gt;

&lt;h2 id=&#34;アプリ構成&#34;&gt;アプリ構成&lt;/h2&gt;

&lt;p&gt;JavaはJDK7、JPAの実装はEclipseLink-2.3.2を利用。DBはDerby。&lt;/p&gt;

&lt;h2 id=&#34;コード&#34;&gt;コード&lt;/h2&gt;

&lt;p&gt;検証に利用するコードは下記の通り。
Bookエンティティを1万レコード永続化する。この際、永続化だけではパフォーマンスの劣化を確認できないため、
永続化されたBookエンティティのうち、&lt;code&gt;bookname=&#39;name1&#39;&lt;/code&gt;のレコードを抽出する。
また、検証に利用する為に、ループ1回の処理時間(ms)をファイルに出力する。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kokuzawa/4646983.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;検証&#34;&gt;検証&lt;/h2&gt;

&lt;p&gt;まず改善前の結果。縦軸は処理時間(ms)、横軸は回数。
約5,000回で一度速度が改善しているが、全体的に右肩上がりで処理時間が劣化している。
簡易なコードであり、処理時間が数msのため、このままでも致命的な状況にならないかもしれないが、
tachされたエンティティの数が増加すると、それに比例して劣化していく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に改善後の結果。
約5,000回で速度が改善するのは同じだが、一定速度以上の劣化は起こらず安定している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;改善方法&#34;&gt;改善方法&lt;/h2&gt;

&lt;p&gt;では、何をすれば改善するのか。
結論から言えば、エンティティをdetachすれば良い。
detachすることによってエンティティはエンティティマネージャの管理外になり、通常のJavaのオブジェクトになる。
そのため、同期のためのオーバヘッドがなくなり、パフォーマンスが改善するのだと考えられるが確証はないので、
あとでEclipseLinkのソースコードを確認してみようと思う。
ただし、これによりDBとの同期は行えなくなるため、detachをする位置には注意が必要。&lt;/p&gt;

&lt;p&gt;検証コードでは、ループ内の最後に下記2行を追加した。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;em.flush();
em.clear();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;em.flush()&lt;/code&gt;を呼び出しているのは、Bookエンティティが永続化される前にdetachされるのを回避するため。
ただし、これも注意が必要で、リレーション関係のあるエンティティを両方とも永続化しようとするケース等で、
片方をpersist、他方をpersistする前にflushしてしまうと、他方の永続化時にエラーが発生してしまう。&lt;/p&gt;

&lt;p&gt;ちなみにflushやclearに関しては次の本が詳しい。&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&amp;bc1=FFFFFF&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=moonwhaleblog-22&amp;o=9&amp;p=8&amp;l=as1&amp;m=amazon&amp;f=ifr&amp;ref=qf_sp_asin_til&amp;asins=4798124605&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Convert the Alerts component of &#39;Bootstrap&#39; to a component of JSF 2.0</title>
      <link>https://kokuzawa.github.io/blog/2013/01/13/facesmessagetobootstrap/</link>
      <pubDate>Sun, 13 Jan 2013 18:46:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2013/01/13/facesmessagetobootstrap/</guid>
      <description>&lt;p&gt;JSFのMessagesコンポーネントは、Managed Beanで設定されたFacesMessageを出力する為のコンポーネントです。
出力方法は、listとTableの二つのレイアウトを利用した方法があり、デフォルトはlistレイアウトです。
listレイアウトは以下のような出力になります。&lt;br /&gt;
(Bootstrapの&lt;code&gt;alert alert-error&lt;/code&gt;を適用)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これに対してTableレイアウトは以下のような出力になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;どちらもエラーを表示するには十分ですが、ユーザとしては確認したらエラー情報を消したいところです。
MessagesコンポーネントはHTMLをカスタマイズする事ができません。
正確にはレンダラをカスタマイズすれば、出力するHTMLを書き換える事が出来ますし、
そういった情報を扱ったブログもありますが、Messagesレンダラのカスタマイズは、
com.sunパッケージのクラスを継承して拡張する必要があり、JSFの実装依存のコードになってしまいます。
もちろん独自で一からレンダラを書いても良いのですが、あまり現実的ではありません。
そこで、標準のMessagesコンポーネントではなくBootstrapのAlertsコンポーネントを使うことにします。&lt;/p&gt;

&lt;p&gt;BootstrapのAlertsコンポーネントはクローズボタンを表示する事ができます。
このクローズボタンをクリックする事により、エラー情報を消すことができます。
クローズボタンを出すには、HTMLを下記のように記載する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;alert alert-error&amp;quot;&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; data-dismiss=&amp;quot;alert&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/button&amp;gt;
    &amp;lt;h4&amp;gt;Summary Message&amp;lt;/h4&amp;gt;
    Detail Message
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをJSF合成コンポーネントにします。
webapp/resources/bootstrapフォルダを作成し、alert.xhtmlファイルを配置します。(フォルダ構成はMavenです)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;alert.xhtml:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;quot; 
      &amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;quot;&amp;gt;
&amp;lt;html xmlns=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;
      xmlns:cc=&amp;quot;http://java.sun.com/jsf/composite&amp;quot;
      xmlns:c=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot;&amp;gt;

    &amp;lt;!-- INTERFACE --&amp;gt;
    &amp;lt;cc:interface&amp;gt;
    &amp;lt;/cc:interface&amp;gt;

    &amp;lt;!-- IMPLEMENTATION --&amp;gt;
    &amp;lt;cc:implementation&amp;gt;
        &amp;lt;c:forEach var=&amp;quot;message&amp;quot; items=&amp;quot;#{facesContext.messageList}&amp;quot;&amp;gt;
            &amp;lt;c:if test=&amp;quot;#{message.severity == &#39;ERROR 2&#39;}&amp;quot;&amp;gt;
                &amp;lt;div class=&amp;quot;alert alert-error&amp;quot;&amp;gt;
                    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; 
                            data-dismiss=&amp;quot;alert&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/button&amp;gt;
                    &amp;lt;h4&amp;gt;#{message.summary}&amp;lt;/h4&amp;gt;
                    #{message.detail}
                &amp;lt;/div&amp;gt;
            &amp;lt;/c:if&amp;gt;
        &amp;lt;/c:forEach&amp;gt;
    &amp;lt;/cc:implementation&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSF合成コンポーネントはinterfaceの部分にコンポーネントの属性を、implementationの部分に実装を書きます。
今回は属性は不要なので、実装部分だけになります。
FacesMessageはFacesContext.messageListから取得します。
コンポーネントはエラーメッセージが設定されている場合のみ表示します。
エラーメッセージはFacesMessage.severityがFacesMessage.SEVERITY_ERRORのものになりますが、
EL式ではStatic fieldを比較値として比較できません。
そのため、FacesMessage.SEVERITY_ERRORの文字列表現である&amp;rsquo;ERROR 2&amp;rsquo;と比較し、一致するものをエラーメッセージとして判定します。
また、複数設定されている場合を考慮して、forEachを利用し、FacesMessageの数だけAlertsコンポーネントを表示します。&lt;/p&gt;

&lt;p&gt;配置したJSF合成コンポーネントは、&lt;a href=&#34;http://java.sun.com/jsf/composite/bootstrap&#34;&gt;http://java.sun.com/jsf/composite/bootstrap&lt;/a&gt; というネームスペースで利用できます。
&lt;a href=&#34;http://java.sun.com/jsf/composite/&#34;&gt;http://java.sun.com/jsf/composite/&lt;/a&gt; にフォルダ名であるbootstrapを付けるだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html xmlns:bs=&amp;quot;http://java.sun.com/jsf/composite/bootstrap&amp;quot;&amp;gt;
    &amp;lt;bs:alert/&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際に表示すると以下のようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kokuzawa.github.io/images/post_image_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;エラーメッセージの右上にクローズボタンが表示され、クリックする事によりメッセージを閉じることができるようになりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FishEyeとCrucible #augj</title>
      <link>https://kokuzawa.github.io/blog/2012/12/16/fisheyetocrucible/</link>
      <pubDate>Sun, 16 Dec 2012 20:40:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/12/16/fisheyetocrucible/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.zusaar.com/event/444403&#34;&gt;Atlassian Advent Calendar 2012&lt;/a&gt;の16日目のエントリーです。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/bohnen&#34;&gt;@bohnen&lt;/a&gt;さんの&lt;a href=&#34;http://qiita.com/items/bea68d04f233f833adfa&#34;&gt;HipChatとJIRAの連携&lt;/a&gt;です。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/yut148&#34;&gt;@yut148&lt;/a&gt;さんです。&lt;/p&gt;

&lt;h2 id=&#34;リポジトリを見るならfisheyeが最高&#34;&gt;リポジトリを見るならFishEyeが最高！&lt;/h2&gt;

&lt;p&gt;ソースコードリポジトリを見るならFishEyeが最高です。といっても他はViewVCしか知らなかったりしますが。
ただし見るだけなら、です。見るだけじゃなくてレビューもできたら最高です。
後述しますが、Atlassianはそんなことも可能にしてくれるCrucibleというFishEyeのプラグインを用意してくれています。&lt;/p&gt;

&lt;h2 id=&#34;だけど制限があります&#34;&gt;だけど制限があります&lt;/h2&gt;

&lt;p&gt;FishEye最高ですが、ライセンスの必要なソフトウェアです。
大きなプロジェクトで予算が潤沢にあれば、ライセンス料の問題は無いでしょうけど、
小さなチームで導入しようとすると、どうしてもスターターライセンスという一番安いライセンスを頼ることになります。
このライセンスは、コミッターは10人まで、リポジトリは5個までという制限があります。
10人以内のチームであれば問題ありませんが、常時10人以内のチームでも何人かの入れ替わりが発生すると、
すぐに10人を超えてしまうかもしれません。&lt;/p&gt;

&lt;p&gt;Gitだと、コミット履歴中のコミッターを書き換える事ができるので、
コミッターを書き換えるのが便利かもしれません。&lt;/p&gt;

&lt;p&gt;SVNはどうなんでしょう？コミッターを書き換えられればGitと同じように出来そうですが、
良くわかりません。ブランチをリポジトリとして参照するなどの方法を取った方が良いかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;crucibleプラグインを使う&#34;&gt;Crucibleプラグインを使う&lt;/h2&gt;

&lt;p&gt;最初に書きましたが、Crucibleはソースコードをレビューする為のプラグインです。
このプラグインを使うと、参照しているソースコード中に行単位でレビューコメントを登録できます。
Crucibleを利用する事で、FishEyeの能力が全開されます。&lt;/p&gt;

&lt;p&gt;Crucibleのレビュー方法は、Author, Moderator, Reviwerの最低3人を設定するところから始まります。
ModeratorはReviwerにはなれません。ただ、Moderatorでもレビューはできます。
小さなチームでは3人をレビューに割り当てるのが効率的ではない場合があります。
そんなときは、AuthorとModeratorを同一人物としています。でもこれが正しいやり方なのかは現在も試行錯誤中です。
ある程度自由に設定できる為に、やり方が何通りも存在してしまい、最適解がなかなか見つかりません。
この辺について何かドキュメントが欲しいところです。&lt;/p&gt;

&lt;h2 id=&#34;でもやっぱり制限がある&#34;&gt;でもやっぱり制限がある&lt;/h2&gt;

&lt;p&gt;ライセンスにもよりますが、Crucibleのスターターライセンスは5ユーザまでという制限があります。
FishEyeがコミッター10人までサポートされているので、単純に考えると5人分のレビューが出来ないことになります。
ですが、管理画面でユーザ毎にCrucibleの適用有無を設定できるので、設定を随時変更する事で、
全員分のレビューを行う事も可能です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ライセンスの制限がある中でやっているので、何かと不便があるのは事実です。
でも、リポジトリの参照とレビュー履歴が一度に見れるこの組み合わせを一度でも体験すると、
他の方法がとれなくなるぐらい魅力的です。とは書いたものの、Crucibleのライセンス、せめてコミッターと同じ数を
許容してもらいたい&amp;hellip;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Point-to-Point on JMS</title>
      <link>https://kokuzawa.github.io/blog/2012/12/15/point-to-point-on-jms/</link>
      <pubDate>Sat, 15 Dec 2012 15:50:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/12/15/point-to-point-on-jms/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://atnd.org/events/33783&#34;&gt;JavaEE Advent Calendar 2012&lt;/a&gt;の15日目のエントリーです。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/yoshioterada&#34;&gt;@yoshioterada&lt;/a&gt;さんの&lt;a href=&#34;http://yoshio3.com/2012/12/14/javaee7-websocket-client-with-javafx/&#34;&gt;Java EE 7 WebSocket Client Sample Application with JavaFX&lt;/a&gt;です。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/akirakoyasu&#34;&gt;@akirakoyasu&lt;/a&gt;さんです。&lt;/p&gt;

&lt;h2 id=&#34;普段は使わないjmsを使う&#34;&gt;普段は使わないJMSを使う&lt;/h2&gt;

&lt;p&gt;おそらくJMSの本来の利用方法は非同期通信を利用した分散処理なのだと思うけど、今回はそんな高尚な目的ではなく、単純なメッセンジャーとして利用します。
世の中のどの位のプロジェクトでJMSが利用されているのか分からないけど、JavaEEの仕様にJMSが含まれているにも関わらず、今まで本格的に利用した事がありません。
分散処理をするケースがあるプロジェクトに参加した事が無いのか、またはサーバがいつもTomcatだからなのか。
おそらく後者なのだと思うけど、ということはつまり分散処理の必要がないプロジェクトということなんだと思います。&lt;/p&gt;

&lt;p&gt;そんな事もあって、JMSの知識が皆無だったわけですが、
JavaEEのアドベンドカレンダーをやるに当たって何か普段は触らないようなことをやりたいなと思い立ち、JMSを使ってみる事にしました。&lt;/p&gt;

&lt;h2 id=&#34;必要なもの&#34;&gt;必要なもの&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GlassFish-3.1.2.2&lt;/li&gt;
&lt;li&gt;jms-api-1.1-rev-1.jar&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;javax.jms&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jms-api&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.1-rev-1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;imq-4.5.2.jar&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.glassfish.mq&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;imq&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.5.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JMSを利用する為には、メッセージプロバイダが必要になります。プロバイダにはOpenMQ, MQSeries, SonicMQなどがありますが、
今回は導入が簡単なOpenMQを利用します。OpenMQはGlassFishに付属してインストールされます。インストール時に特に何かを意識する必要はありません。
また、OpenMQにアクセスする為に2つのライブラリが必要になります。jms-apiとimqです。Mavenリポジトリに登録されているので、
こちらも容易に入手可能です。&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;GlassFishを起動しておく必要があります。ポートとして7676を利用するので、GlassFishがローカルではなく、リモート環境にある場合は、
ポートへのアクセスを許可する必要があるかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;メッセージプロデューサーを作る&#34;&gt;メッセージプロデューサーを作る&lt;/h2&gt;

&lt;p&gt;メッセージを送信するプロデューサーを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package jp.co.baykraft.jmsexample;

import com.sun.messaging.ConnectionConfiguration;
import com.sun.messaging.QueueConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Queue;
import javax.jms.QueueConnection;
import javax.jms.QueueSender;
import javax.jms.QueueSession;
import javax.jms.TextMessage;

/**
 * メッセージを送信するクラスです。
 * @author Katsumi
 */
public class Sender
{
    public static void main(String... args) throws JMSException
    {
        QueueConnectionFactory factory = new QueueConnectionFactory();
        factory.setProperty(ConnectionConfiguration.imqAddressList, 
            &amp;quot;localhost:7676&amp;quot;);
        QueueConnection connection = factory.createQueueConnection();
        QueueSession session = connection.createQueueSession(false, 
            QueueSession.AUTO_ACKNOWLEDGE);
        Queue queue = session.createQueue(&amp;quot;KQueue&amp;quot;);

        QueueSender sender = session.createSender(queue);
        TextMessage message = session.createTextMessage();
        message.setText(&amp;quot;メッセージ&amp;quot;);
        sender.send(message);

        connection.close();

        System.out.println(&amp;quot;Finished.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;session.createQueue(&amp;quot;KQueue&amp;quot;)&lt;/code&gt;でKQueueという文字列を指定していますが、これは任意の文字列です。
メッセージを受信する側でも同じ文字列を指定してメッセージを受け取ります。&lt;/p&gt;

&lt;h2 id=&#34;メッセージコンシューマを作る&#34;&gt;メッセージコンシューマを作る&lt;/h2&gt;

&lt;p&gt;次にメッセージを受信するコンシューマを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package jp.co.baykraft.jmsexample;

import com.sun.messaging.ConnectionConfiguration;
import com.sun.messaging.QueueConnectionFactory;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.Queue;
import javax.jms.QueueConnection;
import javax.jms.QueueReceiver;
import javax.jms.QueueSession;
import javax.jms.TextMessage;

/**
 * メッセージを受診するクラスです。
 * @author Katsumi
 */
public class Receiver
{
    public static void main(String... args) throws JMSException
    {
        QueueConnectionFactory factory = new QueueConnectionFactory();
        factory.setProperty(ConnectionConfiguration.imqAddressList, 
            &amp;quot;localhost:7676&amp;quot;);
        QueueConnection connection = factory.createQueueConnection();
        QueueSession session = connection.createQueueSession(false, 
            QueueSession.CLIENT_ACKNOWLEDGE);
        Queue queue = session.createQueue(&amp;quot;KQueue&amp;quot;);

        QueueReceiver receiver = session.createReceiver(queue);
        receiver.setMessageListener(new MessageListener() {
            @Override
            public void onMessage(Message msg)
            {
                try {
                    TextMessage message = (TextMessage) msg;
                    message.acknowledge();
                    System.out.println(message.getText());
                }
                catch (JMSException ex) {
                    Logger.getLogger(Receiver.class.getName())
                          .log(Level.SEVERE, null, ex);
                }
            }
        });

        connection.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;動かしてみよう&#34;&gt;動かしてみよう&lt;/h2&gt;

&lt;p&gt;さて、コードも作ったので動かしてみます。
送信するメッセージはキューに溜め込まれるので、コンシューマを起動しておかなくても大丈夫です。
まずはプロデューサーを起動すると、「メッセージ」という文字列がメッセージプロバイダに送られます。&lt;/p&gt;

&lt;p&gt;次にコンシューマを起動します。
コンシューマを起動すると、メッセージプロバイダのKQueueに溜め込まれたメッセージが受信されます。
コンシューマのコードの&lt;code&gt;QueueSession.CLIENT_ACKNOWLEDGE&lt;/code&gt;の指定ですが、この指定の場合、
コンシューマ側で&lt;code&gt;TextMessage#acknowledge()&lt;/code&gt;メソッドを呼び出すまで、キュー上のメッセージは削除されません。
コンシューマ側の処理が失敗した場合はキュー上のメッセージを削除したくないのでこの指定にしています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GlassFishを起動するだけでメッセージプロバイダが起動されるのは非常に便利です。
メッセージプロバイダを起動しておけば、簡単なメッセージの送受信アプリが作れます。
キューの名前をコンシューマ毎に切り替えれば、複数クライアントのアプリも出来そうです。
JMSの本来の利用目的とは違うのかもしれませんが、こんな簡単なアプリから触ってみると楽しいと思います。
それにしても、GlassFishは最高ですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WiiRemoteJで遊ぼう on OSX 10.8.7</title>
      <link>https://kokuzawa.github.io/blog/2012/12/11/wiiremotejdeyou-bou-on-osx-10-dot-8-7/</link>
      <pubDate>Tue, 11 Dec 2012 01:46:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/12/11/wiiremotejdeyou-bou-on-osx-10-dot-8-7/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://atnd.org/events/33871&#34;&gt;Java Advent Calendar 2012&lt;/a&gt;の11日目のエントリーです。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/cero_t&#34;&gt;@cero_t&lt;/a&gt;さんです。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/snuffkin&#34;&gt;@snuffkin&lt;/a&gt;さんです。&lt;/p&gt;

&lt;h2 id=&#34;クリスマスだから楽しいことをしよう&#34;&gt;クリスマスだから楽しいことをしよう&lt;/h2&gt;

&lt;p&gt;ということで、WiiUも発売したことだし、今更ながら、WiiRemoteJを取り上げてみたいと思います。
WiiRemoteJはBluetoothを利用して、WiiリモコンでJavaのアプリを操作するためのライブラリです。
最新版はv1.6というのがあるようなのですが、見つけることができなかったため、v1.4を使ってみたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;osx-10-8-7-mountain-lionで動かす&#34;&gt;OSX 10.8.7 Mountain Lionで動かす&lt;/h2&gt;

&lt;p&gt;今回やりたいことは、Macbook Pro上にWiiリモコンのレシーバーとなるアプリを起動し、
Wiiリモコンを使ってそのアプリを操作する、ということです。
レシーバーアプリは下記2つのライブラリが必要になります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://code.google.com/p/bluecove/&#34;&gt;BlueCove.jar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dl.qj.net/wii/homebrew/wiiremotej-v14.html&#34;&gt;WiiRemoteJ.jar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BlueCoveはJavaのBluetoothを利用する為のAPIの規約であるJSR-82の実装ライブラリです。
WiiRemoteJを動かす為に必要になります。
BlueCoveの最新版は2.1.0です。ところがこのBlueCove-2.1.0、Mountain Lion上では動かす事ができません。
Mountain Lionで動かす為には、まだ正式にリリースされていないBlueCove-2.1.1-SNAPSHOTを利用する必要があります。&lt;/p&gt;

&lt;p&gt;ただ、この2.1.1-SNAPSHOTも問題があります。
BlueCoveはBluetoothにアクセスする為に/System/Library/Frameworks/IOBluetooth.frameworkというフレームワークを利用しているのですが、
BlueCove-2.1.1-SNAPSHOTはこのIOBluetooth.frameworkに対応できていないため、実行時にエラーが発生してしまいます。&lt;/p&gt;

&lt;p&gt;という訳で、このままでは実行できそうにありません。
そこで、&lt;a href=&#34;https://groups.google.com/forum/#!msg/bluecove-users/7jWv1V1GC-4/jCHnASj1pbMJ&#34;&gt;ここ&lt;/a&gt;で提供されている、
BlueCove-2.1.1-SNAPSHOTで操作できるIOBluetooth.frameworkに置き換えることにします。
置き換える事により、他のアプリで問題が発生するかもしれません。
置き換える前に、元のIOBluetooth.frameworkのバックアップを作る事をお勧めします。&lt;/p&gt;

&lt;p&gt;さあ、ここまでできれば、あとはレシーバーを作るだけです。&lt;/p&gt;

&lt;h2 id=&#34;レシーバーを実装する&#34;&gt;レシーバーを実装する&lt;/h2&gt;

&lt;p&gt;下記が実装コードになります。動作は単純で、1ボタン、2ボタン、マイナスボタン、プラスボタン、Aボタン、Bボタン、十字キーを押した場合は、
それを標準出力に表示、ホームボタンを押したらレシーバーを終了します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import wiiremotej.WiiRemote;
import wiiremotej.WiiRemoteJ;
import wiiremotej.event.WRAccelerationEvent;
import wiiremotej.event.WRButtonEvent;
import wiiremotej.event.WRStatusEvent;
import wiiremotej.event.WiiRemoteAdapter;
import wiiremotej.event.WiiRemoteDiscoveredEvent;
import wiiremotej.event.WiiRemoteDiscoveryListener;

/**
 * WiiRemoteJサンプルアプリ
 * @author Katsumi
 */
public class Wii extends WiiRemoteAdapter implements WiiRemoteDiscoveryListener
{
    private WiiRemote _remote;

    public static void main(String... args)
    {
        Wii wii = new Wii();
        WiiRemoteJ.findRemotes(wii, 1);
    }

    @Override
    public void wiiRemoteDiscovered(WiiRemoteDiscoveredEvent evt)
    {
        _remote = evt.getWiiRemote();
        try {
            _remote.setAccelerometerEnabled(true);
            _remote.setSpeakerEnabled(true);
            _remote.setLEDIlluminated(0, true);
        }
        catch (IOException | IllegalStateException ex) {
            Logger.getLogger(Wii.class.getName()).log(Level.SEVERE, null, ex);
            if (null != _remote &amp;amp;&amp;amp; _remote.isConnected()) {
                _remote.disconnect();
            }
        }

        _remote.addWiiRemoteListener(this);
    }

    @Override
    public void disconnected()
    {
    }

    @Override
    public void findFinished(int numFound)
    {
    }

    @Override
    public void statusReported(WRStatusEvent evt)
    {
    }

    @Override
    public void accelerationInputReceived(WRAccelerationEvent evt)
    {
    }

    @Override
    public void buttonInputReceived(WRButtonEvent evt)
    {
        if (evt.wasPressed(WRButtonEvent.TWO)) {
            System.out.println(&amp;quot;2&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.ONE)) {
            System.out.println(&amp;quot;1&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.B)) {
            System.out.println(&amp;quot;B&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.A)) {
            System.out.println(&amp;quot;A&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.MINUS)) {
            System.out.println(&amp;quot;Minus&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.PLUS)) {
            System.out.println(&amp;quot;Plus&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.LEFT)) {
            System.out.println(&amp;quot;Left&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.RIGHT)) {
            System.out.println(&amp;quot;Right&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.DOWN)) {
            System.out.println(&amp;quot;Down&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.UP)) {
            System.out.println(&amp;quot;Up&amp;quot;);
        }
        else if (evt.wasPressed(WRButtonEvent.HOME)) {
            if (null != _remote &amp;amp;&amp;amp; _remote.isConnected()) {
                _remote.disconnect();
            }
            System.exit(0);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;レシーバー起動時のVMオプションに下記を設定します。
このオプションを設定しないと、実行時にエラーが発生します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-Dbluecove.jsr82.psm_minimum_off=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;レシーバー起動後にWiiリモコンの電池脇にある赤いSyncボタンを押す必要があります。数秒待つとアプリとWiiリモコンが繋がります。&lt;/p&gt;

&lt;p&gt;実際に動かしているときの動画です。&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/DzjeZHDwMFI&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;本当はボタンを押したらWiiリモコンで音を鳴らすということもしてみたかったのですが、
エラーが出て音源ファイルがWiiリモコンにうまく転送されませんでした。
仕組みとしては、アプリ側からのアクションでWiiリモコン側で音を鳴らす事もできるはずです。
音が出せるようになれば、ちょっとしたパーティーゲームができそうなので、この時期にはもってこいの遊びではないでしょうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OpenJFXをコンパイルしようとして挫折した記録</title>
      <link>https://kokuzawa.github.io/blog/2012/12/07/openjfxwokonnpairusiyoutositecuo-zhe-sitaji-lu/</link>
      <pubDate>Fri, 07 Dec 2012 21:05:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/12/07/openjfxwokonnpairusiyoutositecuo-zhe-sitaji-lu/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://atnd.org/events/33874&#34;&gt;JavaFX Advent Calendar 2012&lt;/a&gt;の7日目のエントリーです。&lt;br /&gt;
昨日は&lt;a href=&#34;https://twitter.com/fukai_yas&#34;&gt;@fukai_yas&lt;/a&gt;さんの「&lt;a href=&#34;http://blog.livedoor.jp/fukai_yas/archives/20772650.html&#34;&gt;AppletでFXMLを使って罠にハマる&lt;/a&gt;」です。&lt;br /&gt;
明日は&lt;a href=&#34;https://twitter.com/btnrouge&#34;&gt;@btnrouge&lt;/a&gt;さんです。&lt;/p&gt;

&lt;h2 id=&#34;joptionpaneが使いたい&#34;&gt;JOptionPaneが使いたい&lt;/h2&gt;

&lt;p&gt;JavaFX 2.2.3で業務に利用する簡単なツールを作っていたのですが、入力エラーを通知する為に、
SwingでいうところのJOptionPane相当のものを探したのですがみつかりませんでした。
誰か知っている人はいないだろうかとTwitterでつぶやいてみたところ、@skrbさんよりこんなお返事を頂きました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/kokuzawa&#34;&gt;@kokuzawa&lt;/a&gt; Project Sandboxというのがあって、そこでJOptionPaneのように使えるDialogクラスを提供してますよ。正式にはJavaFX 8で入る予定です。 &lt;a href=&#34;http://t.co/w6AswYKA&#34;&gt;http://t.co/w6AswYKA&lt;/a&gt;&lt;/p&gt;&amp;mdash; Yuichi Sakuraba (@skrb) &lt;a href=&#34;https://twitter.com/skrb/status/274416797602705408&#34;&gt;2012年11月30日&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Project SandboxでJOptionPane相当のDialogsクラスが提供されているということ。JavaFX 8 に入るらしい。
すばらしい！すばらしいけど、今使いたい。そこでひとまずProject Sandboxを動かしてみる事にしました。&lt;/p&gt;

&lt;h2 id=&#34;openjfxをビルドする&#34;&gt;OpenJFXをビルドする&lt;/h2&gt;

&lt;p&gt;Project SandboxはOpenJFXのSandboxプロジェクトで、これを利用する為には、Mercurialに登録されているソースをコンパイルする必要があるようです。
そこで&lt;a href=&#34;http://openjdk.java.net/projects/openjfx/getting-started.html&#34;&gt;OpenJFXのページ&lt;/a&gt;に書かれているビルド手順を実行します。
でもこれ、記述が古い。JDKのフォルダ構成とか、今のものとはかなり違う。さて困った。&lt;/p&gt;

&lt;p&gt;そこで新たな情報を求めていると、&lt;a href=&#34;https://wikis.oracle.com/display/OpenJDK/Building+OpenJFX&#34;&gt;Building OpenJFX&lt;/a&gt;という、
まさに望んだ通りのページがありました。手順は次のようになります。
また、コンパイルにはJDK 8 が必要です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir -p ~/open-jfx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd ~/open-jfx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hg clone http://hg.openjdk.java.net/openjfx/8/master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir -p artifacts/sdk/rt/lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp -r &amp;lt;PATH TO JDK&amp;gt;/jre/lib/jfxrt.jar artifacts/sdk/rt/lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hg clone http://hg.openjdk.java.net/openjfx/8/master/rt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd rt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ant&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今度こそ、コンパイル出来そうな感じです。最後のantを実行すると、何個かのモジュールのjarが出来上がっていきます。
が、javafx-ui-commonというモジュールのコンパイルが通りません。JDKのバージョンの問題かもしれないと思ったのですが、
JDK 8 はJDK 8 b65というもので、この時点では最新のものです。
ここで1日試行錯誤を繰り返したものの、解決の糸口はなく、ビルドはあきらめる事にしました。&lt;/p&gt;

&lt;h2 id=&#34;やっぱりjoptionpaneが使いたい&#34;&gt;やっぱりJOptionPaneが使いたい&lt;/h2&gt;

&lt;p&gt;OpenJFXのコンパイルにかなりの時間を取られたのですが、本来の目的はJOptionPane相当のものが使いたいだけです。
最初に教えて頂いた&lt;a href=&#34;http://fxexperience.com/2012/10/announcing-the-javafx-ui-controls-sandbox/&#34;&gt;ページ&lt;/a&gt;のコメント欄を読んでいると、
Marco Jakobさんという方がJavaFX 2.2でも利用できるDialogsがあると書いています。やったね、これじゃん！&lt;/p&gt;

&lt;p&gt;ということで、早速&lt;a href=&#34;http://edu.makery.ch/blog/2012/10/30/javafx-2-dialogs/&#34;&gt;リンク先&lt;/a&gt;に行ってみると、
使い方が大変詳しく記述されています。詳しくはリンク先をご覧頂くとして、例えば下記のようなコードを書くだけで、
ダイアログが表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dialogs.showErrorDialog(stage, null, &amp;quot;名前が入力されていません。&amp;quot;, &amp;quot;Error&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;JavaFX 8 になると、これ以外にも業務で利用できそうなTreeTableViewなど、様々なもの増えるようです。
JDK 8 が待ち遠しいですが、現状ではコンパイルもままならないので、今回さわったDialogsクラスをしばらくメインで使わせてもらうつもりです。
しかし、JavaFXはUIが綺麗で楽しくなりますね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>はじめてのLATEX</title>
      <link>https://kokuzawa.github.io/blog/2012/11/24/hazimetefalselatex/</link>
      <pubDate>Sat, 24 Nov 2012 01:25:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/11/24/hazimetefalselatex/</guid>
      <description>

&lt;p&gt;LaTeXって良く目にするんだけれども、それが何なのか、文書作成用の何か程度の知識しかなかった。
何がきっかけだったのかすっかり忘れてしまったけど、今日LaTeXを使ってみようと思い立ち、利用するための環境設定を色々と調べたので、その記録を書き記しておこうと思う。&lt;/p&gt;

&lt;h2 id=&#34;latexって何&#34;&gt;LaTeXって何？&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;LATEX（ラテック、ラテフ、レイテック、レイテックス）とは、レスリー・ランポート (英: Leslie Lamport) によって開発されたテキストベースの組版処理システムである。電子組版ソフトウェア TEX にマクロパッケージを組み込むことによって構築されており、単体の TEX に比べて、より手軽に組版を行うことができるようになっている。なお、LATEX を基にアスキーが日本語処理に対応させたものとして日本語 LATEX が、さらに縦組み処理にも対応させたものとして pLATEX がある。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/LaTeX&#34;&gt;Wikipedia&lt;/a&gt;によれば、組版処理システムということらしい。Wordとかの所謂文書スタイルを制御するものと考えれば良さそう。
ただ、これだけではLaTeXが一体なんなのかがぼんやりとしか分からない。
やっぱり実際に触ってみた方が良さそうだ。&lt;/p&gt;

&lt;h2 id=&#34;macにlatexをインストールする&#34;&gt;MacにLaTeXをインストールする&lt;/h2&gt;

&lt;p&gt;MacでLaTexを使うには何をインストールしたら良いのか？
調べたところ、pTeXというのを入れれば良く、これは縦組み処理も対応したpLATEXと同じもの。
早速インストールしてみよう。インストーラを見つけるよりは、MacPortsを利用した方が早いんじゃないのかと思い、MacPortsで検索してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; sudo port search ptex

pTeX @20110314 (tex, print, textproc, japanese)
    Japanese TeX (pTeX) processing environment

ptex-sfmacros @0 (tex, print, japanese)
    Tategumi/Tateyoko/Kunten packages written by Shinsaku Fujita.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2つ見つけたけど、1つ目の方だろう。インストールする場合はオプションをつけた方が良いとのこと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; sodo port install pTeX +utf8 +motif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長い&amp;hellip;。とても時間がかかるので最初にコーヒーを淹れておけばよかった。ゆっくり飲みながら気長に待つ。
インストールが終わったら、ちゃんとインストールがされたか確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; platex -version

TeX 3.141592-p3.1.10 (utf8.euc) (Web2C 7.5.4)
kpathsea version 3.5.6
ptexenc version 0.997
Copyright (C) 1997-2004 D.E. Knuth.
Kpathsea is copyright (C) 1997-2004 Free Software Foundation, Inc.
There is NO warranty.  Redistribution of this software is
covered by the terms of both the pTeX copyright and
the GNU General Public License.
For more information about these matters, see the files
named COPYING and the pTeX source.
Primary author of TeX: D.E. Knuth.
Kpathsea written by Karl Berry and others.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ああ、やっとインストールできた。&lt;/p&gt;

&lt;h2 id=&#34;使ってみよう&#34;&gt;使ってみよう&lt;/h2&gt;

&lt;p&gt;LaTeXを使うには、まず素となるテキストを作る必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\documentclass[a4paper,12pt]{jarticle}
\begin{document}
本文です。
\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;firstdoc.texという名前で保存。tex拡張子はおそらく慣習？
これをplatexでコンパイルする。コンパイルという言葉が正しいかどうかは分からないけど。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; platex firstdoc.tex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、拡張子がDVIの中間ファイルが生成される。
このファイルはプレビューすることができて、どんな組版になったのかを確認できるようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; xdvi firstdoc.dvi

Error: Can&#39;t open display:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーが出た。Macの場合、ターミナルでプレビューを見ようとしてもダメらしく、
プレビューを見るにはX11をインストールする必要があるらしい。
今更X11はインストールしたくないので、別の方法で確認してみようと思う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; dvipdf firstdoc.dvi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、PDFファイルを生成するためのコマンド。実行するとPDFファイルが生成されるので、それを開く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; open firstdoc.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでプレビューアプリでfirstdoc.pdfを開くことができる。
PDFは開いたままファイルを修正して、platex -&amp;gt; dvipdf でもう一回PDFを生成すると、
開いているPDFが更新される。これで組版の確認をすることができるようになった。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;たいした内容を書かなくても、それっぽいドキュメントを作ることができるのはありがたい。
あと、文章を作る行程がプログラミングのようで、これもなかなか楽しいし、
素となるファイルがバイナリではないので、版数管理もし易そうだ。
組版をするにはいろいろと覚えることが多そうだけど、それを差し引いてもすばらしい。&lt;/p&gt;

&lt;h2 id=&#34;参考サイト&#34;&gt;参考サイト&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://keizai.xrea.jp/latex/tutorial/index.html&#34;&gt;http://keizai.xrea.jp/latex/tutorial/index.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GlassFish3.1.2へのデプロイ時のエラー</title>
      <link>https://kokuzawa.github.io/blog/2012/11/10/glassfishhefalsedepuroishi-falseera/</link>
      <pubDate>Sat, 10 Nov 2012 07:44:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/11/10/glassfishhefalsedepuroishi-falseera/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent.ExecutionException: com.sun.faces.config.ConfigurationException: Unable to parse document &amp;lsquo;bundle://213.0:1/com/sun/faces/jsf-ri-runtime.xml&amp;rsquo;: DTD factory class org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl does not extend from DTDDVFactory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSFを利用していると発生しているようなので、warファイル内のjavax.faces-2.1.4.jarを取り除いて再度デプロイ。でも変化なし。
（JSFのライブラリはGlassFishに含まれている。バージョンはわからないけど）&lt;/p&gt;

&lt;p&gt;何度か再デプロイをしていると起動できるので、それほど真剣に調べていなかったけど、本腰をいれて調べてみることにした。&lt;/p&gt;

&lt;h3 id=&#34;結果&#34;&gt;結果&lt;/h3&gt;

&lt;p&gt;ログを見ると&lt;code&gt;org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl&lt;/code&gt;関係でエラーが発生して&lt;code&gt;bundle://213.0:1/com/sun/faces/jsf-ri-runtime.xml&lt;/code&gt;がパースできないことがわかる。&lt;/p&gt;

&lt;p&gt;っていうか&lt;code&gt;bundle://213.0:1/com/sun/faces/jsf-ri-runtime.xml&lt;/code&gt;って何だろう？ひとまずこれについてはあとで調査。&lt;/p&gt;

&lt;p&gt;おそらくGlassFishで利用しているXMLパーサとぶつかっているせいだと思う。warファイル内からxercesImpl-2.8.1.jarを取り除いてデプロイしたところ正常に起動ができた。
取り除いても正常に起動できたのでXMLパーサがGlassFishに含まれてるのは間違いないと推測できるが、GlassFishのどこにXMLパーサが含まれているのかがわからない。&lt;/p&gt;

&lt;h4 id=&#34;追記-nov-11-2012&#34;&gt;追記: Nov 11, 2012&lt;/h4&gt;

&lt;p&gt;運用環境はTomcatだからxercesImpl-2.8.1.jarを取り除いちゃダメなんじゃないかと思う。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>複合キーを使ったOrderBy</title>
      <link>https://kokuzawa.github.io/blog/2012/11/07/fu-he-kiwoshi-tutaorderby/</link>
      <pubDate>Wed, 07 Nov 2012 00:56:00 +0900</pubDate>
      
      <guid>https://kokuzawa.github.io/blog/2012/11/07/fu-he-kiwoshi-tutaorderby/</guid>
      <description>

&lt;p&gt;JPAで複合キークラスを使ってOrderByをやろうとしたら、メタデータの設定方法が分からなかったんだけど、分かってみれば簡単な話だった。&lt;/p&gt;

&lt;h3 id=&#34;複合キーって何&#34;&gt;複合キーって何？&lt;/h3&gt;

&lt;p&gt;JPAのエンティティには複数の@Idアノテーションが付与できないので、DBのテーブルに主キーが複数ある場合はその主キーをひとまとめにしたクラスを作成する。エンティティ上では、@EmbeddedIdアノテーションを付与すれば、その作成クラスを主キーとして指定できる。これを複合キーといって、実際には下記のようなクラス構成となる。（EntityPK.javaが複合キー）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
public class Entity
{
    @EmbeddedId
    private EntityPK entityPK;

    public EntityPK getEntityPK()
    {
        return entityPK;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Embeddable
public class EntityPK implements Serializable
{
    @Column
    private Integer key1;

    @Column
    private Integer key2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;criteriaqueryでsqlを構築&#34;&gt;CriteriaQueryでSQLを構築&lt;/h3&gt;

&lt;p&gt;この複合キーがあるエンティティに対してCriteriaQueryを使ってSQLを構築する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final CriteriaBuilder cb = entityManager.getCriteriaBuilder();
final CriteriaQuery&amp;lt;Entity&amp;gt; query = cb.createQuery(Entity.class);
final Root&amp;lt;Entity&amp;gt; root = query.from(Entity.class);
query.select(root).orderBy(cb.asc(root.get(Entity_.entityPK)
    .get(EntityPK_.key1)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでポイントとなるのが、key1でソートしようとした場合、いきなり
&lt;code&gt;cb.asc(root.get(EntityPK_.key1))&lt;/code&gt; と指定はできないので、
&lt;code&gt;cb.asc(root.get(Entity_.entityPK).get(EntityPK_.key1))&lt;/code&gt;
のように連鎖した呼び出しにする必要がある、ということ。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

